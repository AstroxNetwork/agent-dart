#![allow(
    non_camel_case_types,
    unused,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::double_parens,
    non_snake_case,
    clippy::too_many_arguments
)]
// AUTO GENERATED FILE, DO NOT EDIT.
// Generated by `flutter_rust_bridge`@ 1.82.6.

use crate::api::*;
use core::panic::UnwindSafe;
use flutter_rust_bridge::rust2dart::IntoIntoDart;
use flutter_rust_bridge::*;
use std::ffi::c_void;
use std::sync::Arc;

// Section: imports

use crate::sha::bdk::blockchain::BlockchainConfig;
use crate::sha::bdk::blockchain::ElectrumConfig;
use crate::sha::bdk::blockchain::EsploraConfig;
use crate::sha::bdk::blockchain::RpcConfig;
use crate::sha::bdk::blockchain::RpcSyncParams;
use crate::sha::bdk::blockchain::UserPass;
use crate::sha::bdk::types::AddressIndex;
use crate::sha::bdk::types::AddressInfo;
use crate::sha::bdk::types::Balance;
use crate::sha::bdk::types::BdkTxBuilderResult;
use crate::sha::bdk::types::BlockTime;
use crate::sha::bdk::types::ChangeSpendPolicy;
use crate::sha::bdk::types::ForeignUtxo;
use crate::sha::bdk::types::KeychainKind;
use crate::sha::bdk::types::Network;
use crate::sha::bdk::types::OutPoint;
use crate::sha::bdk::types::Payload;
use crate::sha::bdk::types::RbfValue;
use crate::sha::bdk::types::Script;
use crate::sha::bdk::types::ScriptAmount;
use crate::sha::bdk::types::TransactionDetails;
use crate::sha::bdk::types::TxBytes;
use crate::sha::bdk::types::TxIn;
use crate::sha::bdk::types::TxOut;
use crate::sha::bdk::types::TxOutForeign;
use crate::sha::bdk::types::WitnessVersion;
use crate::sha::bdk::types::WordCount;
use crate::sha::bdk::wallet::DatabaseConfig;
use crate::sha::bdk::wallet::LocalUtxo;
use crate::sha::bdk::wallet::SignOptions;
use crate::sha::bdk::wallet::SledDbConfiguration;
use crate::sha::bdk::wallet::SqliteDbConfiguration;
use crate::sha::p256::P256IdentityExport;
use crate::sha::schnorr::SchnorrIdentityExport;
use crate::sha::secp256k1::Secp256k1IdentityExport;
use crate::sha::types::AesDecryptReq;
use crate::sha::types::AesEncryptReq;
use crate::sha::types::BLSVerifyReq;
use crate::sha::types::ED25519FromSeedReq;
use crate::sha::types::ED25519Res;
use crate::sha::types::ED25519SignReq;
use crate::sha::types::ED25519VerifyReq;
use crate::sha::types::KeyDerivedRes;
use crate::sha::types::P256FromSeedReq;
use crate::sha::types::P256ShareSecretReq;
use crate::sha::types::P256SignWithSeedReq;
use crate::sha::types::P256VerifyReq;
use crate::sha::types::PBKDFDeriveReq;
use crate::sha::types::PhraseToSeedReq;
use crate::sha::types::SchnorrFromSeedReq;
use crate::sha::types::SchnorrSignWithSeedReq;
use crate::sha::types::SchnorrVerifyReq;
use crate::sha::types::ScriptDeriveReq;
use crate::sha::types::Secp256k1FromSeedReq;
use crate::sha::types::Secp256k1RecoverReq;
use crate::sha::types::Secp256k1ShareSecretReq;
use crate::sha::types::Secp256k1SignWithRngReq;
use crate::sha::types::Secp256k1SignWithSeedReq;
use crate::sha::types::Secp256k1VerifyReq;
use crate::sha::types::SeedToKeyReq;
use crate::sha::types::SignatureFFI;

// Section: wire functions

fn wire_mnemonic_phrase_to_seed_impl(
    port_: MessagePort,
    req: impl Wire2Api<PhraseToSeedReq> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, Vec<u8>, _>(
        WrapInfo {
            debug_name: "mnemonic_phrase_to_seed",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Result::<_, ()>::Ok(mnemonic_phrase_to_seed(api_req))
        },
    )
}
fn wire_mnemonic_seed_to_key_impl(
    port_: MessagePort,
    req: impl Wire2Api<SeedToKeyReq> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, Vec<u8>, _>(
        WrapInfo {
            debug_name: "mnemonic_seed_to_key",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Result::<_, ()>::Ok(mnemonic_seed_to_key(api_req))
        },
    )
}
fn wire_bls_init_impl(port_: MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, bool, _>(
        WrapInfo {
            debug_name: "bls_init",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || move |task_callback| Result::<_, ()>::Ok(bls_init()),
    )
}
fn wire_bls_verify_impl(port_: MessagePort, req: impl Wire2Api<BLSVerifyReq> + UnwindSafe) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, bool, _>(
        WrapInfo {
            debug_name: "bls_verify",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Result::<_, ()>::Ok(bls_verify(api_req))
        },
    )
}
fn wire_ed25519_from_seed_impl(
    port_: MessagePort,
    req: impl Wire2Api<ED25519FromSeedReq> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, ED25519Res, _>(
        WrapInfo {
            debug_name: "ed25519_from_seed",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Result::<_, ()>::Ok(ed25519_from_seed(api_req))
        },
    )
}
fn wire_ed25519_sign_impl(port_: MessagePort, req: impl Wire2Api<ED25519SignReq> + UnwindSafe) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, Vec<u8>, _>(
        WrapInfo {
            debug_name: "ed25519_sign",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Result::<_, ()>::Ok(ed25519_sign(api_req))
        },
    )
}
fn wire_ed25519_verify_impl(port_: MessagePort, req: impl Wire2Api<ED25519VerifyReq> + UnwindSafe) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, bool, _>(
        WrapInfo {
            debug_name: "ed25519_verify",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Result::<_, ()>::Ok(ed25519_verify(api_req))
        },
    )
}
fn wire_secp256k1_from_seed_impl(
    port_: MessagePort,
    req: impl Wire2Api<Secp256k1FromSeedReq> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, Secp256k1IdentityExport, _>(
        WrapInfo {
            debug_name: "secp256k1_from_seed",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Result::<_, ()>::Ok(secp256k1_from_seed(api_req))
        },
    )
}
fn wire_secp256k1_sign_impl(
    port_: MessagePort,
    req: impl Wire2Api<Secp256k1SignWithSeedReq> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, SignatureFFI, _>(
        WrapInfo {
            debug_name: "secp256k1_sign",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Result::<_, ()>::Ok(secp256k1_sign(api_req))
        },
    )
}
fn wire_secp256k1_sign_with_rng_impl(
    port_: MessagePort,
    req: impl Wire2Api<Secp256k1SignWithRngReq> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, SignatureFFI, _>(
        WrapInfo {
            debug_name: "secp256k1_sign_with_rng",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Result::<_, ()>::Ok(secp256k1_sign_with_rng(api_req))
        },
    )
}
fn wire_secp256k1_sign_recoverable_impl(
    port_: MessagePort,
    req: impl Wire2Api<Secp256k1SignWithSeedReq> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, SignatureFFI, _>(
        WrapInfo {
            debug_name: "secp256k1_sign_recoverable",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Result::<_, ()>::Ok(secp256k1_sign_recoverable(api_req))
        },
    )
}
fn wire_secp256k1_verify_impl(
    port_: MessagePort,
    req: impl Wire2Api<Secp256k1VerifyReq> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, bool, _>(
        WrapInfo {
            debug_name: "secp256k1_verify",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Result::<_, ()>::Ok(secp256k1_verify(api_req))
        },
    )
}
fn wire_secp256k1_get_shared_secret_impl(
    port_: MessagePort,
    req: impl Wire2Api<Secp256k1ShareSecretReq> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, Vec<u8>, _>(
        WrapInfo {
            debug_name: "secp256k1_get_shared_secret",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Result::<_, ()>::Ok(secp256k1_get_shared_secret(api_req))
        },
    )
}
fn wire_secp256k1_recover_impl(
    port_: MessagePort,
    req: impl Wire2Api<Secp256k1RecoverReq> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, Vec<u8>, _>(
        WrapInfo {
            debug_name: "secp256k1_recover",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Result::<_, ()>::Ok(secp256k1_recover(api_req))
        },
    )
}
fn wire_p256_from_seed_impl(port_: MessagePort, req: impl Wire2Api<P256FromSeedReq> + UnwindSafe) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, P256IdentityExport, _>(
        WrapInfo {
            debug_name: "p256_from_seed",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Result::<_, ()>::Ok(p256_from_seed(api_req))
        },
    )
}
fn wire_p256_sign_impl(port_: MessagePort, req: impl Wire2Api<P256SignWithSeedReq> + UnwindSafe) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, SignatureFFI, _>(
        WrapInfo {
            debug_name: "p256_sign",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Result::<_, ()>::Ok(p256_sign(api_req))
        },
    )
}
fn wire_p256_verify_impl(port_: MessagePort, req: impl Wire2Api<P256VerifyReq> + UnwindSafe) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, bool, _>(
        WrapInfo {
            debug_name: "p256_verify",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Result::<_, ()>::Ok(p256_verify(api_req))
        },
    )
}
fn wire_p256_get_shared_secret_impl(
    port_: MessagePort,
    req: impl Wire2Api<P256ShareSecretReq> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, Vec<u8>, _>(
        WrapInfo {
            debug_name: "p256_get_shared_secret",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Result::<_, ()>::Ok(p256_get_shared_secret(api_req))
        },
    )
}
fn wire_schnorr_from_seed_impl(
    port_: MessagePort,
    req: impl Wire2Api<SchnorrFromSeedReq> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, SchnorrIdentityExport, _>(
        WrapInfo {
            debug_name: "schnorr_from_seed",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Result::<_, ()>::Ok(schnorr_from_seed(api_req))
        },
    )
}
fn wire_schnorr_sign_impl(
    port_: MessagePort,
    req: impl Wire2Api<SchnorrSignWithSeedReq> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, SignatureFFI, _>(
        WrapInfo {
            debug_name: "schnorr_sign",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Result::<_, ()>::Ok(schnorr_sign(api_req))
        },
    )
}
fn wire_schnorr_verify_impl(port_: MessagePort, req: impl Wire2Api<SchnorrVerifyReq> + UnwindSafe) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, bool, _>(
        WrapInfo {
            debug_name: "schnorr_verify",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Result::<_, ()>::Ok(schnorr_verify(api_req))
        },
    )
}
fn wire_aes_128_ctr_encrypt_impl(
    port_: MessagePort,
    req: impl Wire2Api<AesEncryptReq> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, Vec<u8>, _>(
        WrapInfo {
            debug_name: "aes_128_ctr_encrypt",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Result::<_, ()>::Ok(aes_128_ctr_encrypt(api_req))
        },
    )
}
fn wire_aes_128_ctr_decrypt_impl(
    port_: MessagePort,
    req: impl Wire2Api<AesDecryptReq> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, Vec<u8>, _>(
        WrapInfo {
            debug_name: "aes_128_ctr_decrypt",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Result::<_, ()>::Ok(aes_128_ctr_decrypt(api_req))
        },
    )
}
fn wire_aes_256_cbc_encrypt_impl(
    port_: MessagePort,
    req: impl Wire2Api<AesEncryptReq> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, Vec<u8>, _>(
        WrapInfo {
            debug_name: "aes_256_cbc_encrypt",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Result::<_, ()>::Ok(aes_256_cbc_encrypt(api_req))
        },
    )
}
fn wire_aes_256_cbc_decrypt_impl(
    port_: MessagePort,
    req: impl Wire2Api<AesDecryptReq> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, Vec<u8>, _>(
        WrapInfo {
            debug_name: "aes_256_cbc_decrypt",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Result::<_, ()>::Ok(aes_256_cbc_decrypt(api_req))
        },
    )
}
fn wire_aes_256_gcm_encrypt_impl(
    port_: MessagePort,
    req: impl Wire2Api<AesEncryptReq> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, Vec<u8>, _>(
        WrapInfo {
            debug_name: "aes_256_gcm_encrypt",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Result::<_, ()>::Ok(aes_256_gcm_encrypt(api_req))
        },
    )
}
fn wire_aes_256_gcm_decrypt_impl(
    port_: MessagePort,
    req: impl Wire2Api<AesDecryptReq> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, Vec<u8>, _>(
        WrapInfo {
            debug_name: "aes_256_gcm_decrypt",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Result::<_, ()>::Ok(aes_256_gcm_decrypt(api_req))
        },
    )
}
fn wire_pbkdf2_derive_key_impl(
    port_: MessagePort,
    req: impl Wire2Api<PBKDFDeriveReq> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, KeyDerivedRes, _>(
        WrapInfo {
            debug_name: "pbkdf2_derive_key",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Result::<_, ()>::Ok(pbkdf2_derive_key(api_req))
        },
    )
}
fn wire_scrypt_derive_key_impl(
    port_: MessagePort,
    req: impl Wire2Api<ScriptDeriveReq> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, KeyDerivedRes, _>(
        WrapInfo {
            debug_name: "scrypt_derive_key",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Result::<_, ()>::Ok(scrypt_derive_key(api_req))
        },
    )
}
fn wire_create_blockchain__static_method__Api_impl(
    port_: MessagePort,
    config: impl Wire2Api<BlockchainConfig> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, RustOpaque<BlockchainInstance>, _>(
        WrapInfo {
            debug_name: "create_blockchain__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_config = config.wire2api();
            move |task_callback| Api::create_blockchain(api_config)
        },
    )
}
fn wire_get_height__static_method__Api_impl(
    port_: MessagePort,
    blockchain: impl Wire2Api<RustOpaque<BlockchainInstance>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, u32, _>(
        WrapInfo {
            debug_name: "get_height__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_blockchain = blockchain.wire2api();
            move |task_callback| Api::get_height(api_blockchain)
        },
    )
}
fn wire_get_blockchain_hash__static_method__Api_impl(
    port_: MessagePort,
    blockchain_height: impl Wire2Api<u32> + UnwindSafe,
    blockchain: impl Wire2Api<RustOpaque<BlockchainInstance>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, String, _>(
        WrapInfo {
            debug_name: "get_blockchain_hash__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_blockchain_height = blockchain_height.wire2api();
            let api_blockchain = blockchain.wire2api();
            move |task_callback| Api::get_blockchain_hash(api_blockchain_height, api_blockchain)
        },
    )
}
fn wire_estimate_fee__static_method__Api_impl(
    port_: MessagePort,
    target: impl Wire2Api<u64> + UnwindSafe,
    blockchain: impl Wire2Api<RustOpaque<BlockchainInstance>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, f32, _>(
        WrapInfo {
            debug_name: "estimate_fee__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_target = target.wire2api();
            let api_blockchain = blockchain.wire2api();
            move |task_callback| Api::estimate_fee(api_target, api_blockchain)
        },
    )
}
fn wire_broadcast__static_method__Api_impl(
    port_: MessagePort,
    tx: impl Wire2Api<String> + UnwindSafe,
    blockchain: impl Wire2Api<RustOpaque<BlockchainInstance>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, String, _>(
        WrapInfo {
            debug_name: "broadcast__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_tx = tx.wire2api();
            let api_blockchain = blockchain.wire2api();
            move |task_callback| Api::broadcast(api_tx, api_blockchain)
        },
    )
}
fn wire_get_tx__static_method__Api_impl(
    port_: MessagePort,
    tx: impl Wire2Api<String> + UnwindSafe,
    blockchain: impl Wire2Api<RustOpaque<BlockchainInstance>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, String, _>(
        WrapInfo {
            debug_name: "get_tx__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_tx = tx.wire2api();
            let api_blockchain = blockchain.wire2api();
            move |task_callback| Api::get_tx(api_tx, api_blockchain)
        },
    )
}
fn wire_create_transaction__static_method__Api_impl(
    port_: MessagePort,
    tx: impl Wire2Api<Vec<u8>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, String, _>(
        WrapInfo {
            debug_name: "create_transaction__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_tx = tx.wire2api();
            move |task_callback| Api::create_transaction(api_tx)
        },
    )
}
fn wire_tx_txid__static_method__Api_impl(
    port_: MessagePort,
    tx: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, String, _>(
        WrapInfo {
            debug_name: "tx_txid__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_tx = tx.wire2api();
            move |task_callback| Api::tx_txid(api_tx)
        },
    )
}
fn wire_weight__static_method__Api_impl(
    port_: MessagePort,
    tx: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, u64, _>(
        WrapInfo {
            debug_name: "weight__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_tx = tx.wire2api();
            move |task_callback| Result::<_, ()>::Ok(Api::weight(api_tx))
        },
    )
}
fn wire_size__static_method__Api_impl(port_: MessagePort, tx: impl Wire2Api<String> + UnwindSafe) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, u64, _>(
        WrapInfo {
            debug_name: "size__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_tx = tx.wire2api();
            move |task_callback| Result::<_, ()>::Ok(Api::size(api_tx))
        },
    )
}
fn wire_vsize__static_method__Api_impl(port_: MessagePort, tx: impl Wire2Api<String> + UnwindSafe) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, u64, _>(
        WrapInfo {
            debug_name: "vsize__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_tx = tx.wire2api();
            move |task_callback| Result::<_, ()>::Ok(Api::vsize(api_tx))
        },
    )
}
fn wire_serialize_tx__static_method__Api_impl(
    port_: MessagePort,
    tx: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, Vec<u8>, _>(
        WrapInfo {
            debug_name: "serialize_tx__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_tx = tx.wire2api();
            move |task_callback| Result::<_, ()>::Ok(Api::serialize_tx(api_tx))
        },
    )
}
fn wire_is_coin_base__static_method__Api_impl(
    port_: MessagePort,
    tx: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, bool, _>(
        WrapInfo {
            debug_name: "is_coin_base__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_tx = tx.wire2api();
            move |task_callback| Result::<_, ()>::Ok(Api::is_coin_base(api_tx))
        },
    )
}
fn wire_is_explicitly_rbf__static_method__Api_impl(
    port_: MessagePort,
    tx: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, bool, _>(
        WrapInfo {
            debug_name: "is_explicitly_rbf__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_tx = tx.wire2api();
            move |task_callback| Result::<_, ()>::Ok(Api::is_explicitly_rbf(api_tx))
        },
    )
}
fn wire_is_lock_time_enabled__static_method__Api_impl(
    port_: MessagePort,
    tx: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, bool, _>(
        WrapInfo {
            debug_name: "is_lock_time_enabled__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_tx = tx.wire2api();
            move |task_callback| Result::<_, ()>::Ok(Api::is_lock_time_enabled(api_tx))
        },
    )
}
fn wire_version__static_method__Api_impl(
    port_: MessagePort,
    tx: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, i32, _>(
        WrapInfo {
            debug_name: "version__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_tx = tx.wire2api();
            move |task_callback| Result::<_, ()>::Ok(Api::version(api_tx))
        },
    )
}
fn wire_lock_time__static_method__Api_impl(
    port_: MessagePort,
    tx: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, u32, _>(
        WrapInfo {
            debug_name: "lock_time__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_tx = tx.wire2api();
            move |task_callback| Result::<_, ()>::Ok(Api::lock_time(api_tx))
        },
    )
}
fn wire_input__static_method__Api_impl(port_: MessagePort, tx: impl Wire2Api<String> + UnwindSafe) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, Vec<TxIn>, _>(
        WrapInfo {
            debug_name: "input__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_tx = tx.wire2api();
            move |task_callback| Result::<_, ()>::Ok(Api::input(api_tx))
        },
    )
}
fn wire_output__static_method__Api_impl(
    port_: MessagePort,
    tx: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, Vec<TxOut>, _>(
        WrapInfo {
            debug_name: "output__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_tx = tx.wire2api();
            move |task_callback| Result::<_, ()>::Ok(Api::output(api_tx))
        },
    )
}
fn wire_serialize_psbt__static_method__Api_impl(
    port_: MessagePort,
    psbt_str: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, String, _>(
        WrapInfo {
            debug_name: "serialize_psbt__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_psbt_str = psbt_str.wire2api();
            move |task_callback| Api::serialize_psbt(api_psbt_str)
        },
    )
}
fn wire_psbt_txid__static_method__Api_impl(
    port_: MessagePort,
    psbt_str: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, String, _>(
        WrapInfo {
            debug_name: "psbt_txid__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_psbt_str = psbt_str.wire2api();
            move |task_callback| Api::psbt_txid(api_psbt_str)
        },
    )
}
fn wire_extract_tx__static_method__Api_impl(
    port_: MessagePort,
    psbt_str: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, String, _>(
        WrapInfo {
            debug_name: "extract_tx__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_psbt_str = psbt_str.wire2api();
            move |task_callback| Api::extract_tx(api_psbt_str)
        },
    )
}
fn wire_psbt_fee_rate__static_method__Api_impl(
    port_: MessagePort,
    psbt_str: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, Option<f32>, _>(
        WrapInfo {
            debug_name: "psbt_fee_rate__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_psbt_str = psbt_str.wire2api();
            move |task_callback| Result::<_, ()>::Ok(Api::psbt_fee_rate(api_psbt_str))
        },
    )
}
fn wire_psbt_fee_amount__static_method__Api_impl(
    port_: MessagePort,
    psbt_str: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, Option<u64>, _>(
        WrapInfo {
            debug_name: "psbt_fee_amount__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_psbt_str = psbt_str.wire2api();
            move |task_callback| Result::<_, ()>::Ok(Api::psbt_fee_amount(api_psbt_str))
        },
    )
}
fn wire_combine_psbt__static_method__Api_impl(
    port_: MessagePort,
    psbt_str: impl Wire2Api<String> + UnwindSafe,
    other: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, String, _>(
        WrapInfo {
            debug_name: "combine_psbt__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_psbt_str = psbt_str.wire2api();
            let api_other = other.wire2api();
            move |task_callback| Api::combine_psbt(api_psbt_str, api_other)
        },
    )
}
fn wire_json_serialize__static_method__Api_impl(
    port_: MessagePort,
    psbt_str: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, String, _>(
        WrapInfo {
            debug_name: "json_serialize__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_psbt_str = psbt_str.wire2api();
            move |task_callback| Api::json_serialize(api_psbt_str)
        },
    )
}
fn wire_get_inputs__static_method__Api_impl(
    port_: MessagePort,
    psbt_str: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, Vec<TxOut>, _>(
        WrapInfo {
            debug_name: "get_inputs__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_psbt_str = psbt_str.wire2api();
            move |task_callback| Api::get_inputs(api_psbt_str)
        },
    )
}
fn wire_tx_builder_finish__static_method__Api_impl(
    port_: MessagePort,
    wallet: impl Wire2Api<RustOpaque<WalletInstance>> + UnwindSafe,
    recipients: impl Wire2Api<Vec<ScriptAmount>> + UnwindSafe,
    txs: impl Wire2Api<Vec<TxBytes>> + UnwindSafe,
    unspendable: impl Wire2Api<Vec<OutPoint>> + UnwindSafe,
    foreign_utxos: impl Wire2Api<Vec<ForeignUtxo>> + UnwindSafe,
    change_policy: impl Wire2Api<ChangeSpendPolicy> + UnwindSafe,
    manually_selected_only: impl Wire2Api<bool> + UnwindSafe,
    fee_rate: impl Wire2Api<Option<f32>> + UnwindSafe,
    fee_absolute: impl Wire2Api<Option<u64>> + UnwindSafe,
    drain_wallet: impl Wire2Api<bool> + UnwindSafe,
    drain_to: impl Wire2Api<Option<Script>> + UnwindSafe,
    rbf: impl Wire2Api<Option<RbfValue>> + UnwindSafe,
    data: impl Wire2Api<Vec<u8>> + UnwindSafe,
    shuffle_utxo: impl Wire2Api<Option<bool>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, BdkTxBuilderResult, _>(
        WrapInfo {
            debug_name: "tx_builder_finish__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_wallet = wallet.wire2api();
            let api_recipients = recipients.wire2api();
            let api_txs = txs.wire2api();
            let api_unspendable = unspendable.wire2api();
            let api_foreign_utxos = foreign_utxos.wire2api();
            let api_change_policy = change_policy.wire2api();
            let api_manually_selected_only = manually_selected_only.wire2api();
            let api_fee_rate = fee_rate.wire2api();
            let api_fee_absolute = fee_absolute.wire2api();
            let api_drain_wallet = drain_wallet.wire2api();
            let api_drain_to = drain_to.wire2api();
            let api_rbf = rbf.wire2api();
            let api_data = data.wire2api();
            let api_shuffle_utxo = shuffle_utxo.wire2api();
            move |task_callback| {
                Api::tx_builder_finish(
                    api_wallet,
                    api_recipients,
                    api_txs,
                    api_unspendable,
                    api_foreign_utxos,
                    api_change_policy,
                    api_manually_selected_only,
                    api_fee_rate,
                    api_fee_absolute,
                    api_drain_wallet,
                    api_drain_to,
                    api_rbf,
                    api_data,
                    api_shuffle_utxo,
                )
            }
        },
    )
}
fn wire_tx_cal_fee_finish__static_method__Api_impl(
    port_: MessagePort,
    wallet: impl Wire2Api<RustOpaque<WalletInstance>> + UnwindSafe,
    recipients: impl Wire2Api<Vec<ScriptAmount>> + UnwindSafe,
    txs: impl Wire2Api<Vec<TxBytes>> + UnwindSafe,
    unspendable: impl Wire2Api<Vec<OutPoint>> + UnwindSafe,
    foreign_utxos: impl Wire2Api<Vec<ForeignUtxo>> + UnwindSafe,
    change_policy: impl Wire2Api<ChangeSpendPolicy> + UnwindSafe,
    manually_selected_only: impl Wire2Api<bool> + UnwindSafe,
    fee_rate: impl Wire2Api<Option<f32>> + UnwindSafe,
    fee_absolute: impl Wire2Api<Option<u64>> + UnwindSafe,
    drain_wallet: impl Wire2Api<bool> + UnwindSafe,
    drain_to: impl Wire2Api<Option<Script>> + UnwindSafe,
    rbf: impl Wire2Api<Option<RbfValue>> + UnwindSafe,
    data: impl Wire2Api<Vec<u8>> + UnwindSafe,
    shuffle_utxo: impl Wire2Api<Option<bool>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, u64, _>(
        WrapInfo {
            debug_name: "tx_cal_fee_finish__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_wallet = wallet.wire2api();
            let api_recipients = recipients.wire2api();
            let api_txs = txs.wire2api();
            let api_unspendable = unspendable.wire2api();
            let api_foreign_utxos = foreign_utxos.wire2api();
            let api_change_policy = change_policy.wire2api();
            let api_manually_selected_only = manually_selected_only.wire2api();
            let api_fee_rate = fee_rate.wire2api();
            let api_fee_absolute = fee_absolute.wire2api();
            let api_drain_wallet = drain_wallet.wire2api();
            let api_drain_to = drain_to.wire2api();
            let api_rbf = rbf.wire2api();
            let api_data = data.wire2api();
            let api_shuffle_utxo = shuffle_utxo.wire2api();
            move |task_callback| {
                Api::tx_cal_fee_finish(
                    api_wallet,
                    api_recipients,
                    api_txs,
                    api_unspendable,
                    api_foreign_utxos,
                    api_change_policy,
                    api_manually_selected_only,
                    api_fee_rate,
                    api_fee_absolute,
                    api_drain_wallet,
                    api_drain_to,
                    api_rbf,
                    api_data,
                    api_shuffle_utxo,
                )
            }
        },
    )
}
fn wire_bump_fee_tx_builder_finish__static_method__Api_impl(
    port_: MessagePort,
    txid: impl Wire2Api<String> + UnwindSafe,
    fee_rate: impl Wire2Api<f32> + UnwindSafe,
    allow_shrinking: impl Wire2Api<Option<String>> + UnwindSafe,
    wallet: impl Wire2Api<RustOpaque<WalletInstance>> + UnwindSafe,
    enable_rbf: impl Wire2Api<bool> + UnwindSafe,
    keep_change: impl Wire2Api<bool> + UnwindSafe,
    n_sequence: impl Wire2Api<Option<u32>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, BdkTxBuilderResult, _>(
        WrapInfo {
            debug_name: "bump_fee_tx_builder_finish__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_txid = txid.wire2api();
            let api_fee_rate = fee_rate.wire2api();
            let api_allow_shrinking = allow_shrinking.wire2api();
            let api_wallet = wallet.wire2api();
            let api_enable_rbf = enable_rbf.wire2api();
            let api_keep_change = keep_change.wire2api();
            let api_n_sequence = n_sequence.wire2api();
            move |task_callback| {
                Api::bump_fee_tx_builder_finish(
                    api_txid,
                    api_fee_rate,
                    api_allow_shrinking,
                    api_wallet,
                    api_enable_rbf,
                    api_keep_change,
                    api_n_sequence,
                )
            }
        },
    )
}
fn wire_create_descriptor__static_method__Api_impl(
    port_: MessagePort,
    descriptor: impl Wire2Api<String> + UnwindSafe,
    network: impl Wire2Api<Network> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, RustOpaque<BdkDescriptor>, _>(
        WrapInfo {
            debug_name: "create_descriptor__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_descriptor = descriptor.wire2api();
            let api_network = network.wire2api();
            move |task_callback| Api::create_descriptor(api_descriptor, api_network)
        },
    )
}
fn wire_import_single_wif__static_method__Api_impl(
    port_: MessagePort,
    wif: impl Wire2Api<String> + UnwindSafe,
    address_type: impl Wire2Api<String> + UnwindSafe,
    network: impl Wire2Api<Network> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, RustOpaque<BdkDescriptor>, _>(
        WrapInfo {
            debug_name: "import_single_wif__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_wif = wif.wire2api();
            let api_address_type = address_type.wire2api();
            let api_network = network.wire2api();
            move |task_callback| {
                Result::<_, ()>::Ok(Api::import_single_wif(
                    api_wif,
                    api_address_type,
                    api_network,
                ))
            }
        },
    )
}
fn wire_new_bip44_descriptor__static_method__Api_impl(
    port_: MessagePort,
    key_chain_kind: impl Wire2Api<KeychainKind> + UnwindSafe,
    secret_key: impl Wire2Api<String> + UnwindSafe,
    network: impl Wire2Api<Network> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, RustOpaque<BdkDescriptor>, _>(
        WrapInfo {
            debug_name: "new_bip44_descriptor__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_key_chain_kind = key_chain_kind.wire2api();
            let api_secret_key = secret_key.wire2api();
            let api_network = network.wire2api();
            move |task_callback| {
                Result::<_, ()>::Ok(Api::new_bip44_descriptor(
                    api_key_chain_kind,
                    api_secret_key,
                    api_network,
                ))
            }
        },
    )
}
fn wire_new_bip44_public__static_method__Api_impl(
    port_: MessagePort,
    key_chain_kind: impl Wire2Api<KeychainKind> + UnwindSafe,
    public_key: impl Wire2Api<String> + UnwindSafe,
    network: impl Wire2Api<Network> + UnwindSafe,
    fingerprint: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, RustOpaque<BdkDescriptor>, _>(
        WrapInfo {
            debug_name: "new_bip44_public__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_key_chain_kind = key_chain_kind.wire2api();
            let api_public_key = public_key.wire2api();
            let api_network = network.wire2api();
            let api_fingerprint = fingerprint.wire2api();
            move |task_callback| {
                Result::<_, ()>::Ok(Api::new_bip44_public(
                    api_key_chain_kind,
                    api_public_key,
                    api_network,
                    api_fingerprint,
                ))
            }
        },
    )
}
fn wire_new_bip44_tr_descriptor__static_method__Api_impl(
    port_: MessagePort,
    key_chain_kind: impl Wire2Api<KeychainKind> + UnwindSafe,
    secret_key: impl Wire2Api<String> + UnwindSafe,
    network: impl Wire2Api<Network> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, RustOpaque<BdkDescriptor>, _>(
        WrapInfo {
            debug_name: "new_bip44_tr_descriptor__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_key_chain_kind = key_chain_kind.wire2api();
            let api_secret_key = secret_key.wire2api();
            let api_network = network.wire2api();
            move |task_callback| {
                Result::<_, ()>::Ok(Api::new_bip44_tr_descriptor(
                    api_key_chain_kind,
                    api_secret_key,
                    api_network,
                ))
            }
        },
    )
}
fn wire_new_bip44_tr_public__static_method__Api_impl(
    port_: MessagePort,
    key_chain_kind: impl Wire2Api<KeychainKind> + UnwindSafe,
    public_key: impl Wire2Api<String> + UnwindSafe,
    network: impl Wire2Api<Network> + UnwindSafe,
    fingerprint: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, RustOpaque<BdkDescriptor>, _>(
        WrapInfo {
            debug_name: "new_bip44_tr_public__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_key_chain_kind = key_chain_kind.wire2api();
            let api_public_key = public_key.wire2api();
            let api_network = network.wire2api();
            let api_fingerprint = fingerprint.wire2api();
            move |task_callback| {
                Result::<_, ()>::Ok(Api::new_bip44_tr_public(
                    api_key_chain_kind,
                    api_public_key,
                    api_network,
                    api_fingerprint,
                ))
            }
        },
    )
}
fn wire_new_bip49_descriptor__static_method__Api_impl(
    port_: MessagePort,
    key_chain_kind: impl Wire2Api<KeychainKind> + UnwindSafe,
    secret_key: impl Wire2Api<String> + UnwindSafe,
    network: impl Wire2Api<Network> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, RustOpaque<BdkDescriptor>, _>(
        WrapInfo {
            debug_name: "new_bip49_descriptor__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_key_chain_kind = key_chain_kind.wire2api();
            let api_secret_key = secret_key.wire2api();
            let api_network = network.wire2api();
            move |task_callback| {
                Result::<_, ()>::Ok(Api::new_bip49_descriptor(
                    api_key_chain_kind,
                    api_secret_key,
                    api_network,
                ))
            }
        },
    )
}
fn wire_new_bip49_public__static_method__Api_impl(
    port_: MessagePort,
    key_chain_kind: impl Wire2Api<KeychainKind> + UnwindSafe,
    public_key: impl Wire2Api<String> + UnwindSafe,
    network: impl Wire2Api<Network> + UnwindSafe,
    fingerprint: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, RustOpaque<BdkDescriptor>, _>(
        WrapInfo {
            debug_name: "new_bip49_public__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_key_chain_kind = key_chain_kind.wire2api();
            let api_public_key = public_key.wire2api();
            let api_network = network.wire2api();
            let api_fingerprint = fingerprint.wire2api();
            move |task_callback| {
                Result::<_, ()>::Ok(Api::new_bip49_public(
                    api_key_chain_kind,
                    api_public_key,
                    api_network,
                    api_fingerprint,
                ))
            }
        },
    )
}
fn wire_new_bip84_descriptor__static_method__Api_impl(
    port_: MessagePort,
    key_chain_kind: impl Wire2Api<KeychainKind> + UnwindSafe,
    secret_key: impl Wire2Api<String> + UnwindSafe,
    network: impl Wire2Api<Network> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, RustOpaque<BdkDescriptor>, _>(
        WrapInfo {
            debug_name: "new_bip84_descriptor__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_key_chain_kind = key_chain_kind.wire2api();
            let api_secret_key = secret_key.wire2api();
            let api_network = network.wire2api();
            move |task_callback| {
                Result::<_, ()>::Ok(Api::new_bip84_descriptor(
                    api_key_chain_kind,
                    api_secret_key,
                    api_network,
                ))
            }
        },
    )
}
fn wire_new_bip84_public__static_method__Api_impl(
    port_: MessagePort,
    key_chain_kind: impl Wire2Api<KeychainKind> + UnwindSafe,
    public_key: impl Wire2Api<String> + UnwindSafe,
    network: impl Wire2Api<Network> + UnwindSafe,
    fingerprint: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, RustOpaque<BdkDescriptor>, _>(
        WrapInfo {
            debug_name: "new_bip84_public__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_key_chain_kind = key_chain_kind.wire2api();
            let api_public_key = public_key.wire2api();
            let api_network = network.wire2api();
            let api_fingerprint = fingerprint.wire2api();
            move |task_callback| {
                Result::<_, ()>::Ok(Api::new_bip84_public(
                    api_key_chain_kind,
                    api_public_key,
                    api_network,
                    api_fingerprint,
                ))
            }
        },
    )
}
fn wire_new_bip86_descriptor__static_method__Api_impl(
    port_: MessagePort,
    key_chain_kind: impl Wire2Api<KeychainKind> + UnwindSafe,
    secret_key: impl Wire2Api<String> + UnwindSafe,
    network: impl Wire2Api<Network> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, RustOpaque<BdkDescriptor>, _>(
        WrapInfo {
            debug_name: "new_bip86_descriptor__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_key_chain_kind = key_chain_kind.wire2api();
            let api_secret_key = secret_key.wire2api();
            let api_network = network.wire2api();
            move |task_callback| {
                Result::<_, ()>::Ok(Api::new_bip86_descriptor(
                    api_key_chain_kind,
                    api_secret_key,
                    api_network,
                ))
            }
        },
    )
}
fn wire_new_bip86_public__static_method__Api_impl(
    port_: MessagePort,
    key_chain_kind: impl Wire2Api<KeychainKind> + UnwindSafe,
    public_key: impl Wire2Api<String> + UnwindSafe,
    network: impl Wire2Api<Network> + UnwindSafe,
    fingerprint: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, RustOpaque<BdkDescriptor>, _>(
        WrapInfo {
            debug_name: "new_bip86_public__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_key_chain_kind = key_chain_kind.wire2api();
            let api_public_key = public_key.wire2api();
            let api_network = network.wire2api();
            let api_fingerprint = fingerprint.wire2api();
            move |task_callback| {
                Result::<_, ()>::Ok(Api::new_bip86_public(
                    api_key_chain_kind,
                    api_public_key,
                    api_network,
                    api_fingerprint,
                ))
            }
        },
    )
}
fn wire_as_string_private__static_method__Api_impl(
    port_: MessagePort,
    descriptor: impl Wire2Api<RustOpaque<BdkDescriptor>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, String, _>(
        WrapInfo {
            debug_name: "as_string_private__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_descriptor = descriptor.wire2api();
            move |task_callback| Result::<_, ()>::Ok(Api::as_string_private(api_descriptor))
        },
    )
}
fn wire_as_string__static_method__Api_impl(
    port_: MessagePort,
    descriptor: impl Wire2Api<RustOpaque<BdkDescriptor>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, String, _>(
        WrapInfo {
            debug_name: "as_string__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_descriptor = descriptor.wire2api();
            move |task_callback| Result::<_, ()>::Ok(Api::as_string(api_descriptor))
        },
    )
}
fn wire_derive_address_at__static_method__Api_impl(
    port_: MessagePort,
    descriptor: impl Wire2Api<RustOpaque<BdkDescriptor>> + UnwindSafe,
    index: impl Wire2Api<u32> + UnwindSafe,
    network: impl Wire2Api<Network> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, AddressInfo, _>(
        WrapInfo {
            debug_name: "derive_address_at__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_descriptor = descriptor.wire2api();
            let api_index = index.wire2api();
            let api_network = network.wire2api();
            move |task_callback| Api::derive_address_at(api_descriptor, api_index, api_network)
        },
    )
}
fn wire_create_descriptor_secret__static_method__Api_impl(
    port_: MessagePort,
    network: impl Wire2Api<Network> + UnwindSafe,
    mnemonic: impl Wire2Api<String> + UnwindSafe,
    password: impl Wire2Api<Option<String>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, String, _>(
        WrapInfo {
            debug_name: "create_descriptor_secret__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_network = network.wire2api();
            let api_mnemonic = mnemonic.wire2api();
            let api_password = password.wire2api();
            move |task_callback| {
                Api::create_descriptor_secret(api_network, api_mnemonic, api_password)
            }
        },
    )
}
fn wire_create_derived_descriptor_secret__static_method__Api_impl(
    port_: MessagePort,
    network: impl Wire2Api<Network> + UnwindSafe,
    mnemonic: impl Wire2Api<String> + UnwindSafe,
    path: impl Wire2Api<String> + UnwindSafe,
    password: impl Wire2Api<Option<String>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, String, _>(
        WrapInfo {
            debug_name: "create_derived_descriptor_secret__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_network = network.wire2api();
            let api_mnemonic = mnemonic.wire2api();
            let api_path = path.wire2api();
            let api_password = password.wire2api();
            move |task_callback| {
                Api::create_derived_descriptor_secret(
                    api_network,
                    api_mnemonic,
                    api_path,
                    api_password,
                )
            }
        },
    )
}
fn wire_descriptor_secret_from_string__static_method__Api_impl(
    port_: MessagePort,
    secret: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, String, _>(
        WrapInfo {
            debug_name: "descriptor_secret_from_string__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_secret = secret.wire2api();
            move |task_callback| Api::descriptor_secret_from_string(api_secret)
        },
    )
}
fn wire_extend_descriptor_secret__static_method__Api_impl(
    port_: MessagePort,
    secret: impl Wire2Api<String> + UnwindSafe,
    path: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, String, _>(
        WrapInfo {
            debug_name: "extend_descriptor_secret__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_secret = secret.wire2api();
            let api_path = path.wire2api();
            move |task_callback| {
                Result::<_, ()>::Ok(Api::extend_descriptor_secret(api_secret, api_path))
            }
        },
    )
}
fn wire_derive_descriptor_secret__static_method__Api_impl(
    port_: MessagePort,
    secret: impl Wire2Api<String> + UnwindSafe,
    path: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, String, _>(
        WrapInfo {
            debug_name: "derive_descriptor_secret__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_secret = secret.wire2api();
            let api_path = path.wire2api();
            move |task_callback| {
                Result::<_, ()>::Ok(Api::derive_descriptor_secret(api_secret, api_path))
            }
        },
    )
}
fn wire_as_secret_bytes__static_method__Api_impl(
    port_: MessagePort,
    secret: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, Vec<u8>, _>(
        WrapInfo {
            debug_name: "as_secret_bytes__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_secret = secret.wire2api();
            move |task_callback| Api::as_secret_bytes(api_secret)
        },
    )
}
fn wire_as_public__static_method__Api_impl(
    port_: MessagePort,
    secret: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, String, _>(
        WrapInfo {
            debug_name: "as_public__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_secret = secret.wire2api();
            move |task_callback| Api::as_public(api_secret)
        },
    )
}
fn wire_get_pub_from_secret_bytes__static_method__Api_impl(
    port_: MessagePort,
    bytes: impl Wire2Api<Vec<u8>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, String, _>(
        WrapInfo {
            debug_name: "get_pub_from_secret_bytes__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_bytes = bytes.wire2api();
            move |task_callback| Result::<_, ()>::Ok(Api::get_pub_from_secret_bytes(api_bytes))
        },
    )
}
fn wire_create_derivation_path__static_method__Api_impl(
    port_: MessagePort,
    path: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, String, _>(
        WrapInfo {
            debug_name: "create_derivation_path__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_path = path.wire2api();
            move |task_callback| Api::create_derivation_path(api_path)
        },
    )
}
fn wire_descriptor_public_from_string__static_method__Api_impl(
    port_: MessagePort,
    public_key: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, String, _>(
        WrapInfo {
            debug_name: "descriptor_public_from_string__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_public_key = public_key.wire2api();
            move |task_callback| Api::descriptor_public_from_string(api_public_key)
        },
    )
}
fn wire_master_finterprint__static_method__Api_impl(
    port_: MessagePort,
    xpub: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, String, _>(
        WrapInfo {
            debug_name: "master_finterprint__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_xpub = xpub.wire2api();
            move |task_callback| Api::master_finterprint(api_xpub)
        },
    )
}
fn wire_create_descriptor_public__static_method__Api_impl(
    port_: MessagePort,
    xpub: impl Wire2Api<Option<String>> + UnwindSafe,
    path: impl Wire2Api<String> + UnwindSafe,
    derive: impl Wire2Api<bool> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, String, _>(
        WrapInfo {
            debug_name: "create_descriptor_public__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_xpub = xpub.wire2api();
            let api_path = path.wire2api();
            let api_derive = derive.wire2api();
            move |task_callback| Api::create_descriptor_public(api_xpub, api_path, api_derive)
        },
    )
}
fn wire_to_public_string__static_method__Api_impl(
    port_: MessagePort,
    xpub: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, String, _>(
        WrapInfo {
            debug_name: "to_public_string__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_xpub = xpub.wire2api();
            move |task_callback| Api::to_public_string(api_xpub)
        },
    )
}
fn wire_create_script__static_method__Api_impl(
    port_: MessagePort,
    raw_output_script: impl Wire2Api<Vec<u8>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, Script, _>(
        WrapInfo {
            debug_name: "create_script__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_raw_output_script = raw_output_script.wire2api();
            move |task_callback| Api::create_script(api_raw_output_script)
        },
    )
}
fn wire_create_address__static_method__Api_impl(
    port_: MessagePort,
    address: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, String, _>(
        WrapInfo {
            debug_name: "create_address__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_address = address.wire2api();
            move |task_callback| Api::create_address(api_address)
        },
    )
}
fn wire_address_from_script__static_method__Api_impl(
    port_: MessagePort,
    script: impl Wire2Api<Script> + UnwindSafe,
    network: impl Wire2Api<Network> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, String, _>(
        WrapInfo {
            debug_name: "address_from_script__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_script = script.wire2api();
            let api_network = network.wire2api();
            move |task_callback| Api::address_from_script(api_script, api_network)
        },
    )
}
fn wire_address_to_script_pubkey__static_method__Api_impl(
    port_: MessagePort,
    address: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, Script, _>(
        WrapInfo {
            debug_name: "address_to_script_pubkey__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_address = address.wire2api();
            move |task_callback| Api::address_to_script_pubkey(api_address)
        },
    )
}
fn wire_payload__static_method__Api_impl(
    port_: MessagePort,
    address: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, Payload, _>(
        WrapInfo {
            debug_name: "payload__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_address = address.wire2api();
            move |task_callback| Api::payload(api_address)
        },
    )
}
fn wire_address_network__static_method__Api_impl(
    port_: MessagePort,
    address: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, Network, _>(
        WrapInfo {
            debug_name: "address_network__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_address = address.wire2api();
            move |task_callback| Api::address_network(api_address)
        },
    )
}
fn wire_get_address_type__static_method__Api_impl(
    port_: MessagePort,
    address: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, String, _>(
        WrapInfo {
            debug_name: "get_address_type__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_address = address.wire2api();
            move |task_callback| Api::get_address_type(api_address)
        },
    )
}
fn wire_create_wallet__static_method__Api_impl(
    port_: MessagePort,
    descriptor: impl Wire2Api<RustOpaque<BdkDescriptor>> + UnwindSafe,
    change_descriptor: impl Wire2Api<Option<RustOpaque<BdkDescriptor>>> + UnwindSafe,
    network: impl Wire2Api<Network> + UnwindSafe,
    database_config: impl Wire2Api<DatabaseConfig> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, RustOpaque<WalletInstance>, _>(
        WrapInfo {
            debug_name: "create_wallet__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_descriptor = descriptor.wire2api();
            let api_change_descriptor = change_descriptor.wire2api();
            let api_network = network.wire2api();
            let api_database_config = database_config.wire2api();
            move |task_callback| {
                Api::create_wallet(
                    api_descriptor,
                    api_change_descriptor,
                    api_network,
                    api_database_config,
                )
            }
        },
    )
}
fn wire_get_address__static_method__Api_impl(
    port_: MessagePort,
    wallet: impl Wire2Api<RustOpaque<WalletInstance>> + UnwindSafe,
    address_index: impl Wire2Api<AddressIndex> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, AddressInfo, _>(
        WrapInfo {
            debug_name: "get_address__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_wallet = wallet.wire2api();
            let api_address_index = address_index.wire2api();
            move |task_callback| Api::get_address(api_wallet, api_address_index)
        },
    )
}
fn wire_get_internal_address__static_method__Api_impl(
    port_: MessagePort,
    wallet: impl Wire2Api<RustOpaque<WalletInstance>> + UnwindSafe,
    address_index: impl Wire2Api<AddressIndex> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, AddressInfo, _>(
        WrapInfo {
            debug_name: "get_internal_address__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_wallet = wallet.wire2api();
            let api_address_index = address_index.wire2api();
            move |task_callback| Api::get_internal_address(api_wallet, api_address_index)
        },
    )
}
fn wire_sync_wallet__static_method__Api_impl(
    port_: MessagePort,
    wallet: impl Wire2Api<RustOpaque<WalletInstance>> + UnwindSafe,
    blockchain: impl Wire2Api<RustOpaque<BlockchainInstance>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, (), _>(
        WrapInfo {
            debug_name: "sync_wallet__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_wallet = wallet.wire2api();
            let api_blockchain = blockchain.wire2api();
            move |task_callback| Result::<_, ()>::Ok(Api::sync_wallet(api_wallet, api_blockchain))
        },
    )
}
fn wire_sync_wallet_thread__static_method__Api_impl(
    port_: MessagePort,
    wallet: impl Wire2Api<RustOpaque<WalletInstance>> + UnwindSafe,
    blockchain: impl Wire2Api<RustOpaque<BlockchainInstance>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, (), _>(
        WrapInfo {
            debug_name: "sync_wallet_thread__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_wallet = wallet.wire2api();
            let api_blockchain = blockchain.wire2api();
            move |task_callback| {
                Result::<_, ()>::Ok(Api::sync_wallet_thread(api_wallet, api_blockchain))
            }
        },
    )
}
fn wire_get_balance__static_method__Api_impl(
    port_: MessagePort,
    wallet: impl Wire2Api<RustOpaque<WalletInstance>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, Balance, _>(
        WrapInfo {
            debug_name: "get_balance__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_wallet = wallet.wire2api();
            move |task_callback| Api::get_balance(api_wallet)
        },
    )
}
fn wire_list_unspent_outputs__static_method__Api_impl(
    port_: MessagePort,
    wallet: impl Wire2Api<RustOpaque<WalletInstance>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, Vec<LocalUtxo>, _>(
        WrapInfo {
            debug_name: "list_unspent_outputs__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_wallet = wallet.wire2api();
            move |task_callback| Api::list_unspent_outputs(api_wallet)
        },
    )
}
fn wire_get_transactions__static_method__Api_impl(
    port_: MessagePort,
    wallet: impl Wire2Api<RustOpaque<WalletInstance>> + UnwindSafe,
    include_raw: impl Wire2Api<bool> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, Vec<TransactionDetails>, _>(
        WrapInfo {
            debug_name: "get_transactions__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_wallet = wallet.wire2api();
            let api_include_raw = include_raw.wire2api();
            move |task_callback| Api::get_transactions(api_wallet, api_include_raw)
        },
    )
}
fn wire_sign__static_method__Api_impl(
    port_: MessagePort,
    wallet: impl Wire2Api<RustOpaque<WalletInstance>> + UnwindSafe,
    psbt_str: impl Wire2Api<String> + UnwindSafe,
    sign_options: impl Wire2Api<Option<SignOptions>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, Option<String>, _>(
        WrapInfo {
            debug_name: "sign__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_wallet = wallet.wire2api();
            let api_psbt_str = psbt_str.wire2api();
            let api_sign_options = sign_options.wire2api();
            move |task_callback| {
                Result::<_, ()>::Ok(Api::sign(api_wallet, api_psbt_str, api_sign_options))
            }
        },
    )
}
fn wire_wallet_network__static_method__Api_impl(
    port_: MessagePort,
    wallet: impl Wire2Api<RustOpaque<WalletInstance>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, Network, _>(
        WrapInfo {
            debug_name: "wallet_network__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_wallet = wallet.wire2api();
            move |task_callback| Result::<_, ()>::Ok(Api::wallet_network(api_wallet))
        },
    )
}
fn wire_list_unspent__static_method__Api_impl(
    port_: MessagePort,
    wallet: impl Wire2Api<RustOpaque<WalletInstance>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, Vec<LocalUtxo>, _>(
        WrapInfo {
            debug_name: "list_unspent__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_wallet = wallet.wire2api();
            move |task_callback| Api::list_unspent(api_wallet)
        },
    )
}
fn wire_cache_address__static_method__Api_impl(
    port_: MessagePort,
    wallet: impl Wire2Api<RustOpaque<WalletInstance>> + UnwindSafe,
    cache_size: impl Wire2Api<u32> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, bool, _>(
        WrapInfo {
            debug_name: "cache_address__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_wallet = wallet.wire2api();
            let api_cache_size = cache_size.wire2api();
            move |task_callback| Api::cache_address(api_wallet, api_cache_size)
        },
    )
}
fn wire_generate_seed_from_word_count__static_method__Api_impl(
    port_: MessagePort,
    word_count: impl Wire2Api<WordCount> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, String, _>(
        WrapInfo {
            debug_name: "generate_seed_from_word_count__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_word_count = word_count.wire2api();
            move |task_callback| {
                Result::<_, ()>::Ok(Api::generate_seed_from_word_count(api_word_count))
            }
        },
    )
}
fn wire_generate_seed_from_string__static_method__Api_impl(
    port_: MessagePort,
    mnemonic: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, String, _>(
        WrapInfo {
            debug_name: "generate_seed_from_string__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_mnemonic = mnemonic.wire2api();
            move |task_callback| Api::generate_seed_from_string(api_mnemonic)
        },
    )
}
fn wire_generate_seed_from_entropy__static_method__Api_impl(
    port_: MessagePort,
    entropy: impl Wire2Api<Vec<u8>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, String, _>(
        WrapInfo {
            debug_name: "generate_seed_from_entropy__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_entropy = entropy.wire2api();
            move |task_callback| Api::generate_seed_from_entropy(api_entropy)
        },
    )
}
fn wire_bip322_sign_segwit__static_method__Api_impl(
    port_: MessagePort,
    secret: impl Wire2Api<Vec<u8>> + UnwindSafe,
    message: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, String, _>(
        WrapInfo {
            debug_name: "bip322_sign_segwit__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_secret = secret.wire2api();
            let api_message = message.wire2api();
            move |task_callback| {
                Result::<_, ()>::Ok(Api::bip322_sign_segwit(api_secret, api_message))
            }
        },
    )
}
fn wire_bip322_sign_taproot__static_method__Api_impl(
    port_: MessagePort,
    secret: impl Wire2Api<Vec<u8>> + UnwindSafe,
    message: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, String, _>(
        WrapInfo {
            debug_name: "bip322_sign_taproot__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_secret = secret.wire2api();
            let api_message = message.wire2api();
            move |task_callback| {
                Result::<_, ()>::Ok(Api::bip322_sign_taproot(api_secret, api_message))
            }
        },
    )
}
// Section: wrapper structs

// Section: static checks

// Section: allocate functions

// Section: related functions

// Section: impl Wire2Api

pub trait Wire2Api<T> {
    fn wire2api(self) -> T;
}

impl<T, S> Wire2Api<Option<T>> for *mut S
where
    *mut S: Wire2Api<T>,
{
    fn wire2api(self) -> Option<T> {
        (!self.is_null()).then(|| self.wire2api())
    }
}

impl Wire2Api<bool> for bool {
    fn wire2api(self) -> bool {
        self
    }
}

impl Wire2Api<ChangeSpendPolicy> for i32 {
    fn wire2api(self) -> ChangeSpendPolicy {
        match self {
            0 => ChangeSpendPolicy::ChangeAllowed,
            1 => ChangeSpendPolicy::OnlyChange,
            2 => ChangeSpendPolicy::ChangeForbidden,
            _ => unreachable!("Invalid variant for ChangeSpendPolicy: {}", self),
        }
    }
}

impl Wire2Api<f32> for f32 {
    fn wire2api(self) -> f32 {
        self
    }
}

impl Wire2Api<i32> for i32 {
    fn wire2api(self) -> i32 {
        self
    }
}
impl Wire2Api<KeychainKind> for i32 {
    fn wire2api(self) -> KeychainKind {
        match self {
            0 => KeychainKind::External,
            1 => KeychainKind::Internal,
            _ => unreachable!("Invalid variant for KeychainKind: {}", self),
        }
    }
}

impl Wire2Api<Network> for i32 {
    fn wire2api(self) -> Network {
        match self {
            0 => Network::Testnet,
            1 => Network::Regtest,
            2 => Network::Bitcoin,
            3 => Network::Signet,
            _ => unreachable!("Invalid variant for Network: {}", self),
        }
    }
}

impl Wire2Api<u32> for u32 {
    fn wire2api(self) -> u32 {
        self
    }
}
impl Wire2Api<u64> for u64 {
    fn wire2api(self) -> u64 {
        self
    }
}
impl Wire2Api<u8> for u8 {
    fn wire2api(self) -> u8 {
        self
    }
}

impl Wire2Api<WordCount> for i32 {
    fn wire2api(self) -> WordCount {
        match self {
            0 => WordCount::Words12,
            1 => WordCount::Words18,
            2 => WordCount::Words24,
            _ => unreachable!("Invalid variant for WordCount: {}", self),
        }
    }
}
// Section: impl IntoDart

impl support::IntoDart for AddressInfo {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.index.into_into_dart().into_dart(),
            self.address.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for AddressInfo {}
impl rust2dart::IntoIntoDart<AddressInfo> for AddressInfo {
    fn into_into_dart(self) -> Self {
        self
    }
}

impl support::IntoDart for Balance {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.immature.into_into_dart().into_dart(),
            self.trusted_pending.into_into_dart().into_dart(),
            self.untrusted_pending.into_into_dart().into_dart(),
            self.confirmed.into_into_dart().into_dart(),
            self.spendable.into_into_dart().into_dart(),
            self.total.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for Balance {}
impl rust2dart::IntoIntoDart<Balance> for Balance {
    fn into_into_dart(self) -> Self {
        self
    }
}

impl support::IntoDart for BdkTxBuilderResult {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.0.into_into_dart().into_dart(),
            self.1.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for BdkTxBuilderResult {}
impl rust2dart::IntoIntoDart<BdkTxBuilderResult> for BdkTxBuilderResult {
    fn into_into_dart(self) -> Self {
        self
    }
}

impl support::IntoDart for BlockTime {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.height.into_into_dart().into_dart(),
            self.timestamp.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for BlockTime {}
impl rust2dart::IntoIntoDart<BlockTime> for BlockTime {
    fn into_into_dart(self) -> Self {
        self
    }
}

impl support::IntoDart for ED25519Res {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.seed.into_into_dart().into_dart(),
            self.public_key.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for ED25519Res {}
impl rust2dart::IntoIntoDart<ED25519Res> for ED25519Res {
    fn into_into_dart(self) -> Self {
        self
    }
}

impl support::IntoDart for KeyDerivedRes {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.left_bits.into_into_dart().into_dart(),
            self.right_bits.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for KeyDerivedRes {}
impl rust2dart::IntoIntoDart<KeyDerivedRes> for KeyDerivedRes {
    fn into_into_dart(self) -> Self {
        self
    }
}

impl support::IntoDart for KeychainKind {
    fn into_dart(self) -> support::DartAbi {
        match self {
            Self::External => 0,
            Self::Internal => 1,
        }
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for KeychainKind {}
impl rust2dart::IntoIntoDart<KeychainKind> for KeychainKind {
    fn into_into_dart(self) -> Self {
        self
    }
}

impl support::IntoDart for LocalUtxo {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.outpoint.into_into_dart().into_dart(),
            self.txout.into_into_dart().into_dart(),
            self.is_spent.into_into_dart().into_dart(),
            self.keychain.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for LocalUtxo {}
impl rust2dart::IntoIntoDart<LocalUtxo> for LocalUtxo {
    fn into_into_dart(self) -> Self {
        self
    }
}

impl support::IntoDart for Network {
    fn into_dart(self) -> support::DartAbi {
        match self {
            Self::Testnet => 0,
            Self::Regtest => 1,
            Self::Bitcoin => 2,
            Self::Signet => 3,
        }
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for Network {}
impl rust2dart::IntoIntoDart<Network> for Network {
    fn into_into_dart(self) -> Self {
        self
    }
}

impl support::IntoDart for OutPoint {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.txid.into_into_dart().into_dart(),
            self.vout.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for OutPoint {}
impl rust2dart::IntoIntoDart<OutPoint> for OutPoint {
    fn into_into_dart(self) -> Self {
        self
    }
}

impl support::IntoDart for P256IdentityExport {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.private_key_hash.into_into_dart().into_dart(),
            self.der_encoded_public_key.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for P256IdentityExport {}
impl rust2dart::IntoIntoDart<P256IdentityExport> for P256IdentityExport {
    fn into_into_dart(self) -> Self {
        self
    }
}

impl support::IntoDart for Payload {
    fn into_dart(self) -> support::DartAbi {
        match self {
            Self::PubkeyHash { pubkey_hash } => {
                vec![0.into_dart(), pubkey_hash.into_into_dart().into_dart()]
            }
            Self::ScriptHash { script_hash } => {
                vec![1.into_dart(), script_hash.into_into_dart().into_dart()]
            }
            Self::WitnessProgram { version, program } => vec![
                2.into_dart(),
                version.into_into_dart().into_dart(),
                program.into_into_dart().into_dart(),
            ],
        }
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for Payload {}
impl rust2dart::IntoIntoDart<Payload> for Payload {
    fn into_into_dart(self) -> Self {
        self
    }
}

impl support::IntoDart for SchnorrIdentityExport {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.private_key_hash.into_into_dart().into_dart(),
            self.public_key_hash.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for SchnorrIdentityExport {}
impl rust2dart::IntoIntoDart<SchnorrIdentityExport> for SchnorrIdentityExport {
    fn into_into_dart(self) -> Self {
        self
    }
}

impl support::IntoDart for Script {
    fn into_dart(self) -> support::DartAbi {
        vec![self.internal.into_into_dart().into_dart()].into_dart()
    }
}
impl support::IntoDartExceptPrimitive for Script {}
impl rust2dart::IntoIntoDart<Script> for Script {
    fn into_into_dart(self) -> Self {
        self
    }
}

impl support::IntoDart for Secp256k1IdentityExport {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.private_key_hash.into_into_dart().into_dart(),
            self.der_encoded_public_key.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for Secp256k1IdentityExport {}
impl rust2dart::IntoIntoDart<Secp256k1IdentityExport> for Secp256k1IdentityExport {
    fn into_into_dart(self) -> Self {
        self
    }
}

impl support::IntoDart for SignatureFFI {
    fn into_dart(self) -> support::DartAbi {
        vec![self.public_key.into_dart(), self.signature.into_dart()].into_dart()
    }
}
impl support::IntoDartExceptPrimitive for SignatureFFI {}
impl rust2dart::IntoIntoDart<SignatureFFI> for SignatureFFI {
    fn into_into_dart(self) -> Self {
        self
    }
}

impl support::IntoDart for TransactionDetails {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.serialized_tx.into_dart(),
            self.txid.into_into_dart().into_dart(),
            self.received.into_into_dart().into_dart(),
            self.sent.into_into_dart().into_dart(),
            self.fee.into_dart(),
            self.confirmation_time.into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for TransactionDetails {}
impl rust2dart::IntoIntoDart<TransactionDetails> for TransactionDetails {
    fn into_into_dart(self) -> Self {
        self
    }
}

impl support::IntoDart for TxIn {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.previous_output.into_into_dart().into_dart(),
            self.script_sig.into_into_dart().into_dart(),
            self.sequence.into_into_dart().into_dart(),
            self.witness.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for TxIn {}
impl rust2dart::IntoIntoDart<TxIn> for TxIn {
    fn into_into_dart(self) -> Self {
        self
    }
}

impl support::IntoDart for TxOut {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.value.into_into_dart().into_dart(),
            self.script_pubkey.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for TxOut {}
impl rust2dart::IntoIntoDart<TxOut> for TxOut {
    fn into_into_dart(self) -> Self {
        self
    }
}

impl support::IntoDart for WitnessVersion {
    fn into_dart(self) -> support::DartAbi {
        match self {
            Self::V0 => 0,
            Self::V1 => 1,
            Self::V2 => 2,
            Self::V3 => 3,
            Self::V4 => 4,
            Self::V5 => 5,
            Self::V6 => 6,
            Self::V7 => 7,
            Self::V8 => 8,
            Self::V9 => 9,
            Self::V10 => 10,
            Self::V11 => 11,
            Self::V12 => 12,
            Self::V13 => 13,
            Self::V14 => 14,
            Self::V15 => 15,
            Self::V16 => 16,
        }
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for WitnessVersion {}
impl rust2dart::IntoIntoDart<WitnessVersion> for WitnessVersion {
    fn into_into_dart(self) -> Self {
        self
    }
}

// Section: executor

support::lazy_static! {
    pub static ref FLUTTER_RUST_BRIDGE_HANDLER: support::DefaultHandler = Default::default();
}

#[cfg(not(target_family = "wasm"))]
#[path = "bridge_generated.io.rs"]
mod io;
#[cfg(not(target_family = "wasm"))]
pub use self::io::*;
