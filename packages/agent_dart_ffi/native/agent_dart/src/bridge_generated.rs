#![allow(
    non_camel_case_types,
    unused,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::double_parens,
    non_snake_case,
    clippy::too_many_arguments
)]
// AUTO GENERATED FILE, DO NOT EDIT.
// Generated by `flutter_rust_bridge`@ 1.77.0.

use crate::api::*;
use core::panic::UnwindSafe;
use flutter_rust_bridge::*;
use std::ffi::c_void;
use std::sync::Arc;

// Section: imports

use crate::bdk::blockchain::BlockchainConfig;
use crate::bdk::blockchain::ElectrumConfig;
use crate::bdk::blockchain::EsploraConfig;
use crate::bdk::blockchain::RpcConfig;
use crate::bdk::blockchain::RpcSyncParams;
use crate::bdk::blockchain::UserPass;
use crate::bdk::types::AddressIndex;
use crate::bdk::types::AddressInfo;
use crate::bdk::types::Balance;
use crate::bdk::types::BdkTxBuilderResult;
use crate::bdk::types::BlockTime;
use crate::bdk::types::ChangeSpendPolicy;
use crate::bdk::types::KeychainKind;
use crate::bdk::types::Network;
use crate::bdk::types::OutPoint;
use crate::bdk::types::Payload;
use crate::bdk::types::RbfValue;
use crate::bdk::types::Script;
use crate::bdk::types::ScriptAmount;
use crate::bdk::types::TransactionDetails;
use crate::bdk::types::TxIn;
use crate::bdk::types::TxOut;
use crate::bdk::types::WitnessVersion;
use crate::bdk::types::WordCount;
use crate::bdk::wallet::DatabaseConfig;
use crate::bdk::wallet::LocalUtxo;
use crate::bdk::wallet::SignOptions;
use crate::bdk::wallet::SledDbConfiguration;
use crate::bdk::wallet::SqliteDbConfiguration;
use crate::p256::P256IdentityExport;
use crate::schnorr::SchnorrIdentityExport;
use crate::secp256k1::Secp256k1IdentityExport;
use crate::types::AesDecryptReq;
use crate::types::AesEncryptReq;
use crate::types::BLSVerifyReq;
use crate::types::ED25519FromSeedReq;
use crate::types::ED25519Res;
use crate::types::ED25519SignReq;
use crate::types::ED25519VerifyReq;
use crate::types::KeyDerivedRes;
use crate::types::P256FromSeedReq;
use crate::types::P256ShareSecretReq;
use crate::types::P256SignWithSeedReq;
use crate::types::P256VerifyReq;
use crate::types::PBKDFDeriveReq;
use crate::types::PhraseToSeedReq;
use crate::types::SchnorrFromSeedReq;
use crate::types::SchnorrSignWithSeedReq;
use crate::types::SchnorrVerifyReq;
use crate::types::ScriptDeriveReq;
use crate::types::Secp256k1FromSeedReq;
use crate::types::Secp256k1RecoverReq;
use crate::types::Secp256k1ShareSecretReq;
use crate::types::Secp256k1SignWithSeedReq;
use crate::types::Secp256k1VerifyReq;
use crate::types::SeedToKeyReq;
use crate::types::SignatureFFI;

// Section: wire functions

fn wire_mnemonic_phrase_to_seed_impl(
    port_: MessagePort,
    req: impl Wire2Api<PhraseToSeedReq> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "mnemonic_phrase_to_seed",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Ok(mnemonic_phrase_to_seed(api_req))
        },
    )
}
fn wire_mnemonic_seed_to_key_impl(
    port_: MessagePort,
    req: impl Wire2Api<SeedToKeyReq> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "mnemonic_seed_to_key",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Ok(mnemonic_seed_to_key(api_req))
        },
    )
}
fn wire_bls_init_impl(port_: MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "bls_init",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || move |task_callback| Ok(bls_init()),
    )
}
fn wire_bls_verify_impl(port_: MessagePort, req: impl Wire2Api<BLSVerifyReq> + UnwindSafe) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "bls_verify",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Ok(bls_verify(api_req))
        },
    )
}
fn wire_ed25519_from_seed_impl(
    port_: MessagePort,
    req: impl Wire2Api<ED25519FromSeedReq> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "ed25519_from_seed",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Ok(ed25519_from_seed(api_req))
        },
    )
}
fn wire_ed25519_sign_impl(port_: MessagePort, req: impl Wire2Api<ED25519SignReq> + UnwindSafe) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "ed25519_sign",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Ok(ed25519_sign(api_req))
        },
    )
}
fn wire_ed25519_verify_impl(port_: MessagePort, req: impl Wire2Api<ED25519VerifyReq> + UnwindSafe) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "ed25519_verify",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Ok(ed25519_verify(api_req))
        },
    )
}
fn wire_secp256k1_from_seed_impl(
    port_: MessagePort,
    req: impl Wire2Api<Secp256k1FromSeedReq> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "secp256k1_from_seed",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Ok(secp256k1_from_seed(api_req))
        },
    )
}
fn wire_secp256k1_sign_impl(
    port_: MessagePort,
    req: impl Wire2Api<Secp256k1SignWithSeedReq> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "secp256k1_sign",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Ok(secp256k1_sign(api_req))
        },
    )
}
fn wire_secp256k1_sign_recoverable_impl(
    port_: MessagePort,
    req: impl Wire2Api<Secp256k1SignWithSeedReq> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "secp256k1_sign_recoverable",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Ok(secp256k1_sign_recoverable(api_req))
        },
    )
}
fn wire_secp256k1_verify_impl(
    port_: MessagePort,
    req: impl Wire2Api<Secp256k1VerifyReq> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "secp256k1_verify",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Ok(secp256k1_verify(api_req))
        },
    )
}
fn wire_secp256k1_get_shared_secret_impl(
    port_: MessagePort,
    req: impl Wire2Api<Secp256k1ShareSecretReq> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "secp256k1_get_shared_secret",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Ok(secp256k1_get_shared_secret(api_req))
        },
    )
}
fn wire_secp256k1_recover_impl(
    port_: MessagePort,
    req: impl Wire2Api<Secp256k1RecoverReq> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "secp256k1_recover",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Ok(secp256k1_recover(api_req))
        },
    )
}
fn wire_p256_from_seed_impl(port_: MessagePort, req: impl Wire2Api<P256FromSeedReq> + UnwindSafe) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "p256_from_seed",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Ok(p256_from_seed(api_req))
        },
    )
}
fn wire_p256_sign_impl(port_: MessagePort, req: impl Wire2Api<P256SignWithSeedReq> + UnwindSafe) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "p256_sign",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Ok(p256_sign(api_req))
        },
    )
}
fn wire_p256_verify_impl(port_: MessagePort, req: impl Wire2Api<P256VerifyReq> + UnwindSafe) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "p256_verify",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Ok(p256_verify(api_req))
        },
    )
}
fn wire_p256_get_shared_secret_impl(
    port_: MessagePort,
    req: impl Wire2Api<P256ShareSecretReq> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "p256_get_shared_secret",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Ok(p256_get_shared_secret(api_req))
        },
    )
}
fn wire_schnorr_from_seed_impl(
    port_: MessagePort,
    req: impl Wire2Api<SchnorrFromSeedReq> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "schnorr_from_seed",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Ok(schnorr_from_seed(api_req))
        },
    )
}
fn wire_schnorr_sign_impl(
    port_: MessagePort,
    req: impl Wire2Api<SchnorrSignWithSeedReq> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "schnorr_sign",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Ok(schnorr_sign(api_req))
        },
    )
}
fn wire_schnorr_verify_impl(port_: MessagePort, req: impl Wire2Api<SchnorrVerifyReq> + UnwindSafe) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "schnorr_verify",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Ok(schnorr_verify(api_req))
        },
    )
}
fn wire_aes_128_ctr_encrypt_impl(
    port_: MessagePort,
    req: impl Wire2Api<AesEncryptReq> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "aes_128_ctr_encrypt",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Ok(aes_128_ctr_encrypt(api_req))
        },
    )
}
fn wire_aes_128_ctr_decrypt_impl(
    port_: MessagePort,
    req: impl Wire2Api<AesDecryptReq> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "aes_128_ctr_decrypt",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Ok(aes_128_ctr_decrypt(api_req))
        },
    )
}
fn wire_aes_256_cbc_encrypt_impl(
    port_: MessagePort,
    req: impl Wire2Api<AesEncryptReq> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "aes_256_cbc_encrypt",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Ok(aes_256_cbc_encrypt(api_req))
        },
    )
}
fn wire_aes_256_cbc_decrypt_impl(
    port_: MessagePort,
    req: impl Wire2Api<AesDecryptReq> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "aes_256_cbc_decrypt",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Ok(aes_256_cbc_decrypt(api_req))
        },
    )
}
fn wire_aes_256_gcm_encrypt_impl(
    port_: MessagePort,
    req: impl Wire2Api<AesEncryptReq> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "aes_256_gcm_encrypt",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Ok(aes_256_gcm_encrypt(api_req))
        },
    )
}
fn wire_aes_256_gcm_decrypt_impl(
    port_: MessagePort,
    req: impl Wire2Api<AesDecryptReq> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "aes_256_gcm_decrypt",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Ok(aes_256_gcm_decrypt(api_req))
        },
    )
}
fn wire_pbkdf2_derive_key_impl(
    port_: MessagePort,
    req: impl Wire2Api<PBKDFDeriveReq> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "pbkdf2_derive_key",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Ok(pbkdf2_derive_key(api_req))
        },
    )
}
fn wire_scrypt_derive_key_impl(
    port_: MessagePort,
    req: impl Wire2Api<ScriptDeriveReq> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "scrypt_derive_key",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_req = req.wire2api();
            move |task_callback| Ok(scrypt_derive_key(api_req))
        },
    )
}
fn wire_create_blockchain__static_method__Api_impl(
    port_: MessagePort,
    config: impl Wire2Api<BlockchainConfig> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "create_blockchain__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_config = config.wire2api();
            move |task_callback| Api::create_blockchain(api_config)
        },
    )
}
fn wire_get_height__static_method__Api_impl(
    port_: MessagePort,
    blockchain: impl Wire2Api<RustOpaque<BlockchainInstance>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "get_height__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_blockchain = blockchain.wire2api();
            move |task_callback| Api::get_height(api_blockchain)
        },
    )
}
fn wire_get_blockchain_hash__static_method__Api_impl(
    port_: MessagePort,
    blockchain_height: impl Wire2Api<u32> + UnwindSafe,
    blockchain: impl Wire2Api<RustOpaque<BlockchainInstance>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "get_blockchain_hash__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_blockchain_height = blockchain_height.wire2api();
            let api_blockchain = blockchain.wire2api();
            move |task_callback| Api::get_blockchain_hash(api_blockchain_height, api_blockchain)
        },
    )
}
fn wire_estimate_fee__static_method__Api_impl(
    port_: MessagePort,
    target: impl Wire2Api<u64> + UnwindSafe,
    blockchain: impl Wire2Api<RustOpaque<BlockchainInstance>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "estimate_fee__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_target = target.wire2api();
            let api_blockchain = blockchain.wire2api();
            move |task_callback| Api::estimate_fee(api_target, api_blockchain)
        },
    )
}
fn wire_broadcast__static_method__Api_impl(
    port_: MessagePort,
    tx: impl Wire2Api<String> + UnwindSafe,
    blockchain: impl Wire2Api<RustOpaque<BlockchainInstance>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "broadcast__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_tx = tx.wire2api();
            let api_blockchain = blockchain.wire2api();
            move |task_callback| Api::broadcast(api_tx, api_blockchain)
        },
    )
}
fn wire_create_transaction__static_method__Api_impl(
    port_: MessagePort,
    tx: impl Wire2Api<Vec<u8>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "create_transaction__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_tx = tx.wire2api();
            move |task_callback| Api::create_transaction(api_tx)
        },
    )
}
fn wire_tx_txid__static_method__Api_impl(
    port_: MessagePort,
    tx: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "tx_txid__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_tx = tx.wire2api();
            move |task_callback| Api::tx_txid(api_tx)
        },
    )
}
fn wire_weight__static_method__Api_impl(
    port_: MessagePort,
    tx: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "weight__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_tx = tx.wire2api();
            move |task_callback| Ok(Api::weight(api_tx))
        },
    )
}
fn wire_size__static_method__Api_impl(port_: MessagePort, tx: impl Wire2Api<String> + UnwindSafe) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "size__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_tx = tx.wire2api();
            move |task_callback| Ok(Api::size(api_tx))
        },
    )
}
fn wire_vsize__static_method__Api_impl(port_: MessagePort, tx: impl Wire2Api<String> + UnwindSafe) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "vsize__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_tx = tx.wire2api();
            move |task_callback| Ok(Api::vsize(api_tx))
        },
    )
}
fn wire_serialize_tx__static_method__Api_impl(
    port_: MessagePort,
    tx: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "serialize_tx__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_tx = tx.wire2api();
            move |task_callback| Ok(Api::serialize_tx(api_tx))
        },
    )
}
fn wire_is_coin_base__static_method__Api_impl(
    port_: MessagePort,
    tx: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "is_coin_base__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_tx = tx.wire2api();
            move |task_callback| Ok(Api::is_coin_base(api_tx))
        },
    )
}
fn wire_is_explicitly_rbf__static_method__Api_impl(
    port_: MessagePort,
    tx: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "is_explicitly_rbf__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_tx = tx.wire2api();
            move |task_callback| Ok(Api::is_explicitly_rbf(api_tx))
        },
    )
}
fn wire_is_lock_time_enabled__static_method__Api_impl(
    port_: MessagePort,
    tx: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "is_lock_time_enabled__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_tx = tx.wire2api();
            move |task_callback| Ok(Api::is_lock_time_enabled(api_tx))
        },
    )
}
fn wire_version__static_method__Api_impl(
    port_: MessagePort,
    tx: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "version__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_tx = tx.wire2api();
            move |task_callback| Ok(Api::version(api_tx))
        },
    )
}
fn wire_lock_time__static_method__Api_impl(
    port_: MessagePort,
    tx: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "lock_time__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_tx = tx.wire2api();
            move |task_callback| Ok(Api::lock_time(api_tx))
        },
    )
}
fn wire_input__static_method__Api_impl(port_: MessagePort, tx: impl Wire2Api<String> + UnwindSafe) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "input__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_tx = tx.wire2api();
            move |task_callback| Ok(Api::input(api_tx))
        },
    )
}
fn wire_output__static_method__Api_impl(
    port_: MessagePort,
    tx: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "output__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_tx = tx.wire2api();
            move |task_callback| Ok(Api::output(api_tx))
        },
    )
}
fn wire_serialize_psbt__static_method__Api_impl(
    port_: MessagePort,
    psbt_str: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "serialize_psbt__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_psbt_str = psbt_str.wire2api();
            move |task_callback| Api::serialize_psbt(api_psbt_str)
        },
    )
}
fn wire_psbt_txid__static_method__Api_impl(
    port_: MessagePort,
    psbt_str: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "psbt_txid__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_psbt_str = psbt_str.wire2api();
            move |task_callback| Api::psbt_txid(api_psbt_str)
        },
    )
}
fn wire_extract_tx__static_method__Api_impl(
    port_: MessagePort,
    psbt_str: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "extract_tx__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_psbt_str = psbt_str.wire2api();
            move |task_callback| Api::extract_tx(api_psbt_str)
        },
    )
}
fn wire_psbt_fee_rate__static_method__Api_impl(
    port_: MessagePort,
    psbt_str: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "psbt_fee_rate__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_psbt_str = psbt_str.wire2api();
            move |task_callback| Ok(Api::psbt_fee_rate(api_psbt_str))
        },
    )
}
fn wire_psbt_fee_amount__static_method__Api_impl(
    port_: MessagePort,
    psbt_str: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "psbt_fee_amount__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_psbt_str = psbt_str.wire2api();
            move |task_callback| Ok(Api::psbt_fee_amount(api_psbt_str))
        },
    )
}
fn wire_combine_psbt__static_method__Api_impl(
    port_: MessagePort,
    psbt_str: impl Wire2Api<String> + UnwindSafe,
    other: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "combine_psbt__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_psbt_str = psbt_str.wire2api();
            let api_other = other.wire2api();
            move |task_callback| Api::combine_psbt(api_psbt_str, api_other)
        },
    )
}
fn wire_json_serialize__static_method__Api_impl(
    port_: MessagePort,
    psbt_str: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "json_serialize__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_psbt_str = psbt_str.wire2api();
            move |task_callback| Api::json_serialize(api_psbt_str)
        },
    )
}
fn wire_get_inputs__static_method__Api_impl(
    port_: MessagePort,
    psbt_str: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "get_inputs__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_psbt_str = psbt_str.wire2api();
            move |task_callback| Api::get_inputs(api_psbt_str)
        },
    )
}
fn wire_tx_builder_finish__static_method__Api_impl(
    port_: MessagePort,
    wallet: impl Wire2Api<RustOpaque<WalletInstance>> + UnwindSafe,
    recipients: impl Wire2Api<Vec<ScriptAmount>> + UnwindSafe,
    utxos: impl Wire2Api<Vec<OutPoint>> + UnwindSafe,
    unspendable: impl Wire2Api<Vec<OutPoint>> + UnwindSafe,
    change_policy: impl Wire2Api<ChangeSpendPolicy> + UnwindSafe,
    manually_selected_only: impl Wire2Api<bool> + UnwindSafe,
    fee_rate: impl Wire2Api<Option<f32>> + UnwindSafe,
    fee_absolute: impl Wire2Api<Option<u64>> + UnwindSafe,
    drain_wallet: impl Wire2Api<bool> + UnwindSafe,
    drain_to: impl Wire2Api<Option<Script>> + UnwindSafe,
    rbf: impl Wire2Api<Option<RbfValue>> + UnwindSafe,
    data: impl Wire2Api<Vec<u8>> + UnwindSafe,
    shuffle_utxo: impl Wire2Api<Option<bool>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "tx_builder_finish__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_wallet = wallet.wire2api();
            let api_recipients = recipients.wire2api();
            let api_utxos = utxos.wire2api();
            let api_unspendable = unspendable.wire2api();
            let api_change_policy = change_policy.wire2api();
            let api_manually_selected_only = manually_selected_only.wire2api();
            let api_fee_rate = fee_rate.wire2api();
            let api_fee_absolute = fee_absolute.wire2api();
            let api_drain_wallet = drain_wallet.wire2api();
            let api_drain_to = drain_to.wire2api();
            let api_rbf = rbf.wire2api();
            let api_data = data.wire2api();
            let api_shuffle_utxo = shuffle_utxo.wire2api();
            move |task_callback| {
                Api::tx_builder_finish(
                    api_wallet,
                    api_recipients,
                    api_utxos,
                    api_unspendable,
                    api_change_policy,
                    api_manually_selected_only,
                    api_fee_rate,
                    api_fee_absolute,
                    api_drain_wallet,
                    api_drain_to,
                    api_rbf,
                    api_data,
                    api_shuffle_utxo,
                )
            }
        },
    )
}
fn wire_bump_fee_tx_builder_finish__static_method__Api_impl(
    port_: MessagePort,
    txid: impl Wire2Api<String> + UnwindSafe,
    fee_rate: impl Wire2Api<f32> + UnwindSafe,
    allow_shrinking: impl Wire2Api<Option<String>> + UnwindSafe,
    wallet: impl Wire2Api<RustOpaque<WalletInstance>> + UnwindSafe,
    enable_rbf: impl Wire2Api<bool> + UnwindSafe,
    keep_change: impl Wire2Api<bool> + UnwindSafe,
    n_sequence: impl Wire2Api<Option<u32>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "bump_fee_tx_builder_finish__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_txid = txid.wire2api();
            let api_fee_rate = fee_rate.wire2api();
            let api_allow_shrinking = allow_shrinking.wire2api();
            let api_wallet = wallet.wire2api();
            let api_enable_rbf = enable_rbf.wire2api();
            let api_keep_change = keep_change.wire2api();
            let api_n_sequence = n_sequence.wire2api();
            move |task_callback| {
                Api::bump_fee_tx_builder_finish(
                    api_txid,
                    api_fee_rate,
                    api_allow_shrinking,
                    api_wallet,
                    api_enable_rbf,
                    api_keep_change,
                    api_n_sequence,
                )
            }
        },
    )
}
fn wire_create_descriptor__static_method__Api_impl(
    port_: MessagePort,
    descriptor: impl Wire2Api<String> + UnwindSafe,
    network: impl Wire2Api<Network> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "create_descriptor__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_descriptor = descriptor.wire2api();
            let api_network = network.wire2api();
            move |task_callback| Api::create_descriptor(api_descriptor, api_network)
        },
    )
}
fn wire_new_bip44_descriptor__static_method__Api_impl(
    port_: MessagePort,
    key_chain_kind: impl Wire2Api<KeychainKind> + UnwindSafe,
    secret_key: impl Wire2Api<String> + UnwindSafe,
    network: impl Wire2Api<Network> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "new_bip44_descriptor__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_key_chain_kind = key_chain_kind.wire2api();
            let api_secret_key = secret_key.wire2api();
            let api_network = network.wire2api();
            move |task_callback| {
                Ok(Api::new_bip44_descriptor(
                    api_key_chain_kind,
                    api_secret_key,
                    api_network,
                ))
            }
        },
    )
}
fn wire_new_bip44_public__static_method__Api_impl(
    port_: MessagePort,
    key_chain_kind: impl Wire2Api<KeychainKind> + UnwindSafe,
    public_key: impl Wire2Api<String> + UnwindSafe,
    network: impl Wire2Api<Network> + UnwindSafe,
    fingerprint: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "new_bip44_public__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_key_chain_kind = key_chain_kind.wire2api();
            let api_public_key = public_key.wire2api();
            let api_network = network.wire2api();
            let api_fingerprint = fingerprint.wire2api();
            move |task_callback| {
                Ok(Api::new_bip44_public(
                    api_key_chain_kind,
                    api_public_key,
                    api_network,
                    api_fingerprint,
                ))
            }
        },
    )
}
fn wire_new_bip49_descriptor__static_method__Api_impl(
    port_: MessagePort,
    key_chain_kind: impl Wire2Api<KeychainKind> + UnwindSafe,
    secret_key: impl Wire2Api<String> + UnwindSafe,
    network: impl Wire2Api<Network> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "new_bip49_descriptor__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_key_chain_kind = key_chain_kind.wire2api();
            let api_secret_key = secret_key.wire2api();
            let api_network = network.wire2api();
            move |task_callback| {
                Ok(Api::new_bip49_descriptor(
                    api_key_chain_kind,
                    api_secret_key,
                    api_network,
                ))
            }
        },
    )
}
fn wire_new_bip49_public__static_method__Api_impl(
    port_: MessagePort,
    key_chain_kind: impl Wire2Api<KeychainKind> + UnwindSafe,
    public_key: impl Wire2Api<String> + UnwindSafe,
    network: impl Wire2Api<Network> + UnwindSafe,
    fingerprint: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "new_bip49_public__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_key_chain_kind = key_chain_kind.wire2api();
            let api_public_key = public_key.wire2api();
            let api_network = network.wire2api();
            let api_fingerprint = fingerprint.wire2api();
            move |task_callback| {
                Ok(Api::new_bip49_public(
                    api_key_chain_kind,
                    api_public_key,
                    api_network,
                    api_fingerprint,
                ))
            }
        },
    )
}
fn wire_new_bip84_descriptor__static_method__Api_impl(
    port_: MessagePort,
    key_chain_kind: impl Wire2Api<KeychainKind> + UnwindSafe,
    secret_key: impl Wire2Api<String> + UnwindSafe,
    network: impl Wire2Api<Network> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "new_bip84_descriptor__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_key_chain_kind = key_chain_kind.wire2api();
            let api_secret_key = secret_key.wire2api();
            let api_network = network.wire2api();
            move |task_callback| {
                Ok(Api::new_bip84_descriptor(
                    api_key_chain_kind,
                    api_secret_key,
                    api_network,
                ))
            }
        },
    )
}
fn wire_new_bip84_public__static_method__Api_impl(
    port_: MessagePort,
    key_chain_kind: impl Wire2Api<KeychainKind> + UnwindSafe,
    public_key: impl Wire2Api<String> + UnwindSafe,
    network: impl Wire2Api<Network> + UnwindSafe,
    fingerprint: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "new_bip84_public__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_key_chain_kind = key_chain_kind.wire2api();
            let api_public_key = public_key.wire2api();
            let api_network = network.wire2api();
            let api_fingerprint = fingerprint.wire2api();
            move |task_callback| {
                Ok(Api::new_bip84_public(
                    api_key_chain_kind,
                    api_public_key,
                    api_network,
                    api_fingerprint,
                ))
            }
        },
    )
}
fn wire_new_bip86_descriptor__static_method__Api_impl(
    port_: MessagePort,
    key_chain_kind: impl Wire2Api<KeychainKind> + UnwindSafe,
    secret_key: impl Wire2Api<String> + UnwindSafe,
    network: impl Wire2Api<Network> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "new_bip86_descriptor__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_key_chain_kind = key_chain_kind.wire2api();
            let api_secret_key = secret_key.wire2api();
            let api_network = network.wire2api();
            move |task_callback| {
                Ok(Api::new_bip86_descriptor(
                    api_key_chain_kind,
                    api_secret_key,
                    api_network,
                ))
            }
        },
    )
}
fn wire_new_bip86_public__static_method__Api_impl(
    port_: MessagePort,
    key_chain_kind: impl Wire2Api<KeychainKind> + UnwindSafe,
    public_key: impl Wire2Api<String> + UnwindSafe,
    network: impl Wire2Api<Network> + UnwindSafe,
    fingerprint: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "new_bip86_public__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_key_chain_kind = key_chain_kind.wire2api();
            let api_public_key = public_key.wire2api();
            let api_network = network.wire2api();
            let api_fingerprint = fingerprint.wire2api();
            move |task_callback| {
                Ok(Api::new_bip86_public(
                    api_key_chain_kind,
                    api_public_key,
                    api_network,
                    api_fingerprint,
                ))
            }
        },
    )
}
fn wire_as_string_private__static_method__Api_impl(
    port_: MessagePort,
    descriptor: impl Wire2Api<RustOpaque<BdkDescriptor>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "as_string_private__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_descriptor = descriptor.wire2api();
            move |task_callback| Ok(Api::as_string_private(api_descriptor))
        },
    )
}
fn wire_as_string__static_method__Api_impl(
    port_: MessagePort,
    descriptor: impl Wire2Api<RustOpaque<BdkDescriptor>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "as_string__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_descriptor = descriptor.wire2api();
            move |task_callback| Ok(Api::as_string(api_descriptor))
        },
    )
}
fn wire_create_descriptor_secret__static_method__Api_impl(
    port_: MessagePort,
    network: impl Wire2Api<Network> + UnwindSafe,
    mnemonic: impl Wire2Api<String> + UnwindSafe,
    password: impl Wire2Api<Option<String>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "create_descriptor_secret__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_network = network.wire2api();
            let api_mnemonic = mnemonic.wire2api();
            let api_password = password.wire2api();
            move |task_callback| {
                Api::create_descriptor_secret(api_network, api_mnemonic, api_password)
            }
        },
    )
}
fn wire_create_derived_descriptor_secret__static_method__Api_impl(
    port_: MessagePort,
    network: impl Wire2Api<Network> + UnwindSafe,
    mnemonic: impl Wire2Api<String> + UnwindSafe,
    path: impl Wire2Api<String> + UnwindSafe,
    password: impl Wire2Api<Option<String>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "create_derived_descriptor_secret__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_network = network.wire2api();
            let api_mnemonic = mnemonic.wire2api();
            let api_path = path.wire2api();
            let api_password = password.wire2api();
            move |task_callback| {
                Api::create_derived_descriptor_secret(
                    api_network,
                    api_mnemonic,
                    api_path,
                    api_password,
                )
            }
        },
    )
}
fn wire_descriptor_secret_from_string__static_method__Api_impl(
    port_: MessagePort,
    secret: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "descriptor_secret_from_string__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_secret = secret.wire2api();
            move |task_callback| Api::descriptor_secret_from_string(api_secret)
        },
    )
}
fn wire_extend_descriptor_secret__static_method__Api_impl(
    port_: MessagePort,
    secret: impl Wire2Api<String> + UnwindSafe,
    path: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "extend_descriptor_secret__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_secret = secret.wire2api();
            let api_path = path.wire2api();
            move |task_callback| Ok(Api::extend_descriptor_secret(api_secret, api_path))
        },
    )
}
fn wire_derive_descriptor_secret__static_method__Api_impl(
    port_: MessagePort,
    secret: impl Wire2Api<String> + UnwindSafe,
    path: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "derive_descriptor_secret__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_secret = secret.wire2api();
            let api_path = path.wire2api();
            move |task_callback| Ok(Api::derive_descriptor_secret(api_secret, api_path))
        },
    )
}
fn wire_as_secret_bytes__static_method__Api_impl(
    port_: MessagePort,
    secret: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "as_secret_bytes__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_secret = secret.wire2api();
            move |task_callback| Api::as_secret_bytes(api_secret)
        },
    )
}
fn wire_as_public__static_method__Api_impl(
    port_: MessagePort,
    secret: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "as_public__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_secret = secret.wire2api();
            move |task_callback| Api::as_public(api_secret)
        },
    )
}
fn wire_get_pub_from_secret_bytes__static_method__Api_impl(
    port_: MessagePort,
    bytes: impl Wire2Api<Vec<u8>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "get_pub_from_secret_bytes__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_bytes = bytes.wire2api();
            move |task_callback| Ok(Api::get_pub_from_secret_bytes(api_bytes))
        },
    )
}
fn wire_create_derivation_path__static_method__Api_impl(
    port_: MessagePort,
    path: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "create_derivation_path__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_path = path.wire2api();
            move |task_callback| Api::create_derivation_path(api_path)
        },
    )
}
fn wire_descriptor_public_from_string__static_method__Api_impl(
    port_: MessagePort,
    public_key: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "descriptor_public_from_string__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_public_key = public_key.wire2api();
            move |task_callback| Api::descriptor_public_from_string(api_public_key)
        },
    )
}
fn wire_master_finterprint__static_method__Api_impl(
    port_: MessagePort,
    xpub: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "master_finterprint__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_xpub = xpub.wire2api();
            move |task_callback| Api::master_finterprint(api_xpub)
        },
    )
}
fn wire_create_descriptor_public__static_method__Api_impl(
    port_: MessagePort,
    xpub: impl Wire2Api<Option<String>> + UnwindSafe,
    path: impl Wire2Api<String> + UnwindSafe,
    derive: impl Wire2Api<bool> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "create_descriptor_public__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_xpub = xpub.wire2api();
            let api_path = path.wire2api();
            let api_derive = derive.wire2api();
            move |task_callback| Api::create_descriptor_public(api_xpub, api_path, api_derive)
        },
    )
}
fn wire_to_public_string__static_method__Api_impl(
    port_: MessagePort,
    xpub: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "to_public_string__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_xpub = xpub.wire2api();
            move |task_callback| Api::to_public_string(api_xpub)
        },
    )
}
fn wire_create_script__static_method__Api_impl(
    port_: MessagePort,
    raw_output_script: impl Wire2Api<Vec<u8>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "create_script__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_raw_output_script = raw_output_script.wire2api();
            move |task_callback| Api::create_script(api_raw_output_script)
        },
    )
}
fn wire_create_address__static_method__Api_impl(
    port_: MessagePort,
    address: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "create_address__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_address = address.wire2api();
            move |task_callback| Api::create_address(api_address)
        },
    )
}
fn wire_address_from_script__static_method__Api_impl(
    port_: MessagePort,
    script: impl Wire2Api<Script> + UnwindSafe,
    network: impl Wire2Api<Network> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "address_from_script__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_script = script.wire2api();
            let api_network = network.wire2api();
            move |task_callback| Api::address_from_script(api_script, api_network)
        },
    )
}
fn wire_address_to_script_pubkey__static_method__Api_impl(
    port_: MessagePort,
    address: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "address_to_script_pubkey__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_address = address.wire2api();
            move |task_callback| Api::address_to_script_pubkey(api_address)
        },
    )
}
fn wire_payload__static_method__Api_impl(
    port_: MessagePort,
    address: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "payload__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_address = address.wire2api();
            move |task_callback| Api::payload(api_address)
        },
    )
}
fn wire_address_network__static_method__Api_impl(
    port_: MessagePort,
    address: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "address_network__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_address = address.wire2api();
            move |task_callback| Api::address_network(api_address)
        },
    )
}
fn wire_create_wallet__static_method__Api_impl(
    port_: MessagePort,
    descriptor: impl Wire2Api<RustOpaque<BdkDescriptor>> + UnwindSafe,
    change_descriptor: impl Wire2Api<Option<RustOpaque<BdkDescriptor>>> + UnwindSafe,
    network: impl Wire2Api<Network> + UnwindSafe,
    database_config: impl Wire2Api<DatabaseConfig> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "create_wallet__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_descriptor = descriptor.wire2api();
            let api_change_descriptor = change_descriptor.wire2api();
            let api_network = network.wire2api();
            let api_database_config = database_config.wire2api();
            move |task_callback| {
                Api::create_wallet(
                    api_descriptor,
                    api_change_descriptor,
                    api_network,
                    api_database_config,
                )
            }
        },
    )
}
fn wire_get_address__static_method__Api_impl(
    port_: MessagePort,
    wallet: impl Wire2Api<RustOpaque<WalletInstance>> + UnwindSafe,
    address_index: impl Wire2Api<AddressIndex> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "get_address__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_wallet = wallet.wire2api();
            let api_address_index = address_index.wire2api();
            move |task_callback| Api::get_address(api_wallet, api_address_index)
        },
    )
}
fn wire_get_internal_address__static_method__Api_impl(
    port_: MessagePort,
    wallet: impl Wire2Api<RustOpaque<WalletInstance>> + UnwindSafe,
    address_index: impl Wire2Api<AddressIndex> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "get_internal_address__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_wallet = wallet.wire2api();
            let api_address_index = address_index.wire2api();
            move |task_callback| Api::get_internal_address(api_wallet, api_address_index)
        },
    )
}
fn wire_sync_wallet__static_method__Api_impl(
    port_: MessagePort,
    wallet: impl Wire2Api<RustOpaque<WalletInstance>> + UnwindSafe,
    blockchain: impl Wire2Api<RustOpaque<BlockchainInstance>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "sync_wallet__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_wallet = wallet.wire2api();
            let api_blockchain = blockchain.wire2api();
            move |task_callback| Ok(Api::sync_wallet(api_wallet, api_blockchain))
        },
    )
}
fn wire_sync_wallet_thread__static_method__Api_impl(
    port_: MessagePort,
    wallet: impl Wire2Api<RustOpaque<WalletInstance>> + UnwindSafe,
    blockchain: impl Wire2Api<RustOpaque<BlockchainInstance>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "sync_wallet_thread__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_wallet = wallet.wire2api();
            let api_blockchain = blockchain.wire2api();
            move |task_callback| Ok(Api::sync_wallet_thread(api_wallet, api_blockchain))
        },
    )
}
fn wire_get_balance__static_method__Api_impl(
    port_: MessagePort,
    wallet: impl Wire2Api<RustOpaque<WalletInstance>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "get_balance__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_wallet = wallet.wire2api();
            move |task_callback| Api::get_balance(api_wallet)
        },
    )
}
fn wire_list_unspent_outputs__static_method__Api_impl(
    port_: MessagePort,
    wallet: impl Wire2Api<RustOpaque<WalletInstance>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "list_unspent_outputs__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_wallet = wallet.wire2api();
            move |task_callback| Api::list_unspent_outputs(api_wallet)
        },
    )
}
fn wire_get_transactions__static_method__Api_impl(
    port_: MessagePort,
    wallet: impl Wire2Api<RustOpaque<WalletInstance>> + UnwindSafe,
    include_raw: impl Wire2Api<bool> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "get_transactions__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_wallet = wallet.wire2api();
            let api_include_raw = include_raw.wire2api();
            move |task_callback| Api::get_transactions(api_wallet, api_include_raw)
        },
    )
}
fn wire_sign__static_method__Api_impl(
    port_: MessagePort,
    wallet: impl Wire2Api<RustOpaque<WalletInstance>> + UnwindSafe,
    psbt_str: impl Wire2Api<String> + UnwindSafe,
    sign_options: impl Wire2Api<Option<SignOptions>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "sign__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_wallet = wallet.wire2api();
            let api_psbt_str = psbt_str.wire2api();
            let api_sign_options = sign_options.wire2api();
            move |task_callback| Ok(Api::sign(api_wallet, api_psbt_str, api_sign_options))
        },
    )
}
fn wire_wallet_network__static_method__Api_impl(
    port_: MessagePort,
    wallet: impl Wire2Api<RustOpaque<WalletInstance>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "wallet_network__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_wallet = wallet.wire2api();
            move |task_callback| Ok(Api::wallet_network(api_wallet))
        },
    )
}
fn wire_list_unspent__static_method__Api_impl(
    port_: MessagePort,
    wallet: impl Wire2Api<RustOpaque<WalletInstance>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "list_unspent__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_wallet = wallet.wire2api();
            move |task_callback| Api::list_unspent(api_wallet)
        },
    )
}
fn wire_generate_seed_from_word_count__static_method__Api_impl(
    port_: MessagePort,
    word_count: impl Wire2Api<WordCount> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "generate_seed_from_word_count__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_word_count = word_count.wire2api();
            move |task_callback| Ok(Api::generate_seed_from_word_count(api_word_count))
        },
    )
}
fn wire_generate_seed_from_string__static_method__Api_impl(
    port_: MessagePort,
    mnemonic: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "generate_seed_from_string__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_mnemonic = mnemonic.wire2api();
            move |task_callback| Api::generate_seed_from_string(api_mnemonic)
        },
    )
}
fn wire_generate_seed_from_entropy__static_method__Api_impl(
    port_: MessagePort,
    entropy: impl Wire2Api<Vec<u8>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "generate_seed_from_entropy__static_method__Api",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_entropy = entropy.wire2api();
            move |task_callback| Api::generate_seed_from_entropy(api_entropy)
        },
    )
}
// Section: wrapper structs

// Section: static checks

// Section: allocate functions

// Section: related functions

// Section: impl Wire2Api

pub trait Wire2Api<T> {
    fn wire2api(self) -> T;
}

impl<T, S> Wire2Api<Option<T>> for *mut S
where
    *mut S: Wire2Api<T>,
{
    fn wire2api(self) -> Option<T> {
        (!self.is_null()).then(|| self.wire2api())
    }
}

impl Wire2Api<bool> for bool {
    fn wire2api(self) -> bool {
        self
    }
}

impl Wire2Api<ChangeSpendPolicy> for i32 {
    fn wire2api(self) -> ChangeSpendPolicy {
        match self {
            0 => ChangeSpendPolicy::ChangeAllowed,
            1 => ChangeSpendPolicy::OnlyChange,
            2 => ChangeSpendPolicy::ChangeForbidden,
            _ => unreachable!("Invalid variant for ChangeSpendPolicy: {}", self),
        }
    }
}

impl Wire2Api<f32> for f32 {
    fn wire2api(self) -> f32 {
        self
    }
}
impl Wire2Api<i32> for i32 {
    fn wire2api(self) -> i32 {
        self
    }
}
impl Wire2Api<KeychainKind> for i32 {
    fn wire2api(self) -> KeychainKind {
        match self {
            0 => KeychainKind::External,
            1 => KeychainKind::Internal,
            _ => unreachable!("Invalid variant for KeychainKind: {}", self),
        }
    }
}

impl Wire2Api<Network> for i32 {
    fn wire2api(self) -> Network {
        match self {
            0 => Network::Testnet,
            1 => Network::Regtest,
            2 => Network::Bitcoin,
            3 => Network::Signet,
            _ => unreachable!("Invalid variant for Network: {}", self),
        }
    }
}

impl Wire2Api<u32> for u32 {
    fn wire2api(self) -> u32 {
        self
    }
}
impl Wire2Api<u64> for u64 {
    fn wire2api(self) -> u64 {
        self
    }
}
impl Wire2Api<u8> for u8 {
    fn wire2api(self) -> u8 {
        self
    }
}

impl Wire2Api<WordCount> for i32 {
    fn wire2api(self) -> WordCount {
        match self {
            0 => WordCount::Words12,
            1 => WordCount::Words18,
            2 => WordCount::Words24,
            _ => unreachable!("Invalid variant for WordCount: {}", self),
        }
    }
}
// Section: impl IntoDart

impl support::IntoDart for AddressInfo {
    fn into_dart(self) -> support::DartAbi {
        vec![self.index.into_dart(), self.address.into_dart()].into_dart()
    }
}
impl support::IntoDartExceptPrimitive for AddressInfo {}

impl support::IntoDart for Balance {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.immature.into_dart(),
            self.trusted_pending.into_dart(),
            self.untrusted_pending.into_dart(),
            self.confirmed.into_dart(),
            self.spendable.into_dart(),
            self.total.into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for Balance {}

impl support::IntoDart for BdkTxBuilderResult {
    fn into_dart(self) -> support::DartAbi {
        vec![self.0.into_dart(), self.1.into_dart()].into_dart()
    }
}
impl support::IntoDartExceptPrimitive for BdkTxBuilderResult {}

impl support::IntoDart for BlockTime {
    fn into_dart(self) -> support::DartAbi {
        vec![self.height.into_dart(), self.timestamp.into_dart()].into_dart()
    }
}
impl support::IntoDartExceptPrimitive for BlockTime {}

impl support::IntoDart for ED25519Res {
    fn into_dart(self) -> support::DartAbi {
        vec![self.seed.into_dart(), self.public_key.into_dart()].into_dart()
    }
}
impl support::IntoDartExceptPrimitive for ED25519Res {}

impl support::IntoDart for KeyDerivedRes {
    fn into_dart(self) -> support::DartAbi {
        vec![self.left_bits.into_dart(), self.right_bits.into_dart()].into_dart()
    }
}
impl support::IntoDartExceptPrimitive for KeyDerivedRes {}

impl support::IntoDart for KeychainKind {
    fn into_dart(self) -> support::DartAbi {
        match self {
            Self::External => 0,
            Self::Internal => 1,
        }
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for KeychainKind {}

impl support::IntoDart for LocalUtxo {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.outpoint.into_dart(),
            self.txout.into_dart(),
            self.is_spent.into_dart(),
            self.keychain.into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for LocalUtxo {}

impl support::IntoDart for Network {
    fn into_dart(self) -> support::DartAbi {
        match self {
            Self::Testnet => 0,
            Self::Regtest => 1,
            Self::Bitcoin => 2,
            Self::Signet => 3,
        }
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for Network {}

impl support::IntoDart for OutPoint {
    fn into_dart(self) -> support::DartAbi {
        vec![self.txid.into_dart(), self.vout.into_dart()].into_dart()
    }
}
impl support::IntoDartExceptPrimitive for OutPoint {}

impl support::IntoDart for P256IdentityExport {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.private_key_hash.into_dart(),
            self.der_encoded_public_key.into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for P256IdentityExport {}

impl support::IntoDart for Payload {
    fn into_dart(self) -> support::DartAbi {
        match self {
            Self::PubkeyHash { pubkey_hash } => vec![0.into_dart(), pubkey_hash.into_dart()],
            Self::ScriptHash { script_hash } => vec![1.into_dart(), script_hash.into_dart()],
            Self::WitnessProgram { version, program } => {
                vec![2.into_dart(), version.into_dart(), program.into_dart()]
            }
        }
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for Payload {}
impl support::IntoDart for SchnorrIdentityExport {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.private_key_hash.into_dart(),
            self.public_key_hash.into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for SchnorrIdentityExport {}

impl support::IntoDart for Script {
    fn into_dart(self) -> support::DartAbi {
        vec![self.internal.into_dart()].into_dart()
    }
}
impl support::IntoDartExceptPrimitive for Script {}

impl support::IntoDart for Secp256k1IdentityExport {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.private_key_hash.into_dart(),
            self.der_encoded_public_key.into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for Secp256k1IdentityExport {}

impl support::IntoDart for SignatureFFI {
    fn into_dart(self) -> support::DartAbi {
        vec![self.public_key.into_dart(), self.signature.into_dart()].into_dart()
    }
}
impl support::IntoDartExceptPrimitive for SignatureFFI {}

impl support::IntoDart for TransactionDetails {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.serialized_tx.into_dart(),
            self.txid.into_dart(),
            self.received.into_dart(),
            self.sent.into_dart(),
            self.fee.into_dart(),
            self.confirmation_time.into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for TransactionDetails {}

impl support::IntoDart for TxIn {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.previous_output.into_dart(),
            self.script_sig.into_dart(),
            self.sequence.into_dart(),
            self.witness.into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for TxIn {}

impl support::IntoDart for TxOut {
    fn into_dart(self) -> support::DartAbi {
        vec![self.value.into_dart(), self.script_pubkey.into_dart()].into_dart()
    }
}
impl support::IntoDartExceptPrimitive for TxOut {}

impl support::IntoDart for WitnessVersion {
    fn into_dart(self) -> support::DartAbi {
        match self {
            Self::V0 => 0,
            Self::V1 => 1,
            Self::V2 => 2,
            Self::V3 => 3,
            Self::V4 => 4,
            Self::V5 => 5,
            Self::V6 => 6,
            Self::V7 => 7,
            Self::V8 => 8,
            Self::V9 => 9,
            Self::V10 => 10,
            Self::V11 => 11,
            Self::V12 => 12,
            Self::V13 => 13,
            Self::V14 => 14,
            Self::V15 => 15,
            Self::V16 => 16,
        }
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for WitnessVersion {}
// Section: executor

support::lazy_static! {
    pub static ref FLUTTER_RUST_BRIDGE_HANDLER: support::DefaultHandler = Default::default();
}

/// cbindgen:ignore
#[cfg(target_family = "wasm")]
mod web {
    use super::*;
    // Section: wire functions

    #[wasm_bindgen]
    pub fn wire_mnemonic_phrase_to_seed(port_: MessagePort, req: JsValue) {
        wire_mnemonic_phrase_to_seed_impl(port_, req)
    }

    #[wasm_bindgen]
    pub fn wire_mnemonic_seed_to_key(port_: MessagePort, req: JsValue) {
        wire_mnemonic_seed_to_key_impl(port_, req)
    }

    #[wasm_bindgen]
    pub fn wire_bls_init(port_: MessagePort) {
        wire_bls_init_impl(port_)
    }

    #[wasm_bindgen]
    pub fn wire_bls_verify(port_: MessagePort, req: JsValue) {
        wire_bls_verify_impl(port_, req)
    }

    #[wasm_bindgen]
    pub fn wire_ed25519_from_seed(port_: MessagePort, req: JsValue) {
        wire_ed25519_from_seed_impl(port_, req)
    }

    #[wasm_bindgen]
    pub fn wire_ed25519_sign(port_: MessagePort, req: JsValue) {
        wire_ed25519_sign_impl(port_, req)
    }

    #[wasm_bindgen]
    pub fn wire_ed25519_verify(port_: MessagePort, req: JsValue) {
        wire_ed25519_verify_impl(port_, req)
    }

    #[wasm_bindgen]
    pub fn wire_secp256k1_from_seed(port_: MessagePort, req: JsValue) {
        wire_secp256k1_from_seed_impl(port_, req)
    }

    #[wasm_bindgen]
    pub fn wire_secp256k1_sign(port_: MessagePort, req: JsValue) {
        wire_secp256k1_sign_impl(port_, req)
    }

    #[wasm_bindgen]
    pub fn wire_secp256k1_sign_recoverable(port_: MessagePort, req: JsValue) {
        wire_secp256k1_sign_recoverable_impl(port_, req)
    }

    #[wasm_bindgen]
    pub fn wire_secp256k1_verify(port_: MessagePort, req: JsValue) {
        wire_secp256k1_verify_impl(port_, req)
    }

    #[wasm_bindgen]
    pub fn wire_secp256k1_get_shared_secret(port_: MessagePort, req: JsValue) {
        wire_secp256k1_get_shared_secret_impl(port_, req)
    }

    #[wasm_bindgen]
    pub fn wire_secp256k1_recover(port_: MessagePort, req: JsValue) {
        wire_secp256k1_recover_impl(port_, req)
    }

    #[wasm_bindgen]
    pub fn wire_p256_from_seed(port_: MessagePort, req: JsValue) {
        wire_p256_from_seed_impl(port_, req)
    }

    #[wasm_bindgen]
    pub fn wire_p256_sign(port_: MessagePort, req: JsValue) {
        wire_p256_sign_impl(port_, req)
    }

    #[wasm_bindgen]
    pub fn wire_p256_verify(port_: MessagePort, req: JsValue) {
        wire_p256_verify_impl(port_, req)
    }

    #[wasm_bindgen]
    pub fn wire_p256_get_shared_secret(port_: MessagePort, req: JsValue) {
        wire_p256_get_shared_secret_impl(port_, req)
    }

    #[wasm_bindgen]
    pub fn wire_schnorr_from_seed(port_: MessagePort, req: JsValue) {
        wire_schnorr_from_seed_impl(port_, req)
    }

    #[wasm_bindgen]
    pub fn wire_schnorr_sign(port_: MessagePort, req: JsValue) {
        wire_schnorr_sign_impl(port_, req)
    }

    #[wasm_bindgen]
    pub fn wire_schnorr_verify(port_: MessagePort, req: JsValue) {
        wire_schnorr_verify_impl(port_, req)
    }

    #[wasm_bindgen]
    pub fn wire_aes_128_ctr_encrypt(port_: MessagePort, req: JsValue) {
        wire_aes_128_ctr_encrypt_impl(port_, req)
    }

    #[wasm_bindgen]
    pub fn wire_aes_128_ctr_decrypt(port_: MessagePort, req: JsValue) {
        wire_aes_128_ctr_decrypt_impl(port_, req)
    }

    #[wasm_bindgen]
    pub fn wire_aes_256_cbc_encrypt(port_: MessagePort, req: JsValue) {
        wire_aes_256_cbc_encrypt_impl(port_, req)
    }

    #[wasm_bindgen]
    pub fn wire_aes_256_cbc_decrypt(port_: MessagePort, req: JsValue) {
        wire_aes_256_cbc_decrypt_impl(port_, req)
    }

    #[wasm_bindgen]
    pub fn wire_aes_256_gcm_encrypt(port_: MessagePort, req: JsValue) {
        wire_aes_256_gcm_encrypt_impl(port_, req)
    }

    #[wasm_bindgen]
    pub fn wire_aes_256_gcm_decrypt(port_: MessagePort, req: JsValue) {
        wire_aes_256_gcm_decrypt_impl(port_, req)
    }

    #[wasm_bindgen]
    pub fn wire_pbkdf2_derive_key(port_: MessagePort, req: JsValue) {
        wire_pbkdf2_derive_key_impl(port_, req)
    }

    #[wasm_bindgen]
    pub fn wire_scrypt_derive_key(port_: MessagePort, req: JsValue) {
        wire_scrypt_derive_key_impl(port_, req)
    }

    #[wasm_bindgen]
    pub fn wire_create_blockchain__static_method__Api(port_: MessagePort, config: JsValue) {
        wire_create_blockchain__static_method__Api_impl(port_, config)
    }

    #[wasm_bindgen]
    pub fn wire_get_height__static_method__Api(port_: MessagePort, blockchain: JsValue) {
        wire_get_height__static_method__Api_impl(port_, blockchain)
    }

    #[wasm_bindgen]
    pub fn wire_get_blockchain_hash__static_method__Api(
        port_: MessagePort,
        blockchain_height: u32,
        blockchain: JsValue,
    ) {
        wire_get_blockchain_hash__static_method__Api_impl(port_, blockchain_height, blockchain)
    }

    #[wasm_bindgen]
    pub fn wire_estimate_fee__static_method__Api(
        port_: MessagePort,
        target: u64,
        blockchain: JsValue,
    ) {
        wire_estimate_fee__static_method__Api_impl(port_, target, blockchain)
    }

    #[wasm_bindgen]
    pub fn wire_broadcast__static_method__Api(port_: MessagePort, tx: String, blockchain: JsValue) {
        wire_broadcast__static_method__Api_impl(port_, tx, blockchain)
    }

    #[wasm_bindgen]
    pub fn wire_create_transaction__static_method__Api(port_: MessagePort, tx: Box<[u8]>) {
        wire_create_transaction__static_method__Api_impl(port_, tx)
    }

    #[wasm_bindgen]
    pub fn wire_tx_txid__static_method__Api(port_: MessagePort, tx: String) {
        wire_tx_txid__static_method__Api_impl(port_, tx)
    }

    #[wasm_bindgen]
    pub fn wire_weight__static_method__Api(port_: MessagePort, tx: String) {
        wire_weight__static_method__Api_impl(port_, tx)
    }

    #[wasm_bindgen]
    pub fn wire_size__static_method__Api(port_: MessagePort, tx: String) {
        wire_size__static_method__Api_impl(port_, tx)
    }

    #[wasm_bindgen]
    pub fn wire_vsize__static_method__Api(port_: MessagePort, tx: String) {
        wire_vsize__static_method__Api_impl(port_, tx)
    }

    #[wasm_bindgen]
    pub fn wire_serialize_tx__static_method__Api(port_: MessagePort, tx: String) {
        wire_serialize_tx__static_method__Api_impl(port_, tx)
    }

    #[wasm_bindgen]
    pub fn wire_is_coin_base__static_method__Api(port_: MessagePort, tx: String) {
        wire_is_coin_base__static_method__Api_impl(port_, tx)
    }

    #[wasm_bindgen]
    pub fn wire_is_explicitly_rbf__static_method__Api(port_: MessagePort, tx: String) {
        wire_is_explicitly_rbf__static_method__Api_impl(port_, tx)
    }

    #[wasm_bindgen]
    pub fn wire_is_lock_time_enabled__static_method__Api(port_: MessagePort, tx: String) {
        wire_is_lock_time_enabled__static_method__Api_impl(port_, tx)
    }

    #[wasm_bindgen]
    pub fn wire_version__static_method__Api(port_: MessagePort, tx: String) {
        wire_version__static_method__Api_impl(port_, tx)
    }

    #[wasm_bindgen]
    pub fn wire_lock_time__static_method__Api(port_: MessagePort, tx: String) {
        wire_lock_time__static_method__Api_impl(port_, tx)
    }

    #[wasm_bindgen]
    pub fn wire_input__static_method__Api(port_: MessagePort, tx: String) {
        wire_input__static_method__Api_impl(port_, tx)
    }

    #[wasm_bindgen]
    pub fn wire_output__static_method__Api(port_: MessagePort, tx: String) {
        wire_output__static_method__Api_impl(port_, tx)
    }

    #[wasm_bindgen]
    pub fn wire_serialize_psbt__static_method__Api(port_: MessagePort, psbt_str: String) {
        wire_serialize_psbt__static_method__Api_impl(port_, psbt_str)
    }

    #[wasm_bindgen]
    pub fn wire_psbt_txid__static_method__Api(port_: MessagePort, psbt_str: String) {
        wire_psbt_txid__static_method__Api_impl(port_, psbt_str)
    }

    #[wasm_bindgen]
    pub fn wire_extract_tx__static_method__Api(port_: MessagePort, psbt_str: String) {
        wire_extract_tx__static_method__Api_impl(port_, psbt_str)
    }

    #[wasm_bindgen]
    pub fn wire_psbt_fee_rate__static_method__Api(port_: MessagePort, psbt_str: String) {
        wire_psbt_fee_rate__static_method__Api_impl(port_, psbt_str)
    }

    #[wasm_bindgen]
    pub fn wire_psbt_fee_amount__static_method__Api(port_: MessagePort, psbt_str: String) {
        wire_psbt_fee_amount__static_method__Api_impl(port_, psbt_str)
    }

    #[wasm_bindgen]
    pub fn wire_combine_psbt__static_method__Api(
        port_: MessagePort,
        psbt_str: String,
        other: String,
    ) {
        wire_combine_psbt__static_method__Api_impl(port_, psbt_str, other)
    }

    #[wasm_bindgen]
    pub fn wire_json_serialize__static_method__Api(port_: MessagePort, psbt_str: String) {
        wire_json_serialize__static_method__Api_impl(port_, psbt_str)
    }

    #[wasm_bindgen]
    pub fn wire_get_inputs__static_method__Api(port_: MessagePort, psbt_str: String) {
        wire_get_inputs__static_method__Api_impl(port_, psbt_str)
    }

    #[wasm_bindgen]
    pub fn wire_tx_builder_finish__static_method__Api(
        port_: MessagePort,
        wallet: JsValue,
        recipients: JsValue,
        utxos: JsValue,
        unspendable: JsValue,
        change_policy: i32,
        manually_selected_only: bool,
        fee_rate: JsValue,
        fee_absolute: JsValue,
        drain_wallet: bool,
        drain_to: JsValue,
        rbf: JsValue,
        data: Box<[u8]>,
        shuffle_utxo: JsValue,
    ) {
        wire_tx_builder_finish__static_method__Api_impl(
            port_,
            wallet,
            recipients,
            utxos,
            unspendable,
            change_policy,
            manually_selected_only,
            fee_rate,
            fee_absolute,
            drain_wallet,
            drain_to,
            rbf,
            data,
            shuffle_utxo,
        )
    }

    #[wasm_bindgen]
    pub fn wire_bump_fee_tx_builder_finish__static_method__Api(
        port_: MessagePort,
        txid: String,
        fee_rate: f32,
        allow_shrinking: Option<String>,
        wallet: JsValue,
        enable_rbf: bool,
        keep_change: bool,
        n_sequence: JsValue,
    ) {
        wire_bump_fee_tx_builder_finish__static_method__Api_impl(
            port_,
            txid,
            fee_rate,
            allow_shrinking,
            wallet,
            enable_rbf,
            keep_change,
            n_sequence,
        )
    }

    #[wasm_bindgen]
    pub fn wire_create_descriptor__static_method__Api(
        port_: MessagePort,
        descriptor: String,
        network: i32,
    ) {
        wire_create_descriptor__static_method__Api_impl(port_, descriptor, network)
    }

    #[wasm_bindgen]
    pub fn wire_new_bip44_descriptor__static_method__Api(
        port_: MessagePort,
        key_chain_kind: i32,
        secret_key: String,
        network: i32,
    ) {
        wire_new_bip44_descriptor__static_method__Api_impl(
            port_,
            key_chain_kind,
            secret_key,
            network,
        )
    }

    #[wasm_bindgen]
    pub fn wire_new_bip44_public__static_method__Api(
        port_: MessagePort,
        key_chain_kind: i32,
        public_key: String,
        network: i32,
        fingerprint: String,
    ) {
        wire_new_bip44_public__static_method__Api_impl(
            port_,
            key_chain_kind,
            public_key,
            network,
            fingerprint,
        )
    }

    #[wasm_bindgen]
    pub fn wire_new_bip49_descriptor__static_method__Api(
        port_: MessagePort,
        key_chain_kind: i32,
        secret_key: String,
        network: i32,
    ) {
        wire_new_bip49_descriptor__static_method__Api_impl(
            port_,
            key_chain_kind,
            secret_key,
            network,
        )
    }

    #[wasm_bindgen]
    pub fn wire_new_bip49_public__static_method__Api(
        port_: MessagePort,
        key_chain_kind: i32,
        public_key: String,
        network: i32,
        fingerprint: String,
    ) {
        wire_new_bip49_public__static_method__Api_impl(
            port_,
            key_chain_kind,
            public_key,
            network,
            fingerprint,
        )
    }

    #[wasm_bindgen]
    pub fn wire_new_bip84_descriptor__static_method__Api(
        port_: MessagePort,
        key_chain_kind: i32,
        secret_key: String,
        network: i32,
    ) {
        wire_new_bip84_descriptor__static_method__Api_impl(
            port_,
            key_chain_kind,
            secret_key,
            network,
        )
    }

    #[wasm_bindgen]
    pub fn wire_new_bip84_public__static_method__Api(
        port_: MessagePort,
        key_chain_kind: i32,
        public_key: String,
        network: i32,
        fingerprint: String,
    ) {
        wire_new_bip84_public__static_method__Api_impl(
            port_,
            key_chain_kind,
            public_key,
            network,
            fingerprint,
        )
    }

    #[wasm_bindgen]
    pub fn wire_new_bip86_descriptor__static_method__Api(
        port_: MessagePort,
        key_chain_kind: i32,
        secret_key: String,
        network: i32,
    ) {
        wire_new_bip86_descriptor__static_method__Api_impl(
            port_,
            key_chain_kind,
            secret_key,
            network,
        )
    }

    #[wasm_bindgen]
    pub fn wire_new_bip86_public__static_method__Api(
        port_: MessagePort,
        key_chain_kind: i32,
        public_key: String,
        network: i32,
        fingerprint: String,
    ) {
        wire_new_bip86_public__static_method__Api_impl(
            port_,
            key_chain_kind,
            public_key,
            network,
            fingerprint,
        )
    }

    #[wasm_bindgen]
    pub fn wire_as_string_private__static_method__Api(port_: MessagePort, descriptor: JsValue) {
        wire_as_string_private__static_method__Api_impl(port_, descriptor)
    }

    #[wasm_bindgen]
    pub fn wire_as_string__static_method__Api(port_: MessagePort, descriptor: JsValue) {
        wire_as_string__static_method__Api_impl(port_, descriptor)
    }

    #[wasm_bindgen]
    pub fn wire_create_descriptor_secret__static_method__Api(
        port_: MessagePort,
        network: i32,
        mnemonic: String,
        password: Option<String>,
    ) {
        wire_create_descriptor_secret__static_method__Api_impl(port_, network, mnemonic, password)
    }

    #[wasm_bindgen]
    pub fn wire_create_derived_descriptor_secret__static_method__Api(
        port_: MessagePort,
        network: i32,
        mnemonic: String,
        path: String,
        password: Option<String>,
    ) {
        wire_create_derived_descriptor_secret__static_method__Api_impl(
            port_, network, mnemonic, path, password,
        )
    }

    #[wasm_bindgen]
    pub fn wire_descriptor_secret_from_string__static_method__Api(
        port_: MessagePort,
        secret: String,
    ) {
        wire_descriptor_secret_from_string__static_method__Api_impl(port_, secret)
    }

    #[wasm_bindgen]
    pub fn wire_extend_descriptor_secret__static_method__Api(
        port_: MessagePort,
        secret: String,
        path: String,
    ) {
        wire_extend_descriptor_secret__static_method__Api_impl(port_, secret, path)
    }

    #[wasm_bindgen]
    pub fn wire_derive_descriptor_secret__static_method__Api(
        port_: MessagePort,
        secret: String,
        path: String,
    ) {
        wire_derive_descriptor_secret__static_method__Api_impl(port_, secret, path)
    }

    #[wasm_bindgen]
    pub fn wire_as_secret_bytes__static_method__Api(port_: MessagePort, secret: String) {
        wire_as_secret_bytes__static_method__Api_impl(port_, secret)
    }

    #[wasm_bindgen]
    pub fn wire_as_public__static_method__Api(port_: MessagePort, secret: String) {
        wire_as_public__static_method__Api_impl(port_, secret)
    }

    #[wasm_bindgen]
    pub fn wire_get_pub_from_secret_bytes__static_method__Api(
        port_: MessagePort,
        bytes: Box<[u8]>,
    ) {
        wire_get_pub_from_secret_bytes__static_method__Api_impl(port_, bytes)
    }

    #[wasm_bindgen]
    pub fn wire_create_derivation_path__static_method__Api(port_: MessagePort, path: String) {
        wire_create_derivation_path__static_method__Api_impl(port_, path)
    }

    #[wasm_bindgen]
    pub fn wire_descriptor_public_from_string__static_method__Api(
        port_: MessagePort,
        public_key: String,
    ) {
        wire_descriptor_public_from_string__static_method__Api_impl(port_, public_key)
    }

    #[wasm_bindgen]
    pub fn wire_master_finterprint__static_method__Api(port_: MessagePort, xpub: String) {
        wire_master_finterprint__static_method__Api_impl(port_, xpub)
    }

    #[wasm_bindgen]
    pub fn wire_create_descriptor_public__static_method__Api(
        port_: MessagePort,
        xpub: Option<String>,
        path: String,
        derive: bool,
    ) {
        wire_create_descriptor_public__static_method__Api_impl(port_, xpub, path, derive)
    }

    #[wasm_bindgen]
    pub fn wire_to_public_string__static_method__Api(port_: MessagePort, xpub: String) {
        wire_to_public_string__static_method__Api_impl(port_, xpub)
    }

    #[wasm_bindgen]
    pub fn wire_create_script__static_method__Api(
        port_: MessagePort,
        raw_output_script: Box<[u8]>,
    ) {
        wire_create_script__static_method__Api_impl(port_, raw_output_script)
    }

    #[wasm_bindgen]
    pub fn wire_create_address__static_method__Api(port_: MessagePort, address: String) {
        wire_create_address__static_method__Api_impl(port_, address)
    }

    #[wasm_bindgen]
    pub fn wire_address_from_script__static_method__Api(
        port_: MessagePort,
        script: JsValue,
        network: i32,
    ) {
        wire_address_from_script__static_method__Api_impl(port_, script, network)
    }

    #[wasm_bindgen]
    pub fn wire_address_to_script_pubkey__static_method__Api(port_: MessagePort, address: String) {
        wire_address_to_script_pubkey__static_method__Api_impl(port_, address)
    }

    #[wasm_bindgen]
    pub fn wire_payload__static_method__Api(port_: MessagePort, address: String) {
        wire_payload__static_method__Api_impl(port_, address)
    }

    #[wasm_bindgen]
    pub fn wire_address_network__static_method__Api(port_: MessagePort, address: String) {
        wire_address_network__static_method__Api_impl(port_, address)
    }

    #[wasm_bindgen]
    pub fn wire_create_wallet__static_method__Api(
        port_: MessagePort,
        descriptor: JsValue,
        change_descriptor: JsValue,
        network: i32,
        database_config: JsValue,
    ) {
        wire_create_wallet__static_method__Api_impl(
            port_,
            descriptor,
            change_descriptor,
            network,
            database_config,
        )
    }

    #[wasm_bindgen]
    pub fn wire_get_address__static_method__Api(
        port_: MessagePort,
        wallet: JsValue,
        address_index: JsValue,
    ) {
        wire_get_address__static_method__Api_impl(port_, wallet, address_index)
    }

    #[wasm_bindgen]
    pub fn wire_get_internal_address__static_method__Api(
        port_: MessagePort,
        wallet: JsValue,
        address_index: JsValue,
    ) {
        wire_get_internal_address__static_method__Api_impl(port_, wallet, address_index)
    }

    #[wasm_bindgen]
    pub fn wire_sync_wallet__static_method__Api(
        port_: MessagePort,
        wallet: JsValue,
        blockchain: JsValue,
    ) {
        wire_sync_wallet__static_method__Api_impl(port_, wallet, blockchain)
    }

    #[wasm_bindgen]
    pub fn wire_sync_wallet_thread__static_method__Api(
        port_: MessagePort,
        wallet: JsValue,
        blockchain: JsValue,
    ) {
        wire_sync_wallet_thread__static_method__Api_impl(port_, wallet, blockchain)
    }

    #[wasm_bindgen]
    pub fn wire_get_balance__static_method__Api(port_: MessagePort, wallet: JsValue) {
        wire_get_balance__static_method__Api_impl(port_, wallet)
    }

    #[wasm_bindgen]
    pub fn wire_list_unspent_outputs__static_method__Api(port_: MessagePort, wallet: JsValue) {
        wire_list_unspent_outputs__static_method__Api_impl(port_, wallet)
    }

    #[wasm_bindgen]
    pub fn wire_get_transactions__static_method__Api(
        port_: MessagePort,
        wallet: JsValue,
        include_raw: bool,
    ) {
        wire_get_transactions__static_method__Api_impl(port_, wallet, include_raw)
    }

    #[wasm_bindgen]
    pub fn wire_sign__static_method__Api(
        port_: MessagePort,
        wallet: JsValue,
        psbt_str: String,
        sign_options: JsValue,
    ) {
        wire_sign__static_method__Api_impl(port_, wallet, psbt_str, sign_options)
    }

    #[wasm_bindgen]
    pub fn wire_wallet_network__static_method__Api(port_: MessagePort, wallet: JsValue) {
        wire_wallet_network__static_method__Api_impl(port_, wallet)
    }

    #[wasm_bindgen]
    pub fn wire_list_unspent__static_method__Api(port_: MessagePort, wallet: JsValue) {
        wire_list_unspent__static_method__Api_impl(port_, wallet)
    }

    #[wasm_bindgen]
    pub fn wire_generate_seed_from_word_count__static_method__Api(
        port_: MessagePort,
        word_count: i32,
    ) {
        wire_generate_seed_from_word_count__static_method__Api_impl(port_, word_count)
    }

    #[wasm_bindgen]
    pub fn wire_generate_seed_from_string__static_method__Api(
        port_: MessagePort,
        mnemonic: String,
    ) {
        wire_generate_seed_from_string__static_method__Api_impl(port_, mnemonic)
    }

    #[wasm_bindgen]
    pub fn wire_generate_seed_from_entropy__static_method__Api(
        port_: MessagePort,
        entropy: Box<[u8]>,
    ) {
        wire_generate_seed_from_entropy__static_method__Api_impl(port_, entropy)
    }

    // Section: allocate functions

    // Section: related functions

    #[wasm_bindgen]
    pub fn drop_opaque_BdkDescriptor(ptr: *const c_void) {
        unsafe {
            Arc::<BdkDescriptor>::decrement_strong_count(ptr as _);
        }
    }

    #[wasm_bindgen]
    pub fn share_opaque_BdkDescriptor(ptr: *const c_void) -> *const c_void {
        unsafe {
            Arc::<BdkDescriptor>::increment_strong_count(ptr as _);
            ptr
        }
    }

    #[wasm_bindgen]
    pub fn drop_opaque_BlockchainInstance(ptr: *const c_void) {
        unsafe {
            Arc::<BlockchainInstance>::decrement_strong_count(ptr as _);
        }
    }

    #[wasm_bindgen]
    pub fn share_opaque_BlockchainInstance(ptr: *const c_void) -> *const c_void {
        unsafe {
            Arc::<BlockchainInstance>::increment_strong_count(ptr as _);
            ptr
        }
    }

    #[wasm_bindgen]
    pub fn drop_opaque_WalletInstance(ptr: *const c_void) {
        unsafe {
            Arc::<WalletInstance>::decrement_strong_count(ptr as _);
        }
    }

    #[wasm_bindgen]
    pub fn share_opaque_WalletInstance(ptr: *const c_void) -> *const c_void {
        unsafe {
            Arc::<WalletInstance>::increment_strong_count(ptr as _);
            ptr
        }
    }

    // Section: impl Wire2Api

    impl Wire2Api<String> for String {
        fn wire2api(self) -> String {
            self
        }
    }

    impl Wire2Api<AddressIndex> for JsValue {
        fn wire2api(self) -> AddressIndex {
            let self_ = self.unchecked_into::<JsArray>();
            match self_.get(0).unchecked_into_f64() as _ {
                0 => AddressIndex::New,
                1 => AddressIndex::LastUnused,
                2 => AddressIndex::Peek {
                    index: self_.get(1).wire2api(),
                },
                3 => AddressIndex::Reset {
                    index: self_.get(1).wire2api(),
                },
                _ => unreachable!(),
            }
        }
    }
    impl Wire2Api<AesDecryptReq> for JsValue {
        fn wire2api(self) -> AesDecryptReq {
            let self_ = self.dyn_into::<JsArray>().unwrap();
            assert_eq!(
                self_.length(),
                3,
                "Expected 3 elements, got {}",
                self_.length()
            );
            AesDecryptReq {
                key: self_.get(0).wire2api(),
                iv: self_.get(1).wire2api(),
                cipher_text: self_.get(2).wire2api(),
            }
        }
    }
    impl Wire2Api<AesEncryptReq> for JsValue {
        fn wire2api(self) -> AesEncryptReq {
            let self_ = self.dyn_into::<JsArray>().unwrap();
            assert_eq!(
                self_.length(),
                3,
                "Expected 3 elements, got {}",
                self_.length()
            );
            AesEncryptReq {
                key: self_.get(0).wire2api(),
                iv: self_.get(1).wire2api(),
                message: self_.get(2).wire2api(),
            }
        }
    }
    impl Wire2Api<BlockchainConfig> for JsValue {
        fn wire2api(self) -> BlockchainConfig {
            let self_ = self.unchecked_into::<JsArray>();
            match self_.get(0).unchecked_into_f64() as _ {
                0 => BlockchainConfig::Electrum {
                    config: self_.get(1).wire2api(),
                },
                1 => BlockchainConfig::Esplora {
                    config: self_.get(1).wire2api(),
                },
                2 => BlockchainConfig::Rpc {
                    config: self_.get(1).wire2api(),
                },
                _ => unreachable!(),
            }
        }
    }
    impl Wire2Api<BLSVerifyReq> for JsValue {
        fn wire2api(self) -> BLSVerifyReq {
            let self_ = self.dyn_into::<JsArray>().unwrap();
            assert_eq!(
                self_.length(),
                3,
                "Expected 3 elements, got {}",
                self_.length()
            );
            BLSVerifyReq {
                signature: self_.get(0).wire2api(),
                message: self_.get(1).wire2api(),
                public_key: self_.get(2).wire2api(),
            }
        }
    }

    impl Wire2Api<DatabaseConfig> for JsValue {
        fn wire2api(self) -> DatabaseConfig {
            let self_ = self.unchecked_into::<JsArray>();
            match self_.get(0).unchecked_into_f64() as _ {
                0 => DatabaseConfig::Memory,
                1 => DatabaseConfig::Sqlite {
                    config: self_.get(1).wire2api(),
                },
                2 => DatabaseConfig::Sled {
                    config: self_.get(1).wire2api(),
                },
                _ => unreachable!(),
            }
        }
    }
    impl Wire2Api<ED25519FromSeedReq> for JsValue {
        fn wire2api(self) -> ED25519FromSeedReq {
            let self_ = self.dyn_into::<JsArray>().unwrap();
            assert_eq!(
                self_.length(),
                1,
                "Expected 1 elements, got {}",
                self_.length()
            );
            ED25519FromSeedReq {
                seed: self_.get(0).wire2api(),
            }
        }
    }
    impl Wire2Api<ED25519SignReq> for JsValue {
        fn wire2api(self) -> ED25519SignReq {
            let self_ = self.dyn_into::<JsArray>().unwrap();
            assert_eq!(
                self_.length(),
                2,
                "Expected 2 elements, got {}",
                self_.length()
            );
            ED25519SignReq {
                seed: self_.get(0).wire2api(),
                message: self_.get(1).wire2api(),
            }
        }
    }
    impl Wire2Api<ED25519VerifyReq> for JsValue {
        fn wire2api(self) -> ED25519VerifyReq {
            let self_ = self.dyn_into::<JsArray>().unwrap();
            assert_eq!(
                self_.length(),
                3,
                "Expected 3 elements, got {}",
                self_.length()
            );
            ED25519VerifyReq {
                sig: self_.get(0).wire2api(),
                message: self_.get(1).wire2api(),
                pub_key: self_.get(2).wire2api(),
            }
        }
    }
    impl Wire2Api<ElectrumConfig> for JsValue {
        fn wire2api(self) -> ElectrumConfig {
            let self_ = self.dyn_into::<JsArray>().unwrap();
            assert_eq!(
                self_.length(),
                6,
                "Expected 6 elements, got {}",
                self_.length()
            );
            ElectrumConfig {
                url: self_.get(0).wire2api(),
                socks5: self_.get(1).wire2api(),
                retry: self_.get(2).wire2api(),
                timeout: self_.get(3).wire2api(),
                stop_gap: self_.get(4).wire2api(),
                validate_domain: self_.get(5).wire2api(),
            }
        }
    }
    impl Wire2Api<EsploraConfig> for JsValue {
        fn wire2api(self) -> EsploraConfig {
            let self_ = self.dyn_into::<JsArray>().unwrap();
            assert_eq!(
                self_.length(),
                5,
                "Expected 5 elements, got {}",
                self_.length()
            );
            EsploraConfig {
                base_url: self_.get(0).wire2api(),
                proxy: self_.get(1).wire2api(),
                concurrency: self_.get(2).wire2api(),
                stop_gap: self_.get(3).wire2api(),
                timeout: self_.get(4).wire2api(),
            }
        }
    }

    impl Wire2Api<Vec<OutPoint>> for JsValue {
        fn wire2api(self) -> Vec<OutPoint> {
            self.dyn_into::<JsArray>()
                .unwrap()
                .iter()
                .map(Wire2Api::wire2api)
                .collect()
        }
    }
    impl Wire2Api<Vec<ScriptAmount>> for JsValue {
        fn wire2api(self) -> Vec<ScriptAmount> {
            self.dyn_into::<JsArray>()
                .unwrap()
                .iter()
                .map(Wire2Api::wire2api)
                .collect()
        }
    }

    impl Wire2Api<Option<String>> for Option<String> {
        fn wire2api(self) -> Option<String> {
            self.map(Wire2Api::wire2api)
        }
    }
    impl Wire2Api<Option<RustOpaque<BdkDescriptor>>> for JsValue {
        fn wire2api(self) -> Option<RustOpaque<BdkDescriptor>> {
            (!self.is_undefined() && !self.is_null()).then(|| self.wire2api())
        }
    }

    impl Wire2Api<Option<RbfValue>> for JsValue {
        fn wire2api(self) -> Option<RbfValue> {
            (!self.is_undefined() && !self.is_null()).then(|| self.wire2api())
        }
    }
    impl Wire2Api<Option<RpcSyncParams>> for JsValue {
        fn wire2api(self) -> Option<RpcSyncParams> {
            (!self.is_undefined() && !self.is_null()).then(|| self.wire2api())
        }
    }
    impl Wire2Api<Option<Script>> for JsValue {
        fn wire2api(self) -> Option<Script> {
            (!self.is_undefined() && !self.is_null()).then(|| self.wire2api())
        }
    }
    impl Wire2Api<Option<SignOptions>> for JsValue {
        fn wire2api(self) -> Option<SignOptions> {
            (!self.is_undefined() && !self.is_null()).then(|| self.wire2api())
        }
    }

    impl Wire2Api<Option<UserPass>> for JsValue {
        fn wire2api(self) -> Option<UserPass> {
            (!self.is_undefined() && !self.is_null()).then(|| self.wire2api())
        }
    }
    impl Wire2Api<Option<Vec<u8>>> for Option<Box<[u8]>> {
        fn wire2api(self) -> Option<Vec<u8>> {
            self.map(Wire2Api::wire2api)
        }
    }
    impl Wire2Api<OutPoint> for JsValue {
        fn wire2api(self) -> OutPoint {
            let self_ = self.dyn_into::<JsArray>().unwrap();
            assert_eq!(
                self_.length(),
                2,
                "Expected 2 elements, got {}",
                self_.length()
            );
            OutPoint {
                txid: self_.get(0).wire2api(),
                vout: self_.get(1).wire2api(),
            }
        }
    }
    impl Wire2Api<P256FromSeedReq> for JsValue {
        fn wire2api(self) -> P256FromSeedReq {
            let self_ = self.dyn_into::<JsArray>().unwrap();
            assert_eq!(
                self_.length(),
                1,
                "Expected 1 elements, got {}",
                self_.length()
            );
            P256FromSeedReq {
                seed: self_.get(0).wire2api(),
            }
        }
    }
    impl Wire2Api<P256ShareSecretReq> for JsValue {
        fn wire2api(self) -> P256ShareSecretReq {
            let self_ = self.dyn_into::<JsArray>().unwrap();
            assert_eq!(
                self_.length(),
                2,
                "Expected 2 elements, got {}",
                self_.length()
            );
            P256ShareSecretReq {
                seed: self_.get(0).wire2api(),
                public_key_raw_bytes: self_.get(1).wire2api(),
            }
        }
    }
    impl Wire2Api<P256SignWithSeedReq> for JsValue {
        fn wire2api(self) -> P256SignWithSeedReq {
            let self_ = self.dyn_into::<JsArray>().unwrap();
            assert_eq!(
                self_.length(),
                2,
                "Expected 2 elements, got {}",
                self_.length()
            );
            P256SignWithSeedReq {
                msg: self_.get(0).wire2api(),
                seed: self_.get(1).wire2api(),
            }
        }
    }
    impl Wire2Api<P256VerifyReq> for JsValue {
        fn wire2api(self) -> P256VerifyReq {
            let self_ = self.dyn_into::<JsArray>().unwrap();
            assert_eq!(
                self_.length(),
                3,
                "Expected 3 elements, got {}",
                self_.length()
            );
            P256VerifyReq {
                message_hash: self_.get(0).wire2api(),
                signature_bytes: self_.get(1).wire2api(),
                public_key_bytes: self_.get(2).wire2api(),
            }
        }
    }
    impl Wire2Api<PBKDFDeriveReq> for JsValue {
        fn wire2api(self) -> PBKDFDeriveReq {
            let self_ = self.dyn_into::<JsArray>().unwrap();
            assert_eq!(
                self_.length(),
                3,
                "Expected 3 elements, got {}",
                self_.length()
            );
            PBKDFDeriveReq {
                password: self_.get(0).wire2api(),
                salt: self_.get(1).wire2api(),
                c: self_.get(2).wire2api(),
            }
        }
    }
    impl Wire2Api<PhraseToSeedReq> for JsValue {
        fn wire2api(self) -> PhraseToSeedReq {
            let self_ = self.dyn_into::<JsArray>().unwrap();
            assert_eq!(
                self_.length(),
                2,
                "Expected 2 elements, got {}",
                self_.length()
            );
            PhraseToSeedReq {
                phrase: self_.get(0).wire2api(),
                password: self_.get(1).wire2api(),
            }
        }
    }
    impl Wire2Api<RbfValue> for JsValue {
        fn wire2api(self) -> RbfValue {
            let self_ = self.unchecked_into::<JsArray>();
            match self_.get(0).unchecked_into_f64() as _ {
                0 => RbfValue::RbfDefault,
                1 => RbfValue::Value(self_.get(1).wire2api()),
                _ => unreachable!(),
            }
        }
    }
    impl Wire2Api<RpcConfig> for JsValue {
        fn wire2api(self) -> RpcConfig {
            let self_ = self.dyn_into::<JsArray>().unwrap();
            assert_eq!(
                self_.length(),
                6,
                "Expected 6 elements, got {}",
                self_.length()
            );
            RpcConfig {
                url: self_.get(0).wire2api(),
                auth_cookie: self_.get(1).wire2api(),
                auth_user_pass: self_.get(2).wire2api(),
                network: self_.get(3).wire2api(),
                wallet_name: self_.get(4).wire2api(),
                sync_params: self_.get(5).wire2api(),
            }
        }
    }
    impl Wire2Api<RpcSyncParams> for JsValue {
        fn wire2api(self) -> RpcSyncParams {
            let self_ = self.dyn_into::<JsArray>().unwrap();
            assert_eq!(
                self_.length(),
                4,
                "Expected 4 elements, got {}",
                self_.length()
            );
            RpcSyncParams {
                start_script_count: self_.get(0).wire2api(),
                start_time: self_.get(1).wire2api(),
                force_start_time: self_.get(2).wire2api(),
                poll_rate_sec: self_.get(3).wire2api(),
            }
        }
    }
    impl Wire2Api<SchnorrFromSeedReq> for JsValue {
        fn wire2api(self) -> SchnorrFromSeedReq {
            let self_ = self.dyn_into::<JsArray>().unwrap();
            assert_eq!(
                self_.length(),
                1,
                "Expected 1 elements, got {}",
                self_.length()
            );
            SchnorrFromSeedReq {
                seed: self_.get(0).wire2api(),
            }
        }
    }
    impl Wire2Api<SchnorrSignWithSeedReq> for JsValue {
        fn wire2api(self) -> SchnorrSignWithSeedReq {
            let self_ = self.dyn_into::<JsArray>().unwrap();
            assert_eq!(
                self_.length(),
                3,
                "Expected 3 elements, got {}",
                self_.length()
            );
            SchnorrSignWithSeedReq {
                msg: self_.get(0).wire2api(),
                seed: self_.get(1).wire2api(),
                aux_rand: self_.get(2).wire2api(),
            }
        }
    }
    impl Wire2Api<SchnorrVerifyReq> for JsValue {
        fn wire2api(self) -> SchnorrVerifyReq {
            let self_ = self.dyn_into::<JsArray>().unwrap();
            assert_eq!(
                self_.length(),
                3,
                "Expected 3 elements, got {}",
                self_.length()
            );
            SchnorrVerifyReq {
                message_hash: self_.get(0).wire2api(),
                signature_bytes: self_.get(1).wire2api(),
                public_key_bytes: self_.get(2).wire2api(),
            }
        }
    }
    impl Wire2Api<Script> for JsValue {
        fn wire2api(self) -> Script {
            let self_ = self.dyn_into::<JsArray>().unwrap();
            assert_eq!(
                self_.length(),
                1,
                "Expected 1 elements, got {}",
                self_.length()
            );
            Script {
                internal: self_.get(0).wire2api(),
            }
        }
    }
    impl Wire2Api<ScriptAmount> for JsValue {
        fn wire2api(self) -> ScriptAmount {
            let self_ = self.dyn_into::<JsArray>().unwrap();
            assert_eq!(
                self_.length(),
                2,
                "Expected 2 elements, got {}",
                self_.length()
            );
            ScriptAmount {
                script: self_.get(0).wire2api(),
                amount: self_.get(1).wire2api(),
            }
        }
    }
    impl Wire2Api<ScriptDeriveReq> for JsValue {
        fn wire2api(self) -> ScriptDeriveReq {
            let self_ = self.dyn_into::<JsArray>().unwrap();
            assert_eq!(
                self_.length(),
                5,
                "Expected 5 elements, got {}",
                self_.length()
            );
            ScriptDeriveReq {
                password: self_.get(0).wire2api(),
                salt: self_.get(1).wire2api(),
                n: self_.get(2).wire2api(),
                p: self_.get(3).wire2api(),
                r: self_.get(4).wire2api(),
            }
        }
    }
    impl Wire2Api<Secp256k1FromSeedReq> for JsValue {
        fn wire2api(self) -> Secp256k1FromSeedReq {
            let self_ = self.dyn_into::<JsArray>().unwrap();
            assert_eq!(
                self_.length(),
                1,
                "Expected 1 elements, got {}",
                self_.length()
            );
            Secp256k1FromSeedReq {
                seed: self_.get(0).wire2api(),
            }
        }
    }
    impl Wire2Api<Secp256k1RecoverReq> for JsValue {
        fn wire2api(self) -> Secp256k1RecoverReq {
            let self_ = self.dyn_into::<JsArray>().unwrap();
            assert_eq!(
                self_.length(),
                3,
                "Expected 3 elements, got {}",
                self_.length()
            );
            Secp256k1RecoverReq {
                message_pre_hashed: self_.get(0).wire2api(),
                signature_bytes: self_.get(1).wire2api(),
                chain_id: self_.get(2).wire2api(),
            }
        }
    }
    impl Wire2Api<Secp256k1ShareSecretReq> for JsValue {
        fn wire2api(self) -> Secp256k1ShareSecretReq {
            let self_ = self.dyn_into::<JsArray>().unwrap();
            assert_eq!(
                self_.length(),
                2,
                "Expected 2 elements, got {}",
                self_.length()
            );
            Secp256k1ShareSecretReq {
                seed: self_.get(0).wire2api(),
                public_key_raw_bytes: self_.get(1).wire2api(),
            }
        }
    }
    impl Wire2Api<Secp256k1SignWithSeedReq> for JsValue {
        fn wire2api(self) -> Secp256k1SignWithSeedReq {
            let self_ = self.dyn_into::<JsArray>().unwrap();
            assert_eq!(
                self_.length(),
                2,
                "Expected 2 elements, got {}",
                self_.length()
            );
            Secp256k1SignWithSeedReq {
                msg: self_.get(0).wire2api(),
                seed: self_.get(1).wire2api(),
            }
        }
    }
    impl Wire2Api<Secp256k1VerifyReq> for JsValue {
        fn wire2api(self) -> Secp256k1VerifyReq {
            let self_ = self.dyn_into::<JsArray>().unwrap();
            assert_eq!(
                self_.length(),
                3,
                "Expected 3 elements, got {}",
                self_.length()
            );
            Secp256k1VerifyReq {
                message_hash: self_.get(0).wire2api(),
                signature_bytes: self_.get(1).wire2api(),
                public_key_bytes: self_.get(2).wire2api(),
            }
        }
    }
    impl Wire2Api<SeedToKeyReq> for JsValue {
        fn wire2api(self) -> SeedToKeyReq {
            let self_ = self.dyn_into::<JsArray>().unwrap();
            assert_eq!(
                self_.length(),
                2,
                "Expected 2 elements, got {}",
                self_.length()
            );
            SeedToKeyReq {
                seed: self_.get(0).wire2api(),
                path: self_.get(1).wire2api(),
            }
        }
    }
    impl Wire2Api<SignOptions> for JsValue {
        fn wire2api(self) -> SignOptions {
            let self_ = self.dyn_into::<JsArray>().unwrap();
            assert_eq!(
                self_.length(),
                7,
                "Expected 7 elements, got {}",
                self_.length()
            );
            SignOptions {
                trust_witness_utxo: self_.get(0).wire2api(),
                assume_height: self_.get(1).wire2api(),
                allow_all_sighashes: self_.get(2).wire2api(),
                remove_partial_sigs: self_.get(3).wire2api(),
                try_finalize: self_.get(4).wire2api(),
                sign_with_tap_internal_key: self_.get(5).wire2api(),
                allow_grinding: self_.get(6).wire2api(),
            }
        }
    }
    impl Wire2Api<SledDbConfiguration> for JsValue {
        fn wire2api(self) -> SledDbConfiguration {
            let self_ = self.dyn_into::<JsArray>().unwrap();
            assert_eq!(
                self_.length(),
                2,
                "Expected 2 elements, got {}",
                self_.length()
            );
            SledDbConfiguration {
                path: self_.get(0).wire2api(),
                tree_name: self_.get(1).wire2api(),
            }
        }
    }
    impl Wire2Api<SqliteDbConfiguration> for JsValue {
        fn wire2api(self) -> SqliteDbConfiguration {
            let self_ = self.dyn_into::<JsArray>().unwrap();
            assert_eq!(
                self_.length(),
                1,
                "Expected 1 elements, got {}",
                self_.length()
            );
            SqliteDbConfiguration {
                path: self_.get(0).wire2api(),
            }
        }
    }

    impl Wire2Api<Vec<u8>> for Box<[u8]> {
        fn wire2api(self) -> Vec<u8> {
            self.into_vec()
        }
    }
    impl Wire2Api<UserPass> for JsValue {
        fn wire2api(self) -> UserPass {
            let self_ = self.dyn_into::<JsArray>().unwrap();
            assert_eq!(
                self_.length(),
                2,
                "Expected 2 elements, got {}",
                self_.length()
            );
            UserPass {
                username: self_.get(0).wire2api(),
                password: self_.get(1).wire2api(),
            }
        }
    }

    // Section: impl Wire2Api for JsValue

    impl Wire2Api<RustOpaque<BdkDescriptor>> for JsValue {
        fn wire2api(self) -> RustOpaque<BdkDescriptor> {
            #[cfg(target_pointer_width = "64")]
            {
                compile_error!("64-bit pointers are not supported.");
            }

            unsafe { support::opaque_from_dart((self.as_f64().unwrap() as usize) as _) }
        }
    }
    impl Wire2Api<RustOpaque<BlockchainInstance>> for JsValue {
        fn wire2api(self) -> RustOpaque<BlockchainInstance> {
            #[cfg(target_pointer_width = "64")]
            {
                compile_error!("64-bit pointers are not supported.");
            }

            unsafe { support::opaque_from_dart((self.as_f64().unwrap() as usize) as _) }
        }
    }
    impl Wire2Api<String> for JsValue {
        fn wire2api(self) -> String {
            self.as_string().expect("non-UTF-8 string, or not a string")
        }
    }
    impl Wire2Api<RustOpaque<WalletInstance>> for JsValue {
        fn wire2api(self) -> RustOpaque<WalletInstance> {
            #[cfg(target_pointer_width = "64")]
            {
                compile_error!("64-bit pointers are not supported.");
            }

            unsafe { support::opaque_from_dart((self.as_f64().unwrap() as usize) as _) }
        }
    }
    impl Wire2Api<bool> for JsValue {
        fn wire2api(self) -> bool {
            self.is_truthy()
        }
    }
    impl Wire2Api<ChangeSpendPolicy> for JsValue {
        fn wire2api(self) -> ChangeSpendPolicy {
            (self.unchecked_into_f64() as i32).wire2api()
        }
    }
    impl Wire2Api<f32> for JsValue {
        fn wire2api(self) -> f32 {
            self.unchecked_into_f64() as _
        }
    }
    impl Wire2Api<i32> for JsValue {
        fn wire2api(self) -> i32 {
            self.unchecked_into_f64() as _
        }
    }
    impl Wire2Api<KeychainKind> for JsValue {
        fn wire2api(self) -> KeychainKind {
            (self.unchecked_into_f64() as i32).wire2api()
        }
    }
    impl Wire2Api<Network> for JsValue {
        fn wire2api(self) -> Network {
            (self.unchecked_into_f64() as i32).wire2api()
        }
    }
    impl Wire2Api<Option<String>> for JsValue {
        fn wire2api(self) -> Option<String> {
            (!self.is_undefined() && !self.is_null()).then(|| self.wire2api())
        }
    }
    impl Wire2Api<Option<bool>> for JsValue {
        fn wire2api(self) -> Option<bool> {
            (!self.is_undefined() && !self.is_null()).then(|| self.wire2api())
        }
    }
    impl Wire2Api<Option<f32>> for JsValue {
        fn wire2api(self) -> Option<f32> {
            (!self.is_undefined() && !self.is_null()).then(|| self.wire2api())
        }
    }
    impl Wire2Api<Option<u32>> for JsValue {
        fn wire2api(self) -> Option<u32> {
            (!self.is_undefined() && !self.is_null()).then(|| self.wire2api())
        }
    }
    impl Wire2Api<Option<u64>> for JsValue {
        fn wire2api(self) -> Option<u64> {
            (!self.is_undefined() && !self.is_null()).then(|| self.wire2api())
        }
    }
    impl Wire2Api<Option<u8>> for JsValue {
        fn wire2api(self) -> Option<u8> {
            (!self.is_undefined() && !self.is_null()).then(|| self.wire2api())
        }
    }
    impl Wire2Api<Option<Vec<u8>>> for JsValue {
        fn wire2api(self) -> Option<Vec<u8>> {
            (!self.is_undefined() && !self.is_null()).then(|| self.wire2api())
        }
    }
    impl Wire2Api<u32> for JsValue {
        fn wire2api(self) -> u32 {
            self.unchecked_into_f64() as _
        }
    }
    impl Wire2Api<u64> for JsValue {
        fn wire2api(self) -> u64 {
            ::std::convert::TryInto::try_into(self.dyn_into::<js_sys::BigInt>().unwrap()).unwrap()
        }
    }
    impl Wire2Api<u8> for JsValue {
        fn wire2api(self) -> u8 {
            self.unchecked_into_f64() as _
        }
    }
    impl Wire2Api<Vec<u8>> for JsValue {
        fn wire2api(self) -> Vec<u8> {
            self.unchecked_into::<js_sys::Uint8Array>().to_vec().into()
        }
    }
    impl Wire2Api<WordCount> for JsValue {
        fn wire2api(self) -> WordCount {
            (self.unchecked_into_f64() as i32).wire2api()
        }
    }
}
#[cfg(target_family = "wasm")]
pub use web::*;

#[cfg(not(target_family = "wasm"))]
mod io {
    use super::*;
    // Section: wire functions

    #[no_mangle]
    pub extern "C" fn wire_mnemonic_phrase_to_seed(port_: i64, req: *mut wire_PhraseToSeedReq) {
        wire_mnemonic_phrase_to_seed_impl(port_, req)
    }

    #[no_mangle]
    pub extern "C" fn wire_mnemonic_seed_to_key(port_: i64, req: *mut wire_SeedToKeyReq) {
        wire_mnemonic_seed_to_key_impl(port_, req)
    }

    #[no_mangle]
    pub extern "C" fn wire_bls_init(port_: i64) {
        wire_bls_init_impl(port_)
    }

    #[no_mangle]
    pub extern "C" fn wire_bls_verify(port_: i64, req: *mut wire_BLSVerifyReq) {
        wire_bls_verify_impl(port_, req)
    }

    #[no_mangle]
    pub extern "C" fn wire_ed25519_from_seed(port_: i64, req: *mut wire_ED25519FromSeedReq) {
        wire_ed25519_from_seed_impl(port_, req)
    }

    #[no_mangle]
    pub extern "C" fn wire_ed25519_sign(port_: i64, req: *mut wire_ED25519SignReq) {
        wire_ed25519_sign_impl(port_, req)
    }

    #[no_mangle]
    pub extern "C" fn wire_ed25519_verify(port_: i64, req: *mut wire_ED25519VerifyReq) {
        wire_ed25519_verify_impl(port_, req)
    }

    #[no_mangle]
    pub extern "C" fn wire_secp256k1_from_seed(port_: i64, req: *mut wire_Secp256k1FromSeedReq) {
        wire_secp256k1_from_seed_impl(port_, req)
    }

    #[no_mangle]
    pub extern "C" fn wire_secp256k1_sign(port_: i64, req: *mut wire_Secp256k1SignWithSeedReq) {
        wire_secp256k1_sign_impl(port_, req)
    }

    #[no_mangle]
    pub extern "C" fn wire_secp256k1_sign_recoverable(
        port_: i64,
        req: *mut wire_Secp256k1SignWithSeedReq,
    ) {
        wire_secp256k1_sign_recoverable_impl(port_, req)
    }

    #[no_mangle]
    pub extern "C" fn wire_secp256k1_verify(port_: i64, req: *mut wire_Secp256k1VerifyReq) {
        wire_secp256k1_verify_impl(port_, req)
    }

    #[no_mangle]
    pub extern "C" fn wire_secp256k1_get_shared_secret(
        port_: i64,
        req: *mut wire_Secp256k1ShareSecretReq,
    ) {
        wire_secp256k1_get_shared_secret_impl(port_, req)
    }

    #[no_mangle]
    pub extern "C" fn wire_secp256k1_recover(port_: i64, req: *mut wire_Secp256k1RecoverReq) {
        wire_secp256k1_recover_impl(port_, req)
    }

    #[no_mangle]
    pub extern "C" fn wire_p256_from_seed(port_: i64, req: *mut wire_P256FromSeedReq) {
        wire_p256_from_seed_impl(port_, req)
    }

    #[no_mangle]
    pub extern "C" fn wire_p256_sign(port_: i64, req: *mut wire_P256SignWithSeedReq) {
        wire_p256_sign_impl(port_, req)
    }

    #[no_mangle]
    pub extern "C" fn wire_p256_verify(port_: i64, req: *mut wire_P256VerifyReq) {
        wire_p256_verify_impl(port_, req)
    }

    #[no_mangle]
    pub extern "C" fn wire_p256_get_shared_secret(port_: i64, req: *mut wire_P256ShareSecretReq) {
        wire_p256_get_shared_secret_impl(port_, req)
    }

    #[no_mangle]
    pub extern "C" fn wire_schnorr_from_seed(port_: i64, req: *mut wire_SchnorrFromSeedReq) {
        wire_schnorr_from_seed_impl(port_, req)
    }

    #[no_mangle]
    pub extern "C" fn wire_schnorr_sign(port_: i64, req: *mut wire_SchnorrSignWithSeedReq) {
        wire_schnorr_sign_impl(port_, req)
    }

    #[no_mangle]
    pub extern "C" fn wire_schnorr_verify(port_: i64, req: *mut wire_SchnorrVerifyReq) {
        wire_schnorr_verify_impl(port_, req)
    }

    #[no_mangle]
    pub extern "C" fn wire_aes_128_ctr_encrypt(port_: i64, req: *mut wire_AesEncryptReq) {
        wire_aes_128_ctr_encrypt_impl(port_, req)
    }

    #[no_mangle]
    pub extern "C" fn wire_aes_128_ctr_decrypt(port_: i64, req: *mut wire_AesDecryptReq) {
        wire_aes_128_ctr_decrypt_impl(port_, req)
    }

    #[no_mangle]
    pub extern "C" fn wire_aes_256_cbc_encrypt(port_: i64, req: *mut wire_AesEncryptReq) {
        wire_aes_256_cbc_encrypt_impl(port_, req)
    }

    #[no_mangle]
    pub extern "C" fn wire_aes_256_cbc_decrypt(port_: i64, req: *mut wire_AesDecryptReq) {
        wire_aes_256_cbc_decrypt_impl(port_, req)
    }

    #[no_mangle]
    pub extern "C" fn wire_aes_256_gcm_encrypt(port_: i64, req: *mut wire_AesEncryptReq) {
        wire_aes_256_gcm_encrypt_impl(port_, req)
    }

    #[no_mangle]
    pub extern "C" fn wire_aes_256_gcm_decrypt(port_: i64, req: *mut wire_AesDecryptReq) {
        wire_aes_256_gcm_decrypt_impl(port_, req)
    }

    #[no_mangle]
    pub extern "C" fn wire_pbkdf2_derive_key(port_: i64, req: *mut wire_PBKDFDeriveReq) {
        wire_pbkdf2_derive_key_impl(port_, req)
    }

    #[no_mangle]
    pub extern "C" fn wire_scrypt_derive_key(port_: i64, req: *mut wire_ScriptDeriveReq) {
        wire_scrypt_derive_key_impl(port_, req)
    }

    #[no_mangle]
    pub extern "C" fn wire_create_blockchain__static_method__Api(
        port_: i64,
        config: *mut wire_BlockchainConfig,
    ) {
        wire_create_blockchain__static_method__Api_impl(port_, config)
    }

    #[no_mangle]
    pub extern "C" fn wire_get_height__static_method__Api(
        port_: i64,
        blockchain: wire_BlockchainInstance,
    ) {
        wire_get_height__static_method__Api_impl(port_, blockchain)
    }

    #[no_mangle]
    pub extern "C" fn wire_get_blockchain_hash__static_method__Api(
        port_: i64,
        blockchain_height: u32,
        blockchain: wire_BlockchainInstance,
    ) {
        wire_get_blockchain_hash__static_method__Api_impl(port_, blockchain_height, blockchain)
    }

    #[no_mangle]
    pub extern "C" fn wire_estimate_fee__static_method__Api(
        port_: i64,
        target: u64,
        blockchain: wire_BlockchainInstance,
    ) {
        wire_estimate_fee__static_method__Api_impl(port_, target, blockchain)
    }

    #[no_mangle]
    pub extern "C" fn wire_broadcast__static_method__Api(
        port_: i64,
        tx: *mut wire_uint_8_list,
        blockchain: wire_BlockchainInstance,
    ) {
        wire_broadcast__static_method__Api_impl(port_, tx, blockchain)
    }

    #[no_mangle]
    pub extern "C" fn wire_create_transaction__static_method__Api(
        port_: i64,
        tx: *mut wire_uint_8_list,
    ) {
        wire_create_transaction__static_method__Api_impl(port_, tx)
    }

    #[no_mangle]
    pub extern "C" fn wire_tx_txid__static_method__Api(port_: i64, tx: *mut wire_uint_8_list) {
        wire_tx_txid__static_method__Api_impl(port_, tx)
    }

    #[no_mangle]
    pub extern "C" fn wire_weight__static_method__Api(port_: i64, tx: *mut wire_uint_8_list) {
        wire_weight__static_method__Api_impl(port_, tx)
    }

    #[no_mangle]
    pub extern "C" fn wire_size__static_method__Api(port_: i64, tx: *mut wire_uint_8_list) {
        wire_size__static_method__Api_impl(port_, tx)
    }

    #[no_mangle]
    pub extern "C" fn wire_vsize__static_method__Api(port_: i64, tx: *mut wire_uint_8_list) {
        wire_vsize__static_method__Api_impl(port_, tx)
    }

    #[no_mangle]
    pub extern "C" fn wire_serialize_tx__static_method__Api(port_: i64, tx: *mut wire_uint_8_list) {
        wire_serialize_tx__static_method__Api_impl(port_, tx)
    }

    #[no_mangle]
    pub extern "C" fn wire_is_coin_base__static_method__Api(port_: i64, tx: *mut wire_uint_8_list) {
        wire_is_coin_base__static_method__Api_impl(port_, tx)
    }

    #[no_mangle]
    pub extern "C" fn wire_is_explicitly_rbf__static_method__Api(
        port_: i64,
        tx: *mut wire_uint_8_list,
    ) {
        wire_is_explicitly_rbf__static_method__Api_impl(port_, tx)
    }

    #[no_mangle]
    pub extern "C" fn wire_is_lock_time_enabled__static_method__Api(
        port_: i64,
        tx: *mut wire_uint_8_list,
    ) {
        wire_is_lock_time_enabled__static_method__Api_impl(port_, tx)
    }

    #[no_mangle]
    pub extern "C" fn wire_version__static_method__Api(port_: i64, tx: *mut wire_uint_8_list) {
        wire_version__static_method__Api_impl(port_, tx)
    }

    #[no_mangle]
    pub extern "C" fn wire_lock_time__static_method__Api(port_: i64, tx: *mut wire_uint_8_list) {
        wire_lock_time__static_method__Api_impl(port_, tx)
    }

    #[no_mangle]
    pub extern "C" fn wire_input__static_method__Api(port_: i64, tx: *mut wire_uint_8_list) {
        wire_input__static_method__Api_impl(port_, tx)
    }

    #[no_mangle]
    pub extern "C" fn wire_output__static_method__Api(port_: i64, tx: *mut wire_uint_8_list) {
        wire_output__static_method__Api_impl(port_, tx)
    }

    #[no_mangle]
    pub extern "C" fn wire_serialize_psbt__static_method__Api(
        port_: i64,
        psbt_str: *mut wire_uint_8_list,
    ) {
        wire_serialize_psbt__static_method__Api_impl(port_, psbt_str)
    }

    #[no_mangle]
    pub extern "C" fn wire_psbt_txid__static_method__Api(
        port_: i64,
        psbt_str: *mut wire_uint_8_list,
    ) {
        wire_psbt_txid__static_method__Api_impl(port_, psbt_str)
    }

    #[no_mangle]
    pub extern "C" fn wire_extract_tx__static_method__Api(
        port_: i64,
        psbt_str: *mut wire_uint_8_list,
    ) {
        wire_extract_tx__static_method__Api_impl(port_, psbt_str)
    }

    #[no_mangle]
    pub extern "C" fn wire_psbt_fee_rate__static_method__Api(
        port_: i64,
        psbt_str: *mut wire_uint_8_list,
    ) {
        wire_psbt_fee_rate__static_method__Api_impl(port_, psbt_str)
    }

    #[no_mangle]
    pub extern "C" fn wire_psbt_fee_amount__static_method__Api(
        port_: i64,
        psbt_str: *mut wire_uint_8_list,
    ) {
        wire_psbt_fee_amount__static_method__Api_impl(port_, psbt_str)
    }

    #[no_mangle]
    pub extern "C" fn wire_combine_psbt__static_method__Api(
        port_: i64,
        psbt_str: *mut wire_uint_8_list,
        other: *mut wire_uint_8_list,
    ) {
        wire_combine_psbt__static_method__Api_impl(port_, psbt_str, other)
    }

    #[no_mangle]
    pub extern "C" fn wire_json_serialize__static_method__Api(
        port_: i64,
        psbt_str: *mut wire_uint_8_list,
    ) {
        wire_json_serialize__static_method__Api_impl(port_, psbt_str)
    }

    #[no_mangle]
    pub extern "C" fn wire_get_inputs__static_method__Api(
        port_: i64,
        psbt_str: *mut wire_uint_8_list,
    ) {
        wire_get_inputs__static_method__Api_impl(port_, psbt_str)
    }

    #[no_mangle]
    pub extern "C" fn wire_tx_builder_finish__static_method__Api(
        port_: i64,
        wallet: wire_WalletInstance,
        recipients: *mut wire_list_script_amount,
        utxos: *mut wire_list_out_point,
        unspendable: *mut wire_list_out_point,
        change_policy: i32,
        manually_selected_only: bool,
        fee_rate: *mut f32,
        fee_absolute: *mut u64,
        drain_wallet: bool,
        drain_to: *mut wire_Script,
        rbf: *mut wire_RbfValue,
        data: *mut wire_uint_8_list,
        shuffle_utxo: *mut bool,
    ) {
        wire_tx_builder_finish__static_method__Api_impl(
            port_,
            wallet,
            recipients,
            utxos,
            unspendable,
            change_policy,
            manually_selected_only,
            fee_rate,
            fee_absolute,
            drain_wallet,
            drain_to,
            rbf,
            data,
            shuffle_utxo,
        )
    }

    #[no_mangle]
    pub extern "C" fn wire_bump_fee_tx_builder_finish__static_method__Api(
        port_: i64,
        txid: *mut wire_uint_8_list,
        fee_rate: f32,
        allow_shrinking: *mut wire_uint_8_list,
        wallet: wire_WalletInstance,
        enable_rbf: bool,
        keep_change: bool,
        n_sequence: *mut u32,
    ) {
        wire_bump_fee_tx_builder_finish__static_method__Api_impl(
            port_,
            txid,
            fee_rate,
            allow_shrinking,
            wallet,
            enable_rbf,
            keep_change,
            n_sequence,
        )
    }

    #[no_mangle]
    pub extern "C" fn wire_create_descriptor__static_method__Api(
        port_: i64,
        descriptor: *mut wire_uint_8_list,
        network: i32,
    ) {
        wire_create_descriptor__static_method__Api_impl(port_, descriptor, network)
    }

    #[no_mangle]
    pub extern "C" fn wire_new_bip44_descriptor__static_method__Api(
        port_: i64,
        key_chain_kind: i32,
        secret_key: *mut wire_uint_8_list,
        network: i32,
    ) {
        wire_new_bip44_descriptor__static_method__Api_impl(
            port_,
            key_chain_kind,
            secret_key,
            network,
        )
    }

    #[no_mangle]
    pub extern "C" fn wire_new_bip44_public__static_method__Api(
        port_: i64,
        key_chain_kind: i32,
        public_key: *mut wire_uint_8_list,
        network: i32,
        fingerprint: *mut wire_uint_8_list,
    ) {
        wire_new_bip44_public__static_method__Api_impl(
            port_,
            key_chain_kind,
            public_key,
            network,
            fingerprint,
        )
    }

    #[no_mangle]
    pub extern "C" fn wire_new_bip49_descriptor__static_method__Api(
        port_: i64,
        key_chain_kind: i32,
        secret_key: *mut wire_uint_8_list,
        network: i32,
    ) {
        wire_new_bip49_descriptor__static_method__Api_impl(
            port_,
            key_chain_kind,
            secret_key,
            network,
        )
    }

    #[no_mangle]
    pub extern "C" fn wire_new_bip49_public__static_method__Api(
        port_: i64,
        key_chain_kind: i32,
        public_key: *mut wire_uint_8_list,
        network: i32,
        fingerprint: *mut wire_uint_8_list,
    ) {
        wire_new_bip49_public__static_method__Api_impl(
            port_,
            key_chain_kind,
            public_key,
            network,
            fingerprint,
        )
    }

    #[no_mangle]
    pub extern "C" fn wire_new_bip84_descriptor__static_method__Api(
        port_: i64,
        key_chain_kind: i32,
        secret_key: *mut wire_uint_8_list,
        network: i32,
    ) {
        wire_new_bip84_descriptor__static_method__Api_impl(
            port_,
            key_chain_kind,
            secret_key,
            network,
        )
    }

    #[no_mangle]
    pub extern "C" fn wire_new_bip84_public__static_method__Api(
        port_: i64,
        key_chain_kind: i32,
        public_key: *mut wire_uint_8_list,
        network: i32,
        fingerprint: *mut wire_uint_8_list,
    ) {
        wire_new_bip84_public__static_method__Api_impl(
            port_,
            key_chain_kind,
            public_key,
            network,
            fingerprint,
        )
    }

    #[no_mangle]
    pub extern "C" fn wire_new_bip86_descriptor__static_method__Api(
        port_: i64,
        key_chain_kind: i32,
        secret_key: *mut wire_uint_8_list,
        network: i32,
    ) {
        wire_new_bip86_descriptor__static_method__Api_impl(
            port_,
            key_chain_kind,
            secret_key,
            network,
        )
    }

    #[no_mangle]
    pub extern "C" fn wire_new_bip86_public__static_method__Api(
        port_: i64,
        key_chain_kind: i32,
        public_key: *mut wire_uint_8_list,
        network: i32,
        fingerprint: *mut wire_uint_8_list,
    ) {
        wire_new_bip86_public__static_method__Api_impl(
            port_,
            key_chain_kind,
            public_key,
            network,
            fingerprint,
        )
    }

    #[no_mangle]
    pub extern "C" fn wire_as_string_private__static_method__Api(
        port_: i64,
        descriptor: wire_BdkDescriptor,
    ) {
        wire_as_string_private__static_method__Api_impl(port_, descriptor)
    }

    #[no_mangle]
    pub extern "C" fn wire_as_string__static_method__Api(
        port_: i64,
        descriptor: wire_BdkDescriptor,
    ) {
        wire_as_string__static_method__Api_impl(port_, descriptor)
    }

    #[no_mangle]
    pub extern "C" fn wire_create_descriptor_secret__static_method__Api(
        port_: i64,
        network: i32,
        mnemonic: *mut wire_uint_8_list,
        password: *mut wire_uint_8_list,
    ) {
        wire_create_descriptor_secret__static_method__Api_impl(port_, network, mnemonic, password)
    }

    #[no_mangle]
    pub extern "C" fn wire_create_derived_descriptor_secret__static_method__Api(
        port_: i64,
        network: i32,
        mnemonic: *mut wire_uint_8_list,
        path: *mut wire_uint_8_list,
        password: *mut wire_uint_8_list,
    ) {
        wire_create_derived_descriptor_secret__static_method__Api_impl(
            port_, network, mnemonic, path, password,
        )
    }

    #[no_mangle]
    pub extern "C" fn wire_descriptor_secret_from_string__static_method__Api(
        port_: i64,
        secret: *mut wire_uint_8_list,
    ) {
        wire_descriptor_secret_from_string__static_method__Api_impl(port_, secret)
    }

    #[no_mangle]
    pub extern "C" fn wire_extend_descriptor_secret__static_method__Api(
        port_: i64,
        secret: *mut wire_uint_8_list,
        path: *mut wire_uint_8_list,
    ) {
        wire_extend_descriptor_secret__static_method__Api_impl(port_, secret, path)
    }

    #[no_mangle]
    pub extern "C" fn wire_derive_descriptor_secret__static_method__Api(
        port_: i64,
        secret: *mut wire_uint_8_list,
        path: *mut wire_uint_8_list,
    ) {
        wire_derive_descriptor_secret__static_method__Api_impl(port_, secret, path)
    }

    #[no_mangle]
    pub extern "C" fn wire_as_secret_bytes__static_method__Api(
        port_: i64,
        secret: *mut wire_uint_8_list,
    ) {
        wire_as_secret_bytes__static_method__Api_impl(port_, secret)
    }

    #[no_mangle]
    pub extern "C" fn wire_as_public__static_method__Api(
        port_: i64,
        secret: *mut wire_uint_8_list,
    ) {
        wire_as_public__static_method__Api_impl(port_, secret)
    }

    #[no_mangle]
    pub extern "C" fn wire_get_pub_from_secret_bytes__static_method__Api(
        port_: i64,
        bytes: *mut wire_uint_8_list,
    ) {
        wire_get_pub_from_secret_bytes__static_method__Api_impl(port_, bytes)
    }

    #[no_mangle]
    pub extern "C" fn wire_create_derivation_path__static_method__Api(
        port_: i64,
        path: *mut wire_uint_8_list,
    ) {
        wire_create_derivation_path__static_method__Api_impl(port_, path)
    }

    #[no_mangle]
    pub extern "C" fn wire_descriptor_public_from_string__static_method__Api(
        port_: i64,
        public_key: *mut wire_uint_8_list,
    ) {
        wire_descriptor_public_from_string__static_method__Api_impl(port_, public_key)
    }

    #[no_mangle]
    pub extern "C" fn wire_master_finterprint__static_method__Api(
        port_: i64,
        xpub: *mut wire_uint_8_list,
    ) {
        wire_master_finterprint__static_method__Api_impl(port_, xpub)
    }

    #[no_mangle]
    pub extern "C" fn wire_create_descriptor_public__static_method__Api(
        port_: i64,
        xpub: *mut wire_uint_8_list,
        path: *mut wire_uint_8_list,
        derive: bool,
    ) {
        wire_create_descriptor_public__static_method__Api_impl(port_, xpub, path, derive)
    }

    #[no_mangle]
    pub extern "C" fn wire_to_public_string__static_method__Api(
        port_: i64,
        xpub: *mut wire_uint_8_list,
    ) {
        wire_to_public_string__static_method__Api_impl(port_, xpub)
    }

    #[no_mangle]
    pub extern "C" fn wire_create_script__static_method__Api(
        port_: i64,
        raw_output_script: *mut wire_uint_8_list,
    ) {
        wire_create_script__static_method__Api_impl(port_, raw_output_script)
    }

    #[no_mangle]
    pub extern "C" fn wire_create_address__static_method__Api(
        port_: i64,
        address: *mut wire_uint_8_list,
    ) {
        wire_create_address__static_method__Api_impl(port_, address)
    }

    #[no_mangle]
    pub extern "C" fn wire_address_from_script__static_method__Api(
        port_: i64,
        script: *mut wire_Script,
        network: i32,
    ) {
        wire_address_from_script__static_method__Api_impl(port_, script, network)
    }

    #[no_mangle]
    pub extern "C" fn wire_address_to_script_pubkey__static_method__Api(
        port_: i64,
        address: *mut wire_uint_8_list,
    ) {
        wire_address_to_script_pubkey__static_method__Api_impl(port_, address)
    }

    #[no_mangle]
    pub extern "C" fn wire_payload__static_method__Api(port_: i64, address: *mut wire_uint_8_list) {
        wire_payload__static_method__Api_impl(port_, address)
    }

    #[no_mangle]
    pub extern "C" fn wire_address_network__static_method__Api(
        port_: i64,
        address: *mut wire_uint_8_list,
    ) {
        wire_address_network__static_method__Api_impl(port_, address)
    }

    #[no_mangle]
    pub extern "C" fn wire_create_wallet__static_method__Api(
        port_: i64,
        descriptor: wire_BdkDescriptor,
        change_descriptor: *mut wire_BdkDescriptor,
        network: i32,
        database_config: *mut wire_DatabaseConfig,
    ) {
        wire_create_wallet__static_method__Api_impl(
            port_,
            descriptor,
            change_descriptor,
            network,
            database_config,
        )
    }

    #[no_mangle]
    pub extern "C" fn wire_get_address__static_method__Api(
        port_: i64,
        wallet: wire_WalletInstance,
        address_index: *mut wire_AddressIndex,
    ) {
        wire_get_address__static_method__Api_impl(port_, wallet, address_index)
    }

    #[no_mangle]
    pub extern "C" fn wire_get_internal_address__static_method__Api(
        port_: i64,
        wallet: wire_WalletInstance,
        address_index: *mut wire_AddressIndex,
    ) {
        wire_get_internal_address__static_method__Api_impl(port_, wallet, address_index)
    }

    #[no_mangle]
    pub extern "C" fn wire_sync_wallet__static_method__Api(
        port_: i64,
        wallet: wire_WalletInstance,
        blockchain: wire_BlockchainInstance,
    ) {
        wire_sync_wallet__static_method__Api_impl(port_, wallet, blockchain)
    }

    #[no_mangle]
    pub extern "C" fn wire_sync_wallet_thread__static_method__Api(
        port_: i64,
        wallet: wire_WalletInstance,
        blockchain: wire_BlockchainInstance,
    ) {
        wire_sync_wallet_thread__static_method__Api_impl(port_, wallet, blockchain)
    }

    #[no_mangle]
    pub extern "C" fn wire_get_balance__static_method__Api(
        port_: i64,
        wallet: wire_WalletInstance,
    ) {
        wire_get_balance__static_method__Api_impl(port_, wallet)
    }

    #[no_mangle]
    pub extern "C" fn wire_list_unspent_outputs__static_method__Api(
        port_: i64,
        wallet: wire_WalletInstance,
    ) {
        wire_list_unspent_outputs__static_method__Api_impl(port_, wallet)
    }

    #[no_mangle]
    pub extern "C" fn wire_get_transactions__static_method__Api(
        port_: i64,
        wallet: wire_WalletInstance,
        include_raw: bool,
    ) {
        wire_get_transactions__static_method__Api_impl(port_, wallet, include_raw)
    }

    #[no_mangle]
    pub extern "C" fn wire_sign__static_method__Api(
        port_: i64,
        wallet: wire_WalletInstance,
        psbt_str: *mut wire_uint_8_list,
        sign_options: *mut wire_SignOptions,
    ) {
        wire_sign__static_method__Api_impl(port_, wallet, psbt_str, sign_options)
    }

    #[no_mangle]
    pub extern "C" fn wire_wallet_network__static_method__Api(
        port_: i64,
        wallet: wire_WalletInstance,
    ) {
        wire_wallet_network__static_method__Api_impl(port_, wallet)
    }

    #[no_mangle]
    pub extern "C" fn wire_list_unspent__static_method__Api(
        port_: i64,
        wallet: wire_WalletInstance,
    ) {
        wire_list_unspent__static_method__Api_impl(port_, wallet)
    }

    #[no_mangle]
    pub extern "C" fn wire_generate_seed_from_word_count__static_method__Api(
        port_: i64,
        word_count: i32,
    ) {
        wire_generate_seed_from_word_count__static_method__Api_impl(port_, word_count)
    }

    #[no_mangle]
    pub extern "C" fn wire_generate_seed_from_string__static_method__Api(
        port_: i64,
        mnemonic: *mut wire_uint_8_list,
    ) {
        wire_generate_seed_from_string__static_method__Api_impl(port_, mnemonic)
    }

    #[no_mangle]
    pub extern "C" fn wire_generate_seed_from_entropy__static_method__Api(
        port_: i64,
        entropy: *mut wire_uint_8_list,
    ) {
        wire_generate_seed_from_entropy__static_method__Api_impl(port_, entropy)
    }

    // Section: allocate functions

    #[no_mangle]
    pub extern "C" fn new_BdkDescriptor() -> wire_BdkDescriptor {
        wire_BdkDescriptor::new_with_null_ptr()
    }

    #[no_mangle]
    pub extern "C" fn new_BlockchainInstance() -> wire_BlockchainInstance {
        wire_BlockchainInstance::new_with_null_ptr()
    }

    #[no_mangle]
    pub extern "C" fn new_WalletInstance() -> wire_WalletInstance {
        wire_WalletInstance::new_with_null_ptr()
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_BdkDescriptor_0() -> *mut wire_BdkDescriptor {
        support::new_leak_box_ptr(wire_BdkDescriptor::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_address_index_0() -> *mut wire_AddressIndex {
        support::new_leak_box_ptr(wire_AddressIndex::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_aes_decrypt_req_0() -> *mut wire_AesDecryptReq {
        support::new_leak_box_ptr(wire_AesDecryptReq::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_aes_encrypt_req_0() -> *mut wire_AesEncryptReq {
        support::new_leak_box_ptr(wire_AesEncryptReq::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_blockchain_config_0() -> *mut wire_BlockchainConfig {
        support::new_leak_box_ptr(wire_BlockchainConfig::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_bls_verify_req_0() -> *mut wire_BLSVerifyReq {
        support::new_leak_box_ptr(wire_BLSVerifyReq::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_bool_0(value: bool) -> *mut bool {
        support::new_leak_box_ptr(value)
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_database_config_0() -> *mut wire_DatabaseConfig {
        support::new_leak_box_ptr(wire_DatabaseConfig::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_ed_25519_from_seed_req_0() -> *mut wire_ED25519FromSeedReq {
        support::new_leak_box_ptr(wire_ED25519FromSeedReq::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_ed_25519_sign_req_0() -> *mut wire_ED25519SignReq {
        support::new_leak_box_ptr(wire_ED25519SignReq::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_ed_25519_verify_req_0() -> *mut wire_ED25519VerifyReq {
        support::new_leak_box_ptr(wire_ED25519VerifyReq::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_electrum_config_0() -> *mut wire_ElectrumConfig {
        support::new_leak_box_ptr(wire_ElectrumConfig::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_esplora_config_0() -> *mut wire_EsploraConfig {
        support::new_leak_box_ptr(wire_EsploraConfig::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_f32_0(value: f32) -> *mut f32 {
        support::new_leak_box_ptr(value)
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_p_256_from_seed_req_0() -> *mut wire_P256FromSeedReq {
        support::new_leak_box_ptr(wire_P256FromSeedReq::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_p_256_share_secret_req_0() -> *mut wire_P256ShareSecretReq {
        support::new_leak_box_ptr(wire_P256ShareSecretReq::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_p_256_sign_with_seed_req_0() -> *mut wire_P256SignWithSeedReq
    {
        support::new_leak_box_ptr(wire_P256SignWithSeedReq::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_p_256_verify_req_0() -> *mut wire_P256VerifyReq {
        support::new_leak_box_ptr(wire_P256VerifyReq::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_pbkdf_derive_req_0() -> *mut wire_PBKDFDeriveReq {
        support::new_leak_box_ptr(wire_PBKDFDeriveReq::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_phrase_to_seed_req_0() -> *mut wire_PhraseToSeedReq {
        support::new_leak_box_ptr(wire_PhraseToSeedReq::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_rbf_value_0() -> *mut wire_RbfValue {
        support::new_leak_box_ptr(wire_RbfValue::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_rpc_config_0() -> *mut wire_RpcConfig {
        support::new_leak_box_ptr(wire_RpcConfig::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_rpc_sync_params_0() -> *mut wire_RpcSyncParams {
        support::new_leak_box_ptr(wire_RpcSyncParams::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_schnorr_from_seed_req_0() -> *mut wire_SchnorrFromSeedReq {
        support::new_leak_box_ptr(wire_SchnorrFromSeedReq::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_schnorr_sign_with_seed_req_0(
    ) -> *mut wire_SchnorrSignWithSeedReq {
        support::new_leak_box_ptr(wire_SchnorrSignWithSeedReq::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_schnorr_verify_req_0() -> *mut wire_SchnorrVerifyReq {
        support::new_leak_box_ptr(wire_SchnorrVerifyReq::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_script_0() -> *mut wire_Script {
        support::new_leak_box_ptr(wire_Script::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_script_derive_req_0() -> *mut wire_ScriptDeriveReq {
        support::new_leak_box_ptr(wire_ScriptDeriveReq::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_secp_256_k_1_from_seed_req_0(
    ) -> *mut wire_Secp256k1FromSeedReq {
        support::new_leak_box_ptr(wire_Secp256k1FromSeedReq::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_secp_256_k_1_recover_req_0() -> *mut wire_Secp256k1RecoverReq
    {
        support::new_leak_box_ptr(wire_Secp256k1RecoverReq::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_secp_256_k_1_share_secret_req_0(
    ) -> *mut wire_Secp256k1ShareSecretReq {
        support::new_leak_box_ptr(wire_Secp256k1ShareSecretReq::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_secp_256_k_1_sign_with_seed_req_0(
    ) -> *mut wire_Secp256k1SignWithSeedReq {
        support::new_leak_box_ptr(wire_Secp256k1SignWithSeedReq::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_secp_256_k_1_verify_req_0() -> *mut wire_Secp256k1VerifyReq {
        support::new_leak_box_ptr(wire_Secp256k1VerifyReq::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_seed_to_key_req_0() -> *mut wire_SeedToKeyReq {
        support::new_leak_box_ptr(wire_SeedToKeyReq::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_sign_options_0() -> *mut wire_SignOptions {
        support::new_leak_box_ptr(wire_SignOptions::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_sled_db_configuration_0() -> *mut wire_SledDbConfiguration {
        support::new_leak_box_ptr(wire_SledDbConfiguration::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_sqlite_db_configuration_0() -> *mut wire_SqliteDbConfiguration
    {
        support::new_leak_box_ptr(wire_SqliteDbConfiguration::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_u32_0(value: u32) -> *mut u32 {
        support::new_leak_box_ptr(value)
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_u64_0(value: u64) -> *mut u64 {
        support::new_leak_box_ptr(value)
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_u8_0(value: u8) -> *mut u8 {
        support::new_leak_box_ptr(value)
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_user_pass_0() -> *mut wire_UserPass {
        support::new_leak_box_ptr(wire_UserPass::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn new_list_out_point_0(len: i32) -> *mut wire_list_out_point {
        let wrap = wire_list_out_point {
            ptr: support::new_leak_vec_ptr(<wire_OutPoint>::new_with_null_ptr(), len),
            len,
        };
        support::new_leak_box_ptr(wrap)
    }

    #[no_mangle]
    pub extern "C" fn new_list_script_amount_0(len: i32) -> *mut wire_list_script_amount {
        let wrap = wire_list_script_amount {
            ptr: support::new_leak_vec_ptr(<wire_ScriptAmount>::new_with_null_ptr(), len),
            len,
        };
        support::new_leak_box_ptr(wrap)
    }

    #[no_mangle]
    pub extern "C" fn new_uint_8_list_0(len: i32) -> *mut wire_uint_8_list {
        let ans = wire_uint_8_list {
            ptr: support::new_leak_vec_ptr(Default::default(), len),
            len,
        };
        support::new_leak_box_ptr(ans)
    }

    // Section: related functions

    #[no_mangle]
    pub extern "C" fn drop_opaque_BdkDescriptor(ptr: *const c_void) {
        unsafe {
            Arc::<BdkDescriptor>::decrement_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn share_opaque_BdkDescriptor(ptr: *const c_void) -> *const c_void {
        unsafe {
            Arc::<BdkDescriptor>::increment_strong_count(ptr as _);
            ptr
        }
    }

    #[no_mangle]
    pub extern "C" fn drop_opaque_BlockchainInstance(ptr: *const c_void) {
        unsafe {
            Arc::<BlockchainInstance>::decrement_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn share_opaque_BlockchainInstance(ptr: *const c_void) -> *const c_void {
        unsafe {
            Arc::<BlockchainInstance>::increment_strong_count(ptr as _);
            ptr
        }
    }

    #[no_mangle]
    pub extern "C" fn drop_opaque_WalletInstance(ptr: *const c_void) {
        unsafe {
            Arc::<WalletInstance>::decrement_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn share_opaque_WalletInstance(ptr: *const c_void) -> *const c_void {
        unsafe {
            Arc::<WalletInstance>::increment_strong_count(ptr as _);
            ptr
        }
    }

    // Section: impl Wire2Api

    impl Wire2Api<RustOpaque<BdkDescriptor>> for wire_BdkDescriptor {
        fn wire2api(self) -> RustOpaque<BdkDescriptor> {
            unsafe { support::opaque_from_dart(self.ptr as _) }
        }
    }
    impl Wire2Api<RustOpaque<BlockchainInstance>> for wire_BlockchainInstance {
        fn wire2api(self) -> RustOpaque<BlockchainInstance> {
            unsafe { support::opaque_from_dart(self.ptr as _) }
        }
    }
    impl Wire2Api<String> for *mut wire_uint_8_list {
        fn wire2api(self) -> String {
            let vec: Vec<u8> = self.wire2api();
            String::from_utf8_lossy(&vec).into_owned()
        }
    }
    impl Wire2Api<RustOpaque<WalletInstance>> for wire_WalletInstance {
        fn wire2api(self) -> RustOpaque<WalletInstance> {
            unsafe { support::opaque_from_dart(self.ptr as _) }
        }
    }
    impl Wire2Api<AddressIndex> for wire_AddressIndex {
        fn wire2api(self) -> AddressIndex {
            match self.tag {
                0 => AddressIndex::New,
                1 => AddressIndex::LastUnused,
                2 => unsafe {
                    let ans = support::box_from_leak_ptr(self.kind);
                    let ans = support::box_from_leak_ptr(ans.Peek);
                    AddressIndex::Peek {
                        index: ans.index.wire2api(),
                    }
                },
                3 => unsafe {
                    let ans = support::box_from_leak_ptr(self.kind);
                    let ans = support::box_from_leak_ptr(ans.Reset);
                    AddressIndex::Reset {
                        index: ans.index.wire2api(),
                    }
                },
                _ => unreachable!(),
            }
        }
    }
    impl Wire2Api<AesDecryptReq> for wire_AesDecryptReq {
        fn wire2api(self) -> AesDecryptReq {
            AesDecryptReq {
                key: self.key.wire2api(),
                iv: self.iv.wire2api(),
                cipher_text: self.cipher_text.wire2api(),
            }
        }
    }
    impl Wire2Api<AesEncryptReq> for wire_AesEncryptReq {
        fn wire2api(self) -> AesEncryptReq {
            AesEncryptReq {
                key: self.key.wire2api(),
                iv: self.iv.wire2api(),
                message: self.message.wire2api(),
            }
        }
    }
    impl Wire2Api<BlockchainConfig> for wire_BlockchainConfig {
        fn wire2api(self) -> BlockchainConfig {
            match self.tag {
                0 => unsafe {
                    let ans = support::box_from_leak_ptr(self.kind);
                    let ans = support::box_from_leak_ptr(ans.Electrum);
                    BlockchainConfig::Electrum {
                        config: ans.config.wire2api(),
                    }
                },
                1 => unsafe {
                    let ans = support::box_from_leak_ptr(self.kind);
                    let ans = support::box_from_leak_ptr(ans.Esplora);
                    BlockchainConfig::Esplora {
                        config: ans.config.wire2api(),
                    }
                },
                2 => unsafe {
                    let ans = support::box_from_leak_ptr(self.kind);
                    let ans = support::box_from_leak_ptr(ans.Rpc);
                    BlockchainConfig::Rpc {
                        config: ans.config.wire2api(),
                    }
                },
                _ => unreachable!(),
            }
        }
    }
    impl Wire2Api<BLSVerifyReq> for wire_BLSVerifyReq {
        fn wire2api(self) -> BLSVerifyReq {
            BLSVerifyReq {
                signature: self.signature.wire2api(),
                message: self.message.wire2api(),
                public_key: self.public_key.wire2api(),
            }
        }
    }

    impl Wire2Api<RustOpaque<BdkDescriptor>> for *mut wire_BdkDescriptor {
        fn wire2api(self) -> RustOpaque<BdkDescriptor> {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<RustOpaque<BdkDescriptor>>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<AddressIndex> for *mut wire_AddressIndex {
        fn wire2api(self) -> AddressIndex {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<AddressIndex>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<AesDecryptReq> for *mut wire_AesDecryptReq {
        fn wire2api(self) -> AesDecryptReq {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<AesDecryptReq>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<AesEncryptReq> for *mut wire_AesEncryptReq {
        fn wire2api(self) -> AesEncryptReq {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<AesEncryptReq>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<BlockchainConfig> for *mut wire_BlockchainConfig {
        fn wire2api(self) -> BlockchainConfig {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<BlockchainConfig>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<BLSVerifyReq> for *mut wire_BLSVerifyReq {
        fn wire2api(self) -> BLSVerifyReq {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<BLSVerifyReq>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<bool> for *mut bool {
        fn wire2api(self) -> bool {
            unsafe { *support::box_from_leak_ptr(self) }
        }
    }
    impl Wire2Api<DatabaseConfig> for *mut wire_DatabaseConfig {
        fn wire2api(self) -> DatabaseConfig {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<DatabaseConfig>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<ED25519FromSeedReq> for *mut wire_ED25519FromSeedReq {
        fn wire2api(self) -> ED25519FromSeedReq {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<ED25519FromSeedReq>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<ED25519SignReq> for *mut wire_ED25519SignReq {
        fn wire2api(self) -> ED25519SignReq {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<ED25519SignReq>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<ED25519VerifyReq> for *mut wire_ED25519VerifyReq {
        fn wire2api(self) -> ED25519VerifyReq {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<ED25519VerifyReq>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<ElectrumConfig> for *mut wire_ElectrumConfig {
        fn wire2api(self) -> ElectrumConfig {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<ElectrumConfig>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<EsploraConfig> for *mut wire_EsploraConfig {
        fn wire2api(self) -> EsploraConfig {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<EsploraConfig>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<f32> for *mut f32 {
        fn wire2api(self) -> f32 {
            unsafe { *support::box_from_leak_ptr(self) }
        }
    }
    impl Wire2Api<P256FromSeedReq> for *mut wire_P256FromSeedReq {
        fn wire2api(self) -> P256FromSeedReq {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<P256FromSeedReq>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<P256ShareSecretReq> for *mut wire_P256ShareSecretReq {
        fn wire2api(self) -> P256ShareSecretReq {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<P256ShareSecretReq>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<P256SignWithSeedReq> for *mut wire_P256SignWithSeedReq {
        fn wire2api(self) -> P256SignWithSeedReq {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<P256SignWithSeedReq>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<P256VerifyReq> for *mut wire_P256VerifyReq {
        fn wire2api(self) -> P256VerifyReq {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<P256VerifyReq>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<PBKDFDeriveReq> for *mut wire_PBKDFDeriveReq {
        fn wire2api(self) -> PBKDFDeriveReq {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<PBKDFDeriveReq>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<PhraseToSeedReq> for *mut wire_PhraseToSeedReq {
        fn wire2api(self) -> PhraseToSeedReq {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<PhraseToSeedReq>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<RbfValue> for *mut wire_RbfValue {
        fn wire2api(self) -> RbfValue {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<RbfValue>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<RpcConfig> for *mut wire_RpcConfig {
        fn wire2api(self) -> RpcConfig {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<RpcConfig>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<RpcSyncParams> for *mut wire_RpcSyncParams {
        fn wire2api(self) -> RpcSyncParams {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<RpcSyncParams>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<SchnorrFromSeedReq> for *mut wire_SchnorrFromSeedReq {
        fn wire2api(self) -> SchnorrFromSeedReq {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<SchnorrFromSeedReq>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<SchnorrSignWithSeedReq> for *mut wire_SchnorrSignWithSeedReq {
        fn wire2api(self) -> SchnorrSignWithSeedReq {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<SchnorrSignWithSeedReq>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<SchnorrVerifyReq> for *mut wire_SchnorrVerifyReq {
        fn wire2api(self) -> SchnorrVerifyReq {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<SchnorrVerifyReq>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<Script> for *mut wire_Script {
        fn wire2api(self) -> Script {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<Script>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<ScriptDeriveReq> for *mut wire_ScriptDeriveReq {
        fn wire2api(self) -> ScriptDeriveReq {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<ScriptDeriveReq>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<Secp256k1FromSeedReq> for *mut wire_Secp256k1FromSeedReq {
        fn wire2api(self) -> Secp256k1FromSeedReq {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<Secp256k1FromSeedReq>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<Secp256k1RecoverReq> for *mut wire_Secp256k1RecoverReq {
        fn wire2api(self) -> Secp256k1RecoverReq {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<Secp256k1RecoverReq>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<Secp256k1ShareSecretReq> for *mut wire_Secp256k1ShareSecretReq {
        fn wire2api(self) -> Secp256k1ShareSecretReq {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<Secp256k1ShareSecretReq>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<Secp256k1SignWithSeedReq> for *mut wire_Secp256k1SignWithSeedReq {
        fn wire2api(self) -> Secp256k1SignWithSeedReq {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<Secp256k1SignWithSeedReq>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<Secp256k1VerifyReq> for *mut wire_Secp256k1VerifyReq {
        fn wire2api(self) -> Secp256k1VerifyReq {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<Secp256k1VerifyReq>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<SeedToKeyReq> for *mut wire_SeedToKeyReq {
        fn wire2api(self) -> SeedToKeyReq {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<SeedToKeyReq>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<SignOptions> for *mut wire_SignOptions {
        fn wire2api(self) -> SignOptions {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<SignOptions>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<SledDbConfiguration> for *mut wire_SledDbConfiguration {
        fn wire2api(self) -> SledDbConfiguration {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<SledDbConfiguration>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<SqliteDbConfiguration> for *mut wire_SqliteDbConfiguration {
        fn wire2api(self) -> SqliteDbConfiguration {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<SqliteDbConfiguration>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<u32> for *mut u32 {
        fn wire2api(self) -> u32 {
            unsafe { *support::box_from_leak_ptr(self) }
        }
    }
    impl Wire2Api<u64> for *mut u64 {
        fn wire2api(self) -> u64 {
            unsafe { *support::box_from_leak_ptr(self) }
        }
    }
    impl Wire2Api<u8> for *mut u8 {
        fn wire2api(self) -> u8 {
            unsafe { *support::box_from_leak_ptr(self) }
        }
    }
    impl Wire2Api<UserPass> for *mut wire_UserPass {
        fn wire2api(self) -> UserPass {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<UserPass>::wire2api(*wrap).into()
        }
    }

    impl Wire2Api<DatabaseConfig> for wire_DatabaseConfig {
        fn wire2api(self) -> DatabaseConfig {
            match self.tag {
                0 => DatabaseConfig::Memory,
                1 => unsafe {
                    let ans = support::box_from_leak_ptr(self.kind);
                    let ans = support::box_from_leak_ptr(ans.Sqlite);
                    DatabaseConfig::Sqlite {
                        config: ans.config.wire2api(),
                    }
                },
                2 => unsafe {
                    let ans = support::box_from_leak_ptr(self.kind);
                    let ans = support::box_from_leak_ptr(ans.Sled);
                    DatabaseConfig::Sled {
                        config: ans.config.wire2api(),
                    }
                },
                _ => unreachable!(),
            }
        }
    }
    impl Wire2Api<ED25519FromSeedReq> for wire_ED25519FromSeedReq {
        fn wire2api(self) -> ED25519FromSeedReq {
            ED25519FromSeedReq {
                seed: self.seed.wire2api(),
            }
        }
    }
    impl Wire2Api<ED25519SignReq> for wire_ED25519SignReq {
        fn wire2api(self) -> ED25519SignReq {
            ED25519SignReq {
                seed: self.seed.wire2api(),
                message: self.message.wire2api(),
            }
        }
    }
    impl Wire2Api<ED25519VerifyReq> for wire_ED25519VerifyReq {
        fn wire2api(self) -> ED25519VerifyReq {
            ED25519VerifyReq {
                sig: self.sig.wire2api(),
                message: self.message.wire2api(),
                pub_key: self.pub_key.wire2api(),
            }
        }
    }
    impl Wire2Api<ElectrumConfig> for wire_ElectrumConfig {
        fn wire2api(self) -> ElectrumConfig {
            ElectrumConfig {
                url: self.url.wire2api(),
                socks5: self.socks5.wire2api(),
                retry: self.retry.wire2api(),
                timeout: self.timeout.wire2api(),
                stop_gap: self.stop_gap.wire2api(),
                validate_domain: self.validate_domain.wire2api(),
            }
        }
    }
    impl Wire2Api<EsploraConfig> for wire_EsploraConfig {
        fn wire2api(self) -> EsploraConfig {
            EsploraConfig {
                base_url: self.base_url.wire2api(),
                proxy: self.proxy.wire2api(),
                concurrency: self.concurrency.wire2api(),
                stop_gap: self.stop_gap.wire2api(),
                timeout: self.timeout.wire2api(),
            }
        }
    }

    impl Wire2Api<Vec<OutPoint>> for *mut wire_list_out_point {
        fn wire2api(self) -> Vec<OutPoint> {
            let vec = unsafe {
                let wrap = support::box_from_leak_ptr(self);
                support::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(Wire2Api::wire2api).collect()
        }
    }
    impl Wire2Api<Vec<ScriptAmount>> for *mut wire_list_script_amount {
        fn wire2api(self) -> Vec<ScriptAmount> {
            let vec = unsafe {
                let wrap = support::box_from_leak_ptr(self);
                support::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(Wire2Api::wire2api).collect()
        }
    }

    impl Wire2Api<OutPoint> for wire_OutPoint {
        fn wire2api(self) -> OutPoint {
            OutPoint {
                txid: self.txid.wire2api(),
                vout: self.vout.wire2api(),
            }
        }
    }
    impl Wire2Api<P256FromSeedReq> for wire_P256FromSeedReq {
        fn wire2api(self) -> P256FromSeedReq {
            P256FromSeedReq {
                seed: self.seed.wire2api(),
            }
        }
    }
    impl Wire2Api<P256ShareSecretReq> for wire_P256ShareSecretReq {
        fn wire2api(self) -> P256ShareSecretReq {
            P256ShareSecretReq {
                seed: self.seed.wire2api(),
                public_key_raw_bytes: self.public_key_raw_bytes.wire2api(),
            }
        }
    }
    impl Wire2Api<P256SignWithSeedReq> for wire_P256SignWithSeedReq {
        fn wire2api(self) -> P256SignWithSeedReq {
            P256SignWithSeedReq {
                msg: self.msg.wire2api(),
                seed: self.seed.wire2api(),
            }
        }
    }
    impl Wire2Api<P256VerifyReq> for wire_P256VerifyReq {
        fn wire2api(self) -> P256VerifyReq {
            P256VerifyReq {
                message_hash: self.message_hash.wire2api(),
                signature_bytes: self.signature_bytes.wire2api(),
                public_key_bytes: self.public_key_bytes.wire2api(),
            }
        }
    }
    impl Wire2Api<PBKDFDeriveReq> for wire_PBKDFDeriveReq {
        fn wire2api(self) -> PBKDFDeriveReq {
            PBKDFDeriveReq {
                password: self.password.wire2api(),
                salt: self.salt.wire2api(),
                c: self.c.wire2api(),
            }
        }
    }
    impl Wire2Api<PhraseToSeedReq> for wire_PhraseToSeedReq {
        fn wire2api(self) -> PhraseToSeedReq {
            PhraseToSeedReq {
                phrase: self.phrase.wire2api(),
                password: self.password.wire2api(),
            }
        }
    }
    impl Wire2Api<RbfValue> for wire_RbfValue {
        fn wire2api(self) -> RbfValue {
            match self.tag {
                0 => RbfValue::RbfDefault,
                1 => unsafe {
                    let ans = support::box_from_leak_ptr(self.kind);
                    let ans = support::box_from_leak_ptr(ans.Value);
                    RbfValue::Value(ans.field0.wire2api())
                },
                _ => unreachable!(),
            }
        }
    }
    impl Wire2Api<RpcConfig> for wire_RpcConfig {
        fn wire2api(self) -> RpcConfig {
            RpcConfig {
                url: self.url.wire2api(),
                auth_cookie: self.auth_cookie.wire2api(),
                auth_user_pass: self.auth_user_pass.wire2api(),
                network: self.network.wire2api(),
                wallet_name: self.wallet_name.wire2api(),
                sync_params: self.sync_params.wire2api(),
            }
        }
    }
    impl Wire2Api<RpcSyncParams> for wire_RpcSyncParams {
        fn wire2api(self) -> RpcSyncParams {
            RpcSyncParams {
                start_script_count: self.start_script_count.wire2api(),
                start_time: self.start_time.wire2api(),
                force_start_time: self.force_start_time.wire2api(),
                poll_rate_sec: self.poll_rate_sec.wire2api(),
            }
        }
    }
    impl Wire2Api<SchnorrFromSeedReq> for wire_SchnorrFromSeedReq {
        fn wire2api(self) -> SchnorrFromSeedReq {
            SchnorrFromSeedReq {
                seed: self.seed.wire2api(),
            }
        }
    }
    impl Wire2Api<SchnorrSignWithSeedReq> for wire_SchnorrSignWithSeedReq {
        fn wire2api(self) -> SchnorrSignWithSeedReq {
            SchnorrSignWithSeedReq {
                msg: self.msg.wire2api(),
                seed: self.seed.wire2api(),
                aux_rand: self.aux_rand.wire2api(),
            }
        }
    }
    impl Wire2Api<SchnorrVerifyReq> for wire_SchnorrVerifyReq {
        fn wire2api(self) -> SchnorrVerifyReq {
            SchnorrVerifyReq {
                message_hash: self.message_hash.wire2api(),
                signature_bytes: self.signature_bytes.wire2api(),
                public_key_bytes: self.public_key_bytes.wire2api(),
            }
        }
    }
    impl Wire2Api<Script> for wire_Script {
        fn wire2api(self) -> Script {
            Script {
                internal: self.internal.wire2api(),
            }
        }
    }
    impl Wire2Api<ScriptAmount> for wire_ScriptAmount {
        fn wire2api(self) -> ScriptAmount {
            ScriptAmount {
                script: self.script.wire2api(),
                amount: self.amount.wire2api(),
            }
        }
    }
    impl Wire2Api<ScriptDeriveReq> for wire_ScriptDeriveReq {
        fn wire2api(self) -> ScriptDeriveReq {
            ScriptDeriveReq {
                password: self.password.wire2api(),
                salt: self.salt.wire2api(),
                n: self.n.wire2api(),
                p: self.p.wire2api(),
                r: self.r.wire2api(),
            }
        }
    }
    impl Wire2Api<Secp256k1FromSeedReq> for wire_Secp256k1FromSeedReq {
        fn wire2api(self) -> Secp256k1FromSeedReq {
            Secp256k1FromSeedReq {
                seed: self.seed.wire2api(),
            }
        }
    }
    impl Wire2Api<Secp256k1RecoverReq> for wire_Secp256k1RecoverReq {
        fn wire2api(self) -> Secp256k1RecoverReq {
            Secp256k1RecoverReq {
                message_pre_hashed: self.message_pre_hashed.wire2api(),
                signature_bytes: self.signature_bytes.wire2api(),
                chain_id: self.chain_id.wire2api(),
            }
        }
    }
    impl Wire2Api<Secp256k1ShareSecretReq> for wire_Secp256k1ShareSecretReq {
        fn wire2api(self) -> Secp256k1ShareSecretReq {
            Secp256k1ShareSecretReq {
                seed: self.seed.wire2api(),
                public_key_raw_bytes: self.public_key_raw_bytes.wire2api(),
            }
        }
    }
    impl Wire2Api<Secp256k1SignWithSeedReq> for wire_Secp256k1SignWithSeedReq {
        fn wire2api(self) -> Secp256k1SignWithSeedReq {
            Secp256k1SignWithSeedReq {
                msg: self.msg.wire2api(),
                seed: self.seed.wire2api(),
            }
        }
    }
    impl Wire2Api<Secp256k1VerifyReq> for wire_Secp256k1VerifyReq {
        fn wire2api(self) -> Secp256k1VerifyReq {
            Secp256k1VerifyReq {
                message_hash: self.message_hash.wire2api(),
                signature_bytes: self.signature_bytes.wire2api(),
                public_key_bytes: self.public_key_bytes.wire2api(),
            }
        }
    }
    impl Wire2Api<SeedToKeyReq> for wire_SeedToKeyReq {
        fn wire2api(self) -> SeedToKeyReq {
            SeedToKeyReq {
                seed: self.seed.wire2api(),
                path: self.path.wire2api(),
            }
        }
    }
    impl Wire2Api<SignOptions> for wire_SignOptions {
        fn wire2api(self) -> SignOptions {
            SignOptions {
                trust_witness_utxo: self.trust_witness_utxo.wire2api(),
                assume_height: self.assume_height.wire2api(),
                allow_all_sighashes: self.allow_all_sighashes.wire2api(),
                remove_partial_sigs: self.remove_partial_sigs.wire2api(),
                try_finalize: self.try_finalize.wire2api(),
                sign_with_tap_internal_key: self.sign_with_tap_internal_key.wire2api(),
                allow_grinding: self.allow_grinding.wire2api(),
            }
        }
    }
    impl Wire2Api<SledDbConfiguration> for wire_SledDbConfiguration {
        fn wire2api(self) -> SledDbConfiguration {
            SledDbConfiguration {
                path: self.path.wire2api(),
                tree_name: self.tree_name.wire2api(),
            }
        }
    }
    impl Wire2Api<SqliteDbConfiguration> for wire_SqliteDbConfiguration {
        fn wire2api(self) -> SqliteDbConfiguration {
            SqliteDbConfiguration {
                path: self.path.wire2api(),
            }
        }
    }

    impl Wire2Api<Vec<u8>> for *mut wire_uint_8_list {
        fn wire2api(self) -> Vec<u8> {
            unsafe {
                let wrap = support::box_from_leak_ptr(self);
                support::vec_from_leak_ptr(wrap.ptr, wrap.len)
            }
        }
    }
    impl Wire2Api<UserPass> for wire_UserPass {
        fn wire2api(self) -> UserPass {
            UserPass {
                username: self.username.wire2api(),
                password: self.password.wire2api(),
            }
        }
    }

    // Section: wire structs

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_BdkDescriptor {
        ptr: *const core::ffi::c_void,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_BlockchainInstance {
        ptr: *const core::ffi::c_void,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_WalletInstance {
        ptr: *const core::ffi::c_void,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_AesDecryptReq {
        key: *mut wire_uint_8_list,
        iv: *mut wire_uint_8_list,
        cipher_text: *mut wire_uint_8_list,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_AesEncryptReq {
        key: *mut wire_uint_8_list,
        iv: *mut wire_uint_8_list,
        message: *mut wire_uint_8_list,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_BLSVerifyReq {
        signature: *mut wire_uint_8_list,
        message: *mut wire_uint_8_list,
        public_key: *mut wire_uint_8_list,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_ED25519FromSeedReq {
        seed: *mut wire_uint_8_list,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_ED25519SignReq {
        seed: *mut wire_uint_8_list,
        message: *mut wire_uint_8_list,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_ED25519VerifyReq {
        sig: *mut wire_uint_8_list,
        message: *mut wire_uint_8_list,
        pub_key: *mut wire_uint_8_list,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_ElectrumConfig {
        url: *mut wire_uint_8_list,
        socks5: *mut wire_uint_8_list,
        retry: u8,
        timeout: *mut u8,
        stop_gap: u64,
        validate_domain: bool,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_EsploraConfig {
        base_url: *mut wire_uint_8_list,
        proxy: *mut wire_uint_8_list,
        concurrency: *mut u8,
        stop_gap: u64,
        timeout: *mut u64,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_list_out_point {
        ptr: *mut wire_OutPoint,
        len: i32,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_list_script_amount {
        ptr: *mut wire_ScriptAmount,
        len: i32,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_OutPoint {
        txid: *mut wire_uint_8_list,
        vout: u32,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_P256FromSeedReq {
        seed: *mut wire_uint_8_list,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_P256ShareSecretReq {
        seed: *mut wire_uint_8_list,
        public_key_raw_bytes: *mut wire_uint_8_list,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_P256SignWithSeedReq {
        msg: *mut wire_uint_8_list,
        seed: *mut wire_uint_8_list,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_P256VerifyReq {
        message_hash: *mut wire_uint_8_list,
        signature_bytes: *mut wire_uint_8_list,
        public_key_bytes: *mut wire_uint_8_list,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_PBKDFDeriveReq {
        password: *mut wire_uint_8_list,
        salt: *mut wire_uint_8_list,
        c: u32,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_PhraseToSeedReq {
        phrase: *mut wire_uint_8_list,
        password: *mut wire_uint_8_list,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_RpcConfig {
        url: *mut wire_uint_8_list,
        auth_cookie: *mut wire_uint_8_list,
        auth_user_pass: *mut wire_UserPass,
        network: i32,
        wallet_name: *mut wire_uint_8_list,
        sync_params: *mut wire_RpcSyncParams,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_RpcSyncParams {
        start_script_count: u64,
        start_time: u64,
        force_start_time: bool,
        poll_rate_sec: u64,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_SchnorrFromSeedReq {
        seed: *mut wire_uint_8_list,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_SchnorrSignWithSeedReq {
        msg: *mut wire_uint_8_list,
        seed: *mut wire_uint_8_list,
        aux_rand: *mut wire_uint_8_list,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_SchnorrVerifyReq {
        message_hash: *mut wire_uint_8_list,
        signature_bytes: *mut wire_uint_8_list,
        public_key_bytes: *mut wire_uint_8_list,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_Script {
        internal: *mut wire_uint_8_list,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_ScriptAmount {
        script: wire_Script,
        amount: u64,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_ScriptDeriveReq {
        password: *mut wire_uint_8_list,
        salt: *mut wire_uint_8_list,
        n: u32,
        p: u32,
        r: u32,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_Secp256k1FromSeedReq {
        seed: *mut wire_uint_8_list,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_Secp256k1RecoverReq {
        message_pre_hashed: *mut wire_uint_8_list,
        signature_bytes: *mut wire_uint_8_list,
        chain_id: *mut u8,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_Secp256k1ShareSecretReq {
        seed: *mut wire_uint_8_list,
        public_key_raw_bytes: *mut wire_uint_8_list,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_Secp256k1SignWithSeedReq {
        msg: *mut wire_uint_8_list,
        seed: *mut wire_uint_8_list,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_Secp256k1VerifyReq {
        message_hash: *mut wire_uint_8_list,
        signature_bytes: *mut wire_uint_8_list,
        public_key_bytes: *mut wire_uint_8_list,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_SeedToKeyReq {
        seed: *mut wire_uint_8_list,
        path: *mut wire_uint_8_list,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_SignOptions {
        trust_witness_utxo: bool,
        assume_height: *mut u32,
        allow_all_sighashes: bool,
        remove_partial_sigs: bool,
        try_finalize: bool,
        sign_with_tap_internal_key: bool,
        allow_grinding: bool,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_SledDbConfiguration {
        path: *mut wire_uint_8_list,
        tree_name: *mut wire_uint_8_list,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_SqliteDbConfiguration {
        path: *mut wire_uint_8_list,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_uint_8_list {
        ptr: *mut u8,
        len: i32,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_UserPass {
        username: *mut wire_uint_8_list,
        password: *mut wire_uint_8_list,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_AddressIndex {
        tag: i32,
        kind: *mut AddressIndexKind,
    }

    #[repr(C)]
    pub union AddressIndexKind {
        New: *mut wire_AddressIndex_New,
        LastUnused: *mut wire_AddressIndex_LastUnused,
        Peek: *mut wire_AddressIndex_Peek,
        Reset: *mut wire_AddressIndex_Reset,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_AddressIndex_New {}

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_AddressIndex_LastUnused {}

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_AddressIndex_Peek {
        index: u32,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_AddressIndex_Reset {
        index: u32,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_BlockchainConfig {
        tag: i32,
        kind: *mut BlockchainConfigKind,
    }

    #[repr(C)]
    pub union BlockchainConfigKind {
        Electrum: *mut wire_BlockchainConfig_Electrum,
        Esplora: *mut wire_BlockchainConfig_Esplora,
        Rpc: *mut wire_BlockchainConfig_Rpc,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_BlockchainConfig_Electrum {
        config: *mut wire_ElectrumConfig,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_BlockchainConfig_Esplora {
        config: *mut wire_EsploraConfig,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_BlockchainConfig_Rpc {
        config: *mut wire_RpcConfig,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_DatabaseConfig {
        tag: i32,
        kind: *mut DatabaseConfigKind,
    }

    #[repr(C)]
    pub union DatabaseConfigKind {
        Memory: *mut wire_DatabaseConfig_Memory,
        Sqlite: *mut wire_DatabaseConfig_Sqlite,
        Sled: *mut wire_DatabaseConfig_Sled,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_DatabaseConfig_Memory {}

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_DatabaseConfig_Sqlite {
        config: *mut wire_SqliteDbConfiguration,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_DatabaseConfig_Sled {
        config: *mut wire_SledDbConfiguration,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_RbfValue {
        tag: i32,
        kind: *mut RbfValueKind,
    }

    #[repr(C)]
    pub union RbfValueKind {
        RbfDefault: *mut wire_RbfValue_RbfDefault,
        Value: *mut wire_RbfValue_Value,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_RbfValue_RbfDefault {}

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_RbfValue_Value {
        field0: u32,
    }

    // Section: impl NewWithNullPtr

    pub trait NewWithNullPtr {
        fn new_with_null_ptr() -> Self;
    }

    impl<T> NewWithNullPtr for *mut T {
        fn new_with_null_ptr() -> Self {
            std::ptr::null_mut()
        }
    }

    impl NewWithNullPtr for wire_BdkDescriptor {
        fn new_with_null_ptr() -> Self {
            Self {
                ptr: core::ptr::null(),
            }
        }
    }
    impl NewWithNullPtr for wire_BlockchainInstance {
        fn new_with_null_ptr() -> Self {
            Self {
                ptr: core::ptr::null(),
            }
        }
    }

    impl NewWithNullPtr for wire_WalletInstance {
        fn new_with_null_ptr() -> Self {
            Self {
                ptr: core::ptr::null(),
            }
        }
    }
    impl Default for wire_AddressIndex {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl NewWithNullPtr for wire_AddressIndex {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: core::ptr::null_mut(),
            }
        }
    }

    #[no_mangle]
    pub extern "C" fn inflate_AddressIndex_Peek() -> *mut AddressIndexKind {
        support::new_leak_box_ptr(AddressIndexKind {
            Peek: support::new_leak_box_ptr(wire_AddressIndex_Peek {
                index: Default::default(),
            }),
        })
    }

    #[no_mangle]
    pub extern "C" fn inflate_AddressIndex_Reset() -> *mut AddressIndexKind {
        support::new_leak_box_ptr(AddressIndexKind {
            Reset: support::new_leak_box_ptr(wire_AddressIndex_Reset {
                index: Default::default(),
            }),
        })
    }

    impl NewWithNullPtr for wire_AesDecryptReq {
        fn new_with_null_ptr() -> Self {
            Self {
                key: core::ptr::null_mut(),
                iv: core::ptr::null_mut(),
                cipher_text: core::ptr::null_mut(),
            }
        }
    }

    impl Default for wire_AesDecryptReq {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl NewWithNullPtr for wire_AesEncryptReq {
        fn new_with_null_ptr() -> Self {
            Self {
                key: core::ptr::null_mut(),
                iv: core::ptr::null_mut(),
                message: core::ptr::null_mut(),
            }
        }
    }

    impl Default for wire_AesEncryptReq {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl Default for wire_BlockchainConfig {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl NewWithNullPtr for wire_BlockchainConfig {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: core::ptr::null_mut(),
            }
        }
    }

    #[no_mangle]
    pub extern "C" fn inflate_BlockchainConfig_Electrum() -> *mut BlockchainConfigKind {
        support::new_leak_box_ptr(BlockchainConfigKind {
            Electrum: support::new_leak_box_ptr(wire_BlockchainConfig_Electrum {
                config: core::ptr::null_mut(),
            }),
        })
    }

    #[no_mangle]
    pub extern "C" fn inflate_BlockchainConfig_Esplora() -> *mut BlockchainConfigKind {
        support::new_leak_box_ptr(BlockchainConfigKind {
            Esplora: support::new_leak_box_ptr(wire_BlockchainConfig_Esplora {
                config: core::ptr::null_mut(),
            }),
        })
    }

    #[no_mangle]
    pub extern "C" fn inflate_BlockchainConfig_Rpc() -> *mut BlockchainConfigKind {
        support::new_leak_box_ptr(BlockchainConfigKind {
            Rpc: support::new_leak_box_ptr(wire_BlockchainConfig_Rpc {
                config: core::ptr::null_mut(),
            }),
        })
    }

    impl NewWithNullPtr for wire_BLSVerifyReq {
        fn new_with_null_ptr() -> Self {
            Self {
                signature: core::ptr::null_mut(),
                message: core::ptr::null_mut(),
                public_key: core::ptr::null_mut(),
            }
        }
    }

    impl Default for wire_BLSVerifyReq {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl Default for wire_DatabaseConfig {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl NewWithNullPtr for wire_DatabaseConfig {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: core::ptr::null_mut(),
            }
        }
    }

    #[no_mangle]
    pub extern "C" fn inflate_DatabaseConfig_Sqlite() -> *mut DatabaseConfigKind {
        support::new_leak_box_ptr(DatabaseConfigKind {
            Sqlite: support::new_leak_box_ptr(wire_DatabaseConfig_Sqlite {
                config: core::ptr::null_mut(),
            }),
        })
    }

    #[no_mangle]
    pub extern "C" fn inflate_DatabaseConfig_Sled() -> *mut DatabaseConfigKind {
        support::new_leak_box_ptr(DatabaseConfigKind {
            Sled: support::new_leak_box_ptr(wire_DatabaseConfig_Sled {
                config: core::ptr::null_mut(),
            }),
        })
    }

    impl NewWithNullPtr for wire_ED25519FromSeedReq {
        fn new_with_null_ptr() -> Self {
            Self {
                seed: core::ptr::null_mut(),
            }
        }
    }

    impl Default for wire_ED25519FromSeedReq {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl NewWithNullPtr for wire_ED25519SignReq {
        fn new_with_null_ptr() -> Self {
            Self {
                seed: core::ptr::null_mut(),
                message: core::ptr::null_mut(),
            }
        }
    }

    impl Default for wire_ED25519SignReq {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl NewWithNullPtr for wire_ED25519VerifyReq {
        fn new_with_null_ptr() -> Self {
            Self {
                sig: core::ptr::null_mut(),
                message: core::ptr::null_mut(),
                pub_key: core::ptr::null_mut(),
            }
        }
    }

    impl Default for wire_ED25519VerifyReq {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl NewWithNullPtr for wire_ElectrumConfig {
        fn new_with_null_ptr() -> Self {
            Self {
                url: core::ptr::null_mut(),
                socks5: core::ptr::null_mut(),
                retry: Default::default(),
                timeout: core::ptr::null_mut(),
                stop_gap: Default::default(),
                validate_domain: Default::default(),
            }
        }
    }

    impl Default for wire_ElectrumConfig {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl NewWithNullPtr for wire_EsploraConfig {
        fn new_with_null_ptr() -> Self {
            Self {
                base_url: core::ptr::null_mut(),
                proxy: core::ptr::null_mut(),
                concurrency: core::ptr::null_mut(),
                stop_gap: Default::default(),
                timeout: core::ptr::null_mut(),
            }
        }
    }

    impl Default for wire_EsploraConfig {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl NewWithNullPtr for wire_OutPoint {
        fn new_with_null_ptr() -> Self {
            Self {
                txid: core::ptr::null_mut(),
                vout: Default::default(),
            }
        }
    }

    impl Default for wire_OutPoint {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl NewWithNullPtr for wire_P256FromSeedReq {
        fn new_with_null_ptr() -> Self {
            Self {
                seed: core::ptr::null_mut(),
            }
        }
    }

    impl Default for wire_P256FromSeedReq {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl NewWithNullPtr for wire_P256ShareSecretReq {
        fn new_with_null_ptr() -> Self {
            Self {
                seed: core::ptr::null_mut(),
                public_key_raw_bytes: core::ptr::null_mut(),
            }
        }
    }

    impl Default for wire_P256ShareSecretReq {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl NewWithNullPtr for wire_P256SignWithSeedReq {
        fn new_with_null_ptr() -> Self {
            Self {
                msg: core::ptr::null_mut(),
                seed: core::ptr::null_mut(),
            }
        }
    }

    impl Default for wire_P256SignWithSeedReq {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl NewWithNullPtr for wire_P256VerifyReq {
        fn new_with_null_ptr() -> Self {
            Self {
                message_hash: core::ptr::null_mut(),
                signature_bytes: core::ptr::null_mut(),
                public_key_bytes: core::ptr::null_mut(),
            }
        }
    }

    impl Default for wire_P256VerifyReq {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl NewWithNullPtr for wire_PBKDFDeriveReq {
        fn new_with_null_ptr() -> Self {
            Self {
                password: core::ptr::null_mut(),
                salt: core::ptr::null_mut(),
                c: Default::default(),
            }
        }
    }

    impl Default for wire_PBKDFDeriveReq {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl NewWithNullPtr for wire_PhraseToSeedReq {
        fn new_with_null_ptr() -> Self {
            Self {
                phrase: core::ptr::null_mut(),
                password: core::ptr::null_mut(),
            }
        }
    }

    impl Default for wire_PhraseToSeedReq {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl Default for wire_RbfValue {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl NewWithNullPtr for wire_RbfValue {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: core::ptr::null_mut(),
            }
        }
    }

    #[no_mangle]
    pub extern "C" fn inflate_RbfValue_Value() -> *mut RbfValueKind {
        support::new_leak_box_ptr(RbfValueKind {
            Value: support::new_leak_box_ptr(wire_RbfValue_Value {
                field0: Default::default(),
            }),
        })
    }

    impl NewWithNullPtr for wire_RpcConfig {
        fn new_with_null_ptr() -> Self {
            Self {
                url: core::ptr::null_mut(),
                auth_cookie: core::ptr::null_mut(),
                auth_user_pass: core::ptr::null_mut(),
                network: Default::default(),
                wallet_name: core::ptr::null_mut(),
                sync_params: core::ptr::null_mut(),
            }
        }
    }

    impl Default for wire_RpcConfig {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl NewWithNullPtr for wire_RpcSyncParams {
        fn new_with_null_ptr() -> Self {
            Self {
                start_script_count: Default::default(),
                start_time: Default::default(),
                force_start_time: Default::default(),
                poll_rate_sec: Default::default(),
            }
        }
    }

    impl Default for wire_RpcSyncParams {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl NewWithNullPtr for wire_SchnorrFromSeedReq {
        fn new_with_null_ptr() -> Self {
            Self {
                seed: core::ptr::null_mut(),
            }
        }
    }

    impl Default for wire_SchnorrFromSeedReq {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl NewWithNullPtr for wire_SchnorrSignWithSeedReq {
        fn new_with_null_ptr() -> Self {
            Self {
                msg: core::ptr::null_mut(),
                seed: core::ptr::null_mut(),
                aux_rand: core::ptr::null_mut(),
            }
        }
    }

    impl Default for wire_SchnorrSignWithSeedReq {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl NewWithNullPtr for wire_SchnorrVerifyReq {
        fn new_with_null_ptr() -> Self {
            Self {
                message_hash: core::ptr::null_mut(),
                signature_bytes: core::ptr::null_mut(),
                public_key_bytes: core::ptr::null_mut(),
            }
        }
    }

    impl Default for wire_SchnorrVerifyReq {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl NewWithNullPtr for wire_Script {
        fn new_with_null_ptr() -> Self {
            Self {
                internal: core::ptr::null_mut(),
            }
        }
    }

    impl Default for wire_Script {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl NewWithNullPtr for wire_ScriptAmount {
        fn new_with_null_ptr() -> Self {
            Self {
                script: Default::default(),
                amount: Default::default(),
            }
        }
    }

    impl Default for wire_ScriptAmount {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl NewWithNullPtr for wire_ScriptDeriveReq {
        fn new_with_null_ptr() -> Self {
            Self {
                password: core::ptr::null_mut(),
                salt: core::ptr::null_mut(),
                n: Default::default(),
                p: Default::default(),
                r: Default::default(),
            }
        }
    }

    impl Default for wire_ScriptDeriveReq {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl NewWithNullPtr for wire_Secp256k1FromSeedReq {
        fn new_with_null_ptr() -> Self {
            Self {
                seed: core::ptr::null_mut(),
            }
        }
    }

    impl Default for wire_Secp256k1FromSeedReq {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl NewWithNullPtr for wire_Secp256k1RecoverReq {
        fn new_with_null_ptr() -> Self {
            Self {
                message_pre_hashed: core::ptr::null_mut(),
                signature_bytes: core::ptr::null_mut(),
                chain_id: core::ptr::null_mut(),
            }
        }
    }

    impl Default for wire_Secp256k1RecoverReq {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl NewWithNullPtr for wire_Secp256k1ShareSecretReq {
        fn new_with_null_ptr() -> Self {
            Self {
                seed: core::ptr::null_mut(),
                public_key_raw_bytes: core::ptr::null_mut(),
            }
        }
    }

    impl Default for wire_Secp256k1ShareSecretReq {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl NewWithNullPtr for wire_Secp256k1SignWithSeedReq {
        fn new_with_null_ptr() -> Self {
            Self {
                msg: core::ptr::null_mut(),
                seed: core::ptr::null_mut(),
            }
        }
    }

    impl Default for wire_Secp256k1SignWithSeedReq {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl NewWithNullPtr for wire_Secp256k1VerifyReq {
        fn new_with_null_ptr() -> Self {
            Self {
                message_hash: core::ptr::null_mut(),
                signature_bytes: core::ptr::null_mut(),
                public_key_bytes: core::ptr::null_mut(),
            }
        }
    }

    impl Default for wire_Secp256k1VerifyReq {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl NewWithNullPtr for wire_SeedToKeyReq {
        fn new_with_null_ptr() -> Self {
            Self {
                seed: core::ptr::null_mut(),
                path: core::ptr::null_mut(),
            }
        }
    }

    impl Default for wire_SeedToKeyReq {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl NewWithNullPtr for wire_SignOptions {
        fn new_with_null_ptr() -> Self {
            Self {
                trust_witness_utxo: Default::default(),
                assume_height: core::ptr::null_mut(),
                allow_all_sighashes: Default::default(),
                remove_partial_sigs: Default::default(),
                try_finalize: Default::default(),
                sign_with_tap_internal_key: Default::default(),
                allow_grinding: Default::default(),
            }
        }
    }

    impl Default for wire_SignOptions {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl NewWithNullPtr for wire_SledDbConfiguration {
        fn new_with_null_ptr() -> Self {
            Self {
                path: core::ptr::null_mut(),
                tree_name: core::ptr::null_mut(),
            }
        }
    }

    impl Default for wire_SledDbConfiguration {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl NewWithNullPtr for wire_SqliteDbConfiguration {
        fn new_with_null_ptr() -> Self {
            Self {
                path: core::ptr::null_mut(),
            }
        }
    }

    impl Default for wire_SqliteDbConfiguration {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl NewWithNullPtr for wire_UserPass {
        fn new_with_null_ptr() -> Self {
            Self {
                username: core::ptr::null_mut(),
                password: core::ptr::null_mut(),
            }
        }
    }

    impl Default for wire_UserPass {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    // Section: sync execution mode utility

    #[no_mangle]
    pub extern "C" fn free_WireSyncReturn(ptr: support::WireSyncReturn) {
        unsafe {
            let _ = support::box_from_leak_ptr(ptr);
        };
    }
}
#[cfg(not(target_family = "wasm"))]
pub use io::*;
