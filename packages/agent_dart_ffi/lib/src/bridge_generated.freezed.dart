// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'bridge_generated.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$AddressIndex {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() newIndex,
    required TResult Function() lastUnused,
    required TResult Function(int index) peek,
    required TResult Function(int index) reset,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? newIndex,
    TResult? Function()? lastUnused,
    TResult? Function(int index)? peek,
    TResult? Function(int index)? reset,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? newIndex,
    TResult Function()? lastUnused,
    TResult Function(int index)? peek,
    TResult Function(int index)? reset,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AddressIndex_NewIndex value) newIndex,
    required TResult Function(AddressIndex_LastUnused value) lastUnused,
    required TResult Function(AddressIndex_Peek value) peek,
    required TResult Function(AddressIndex_Reset value) reset,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AddressIndex_NewIndex value)? newIndex,
    TResult? Function(AddressIndex_LastUnused value)? lastUnused,
    TResult? Function(AddressIndex_Peek value)? peek,
    TResult? Function(AddressIndex_Reset value)? reset,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AddressIndex_NewIndex value)? newIndex,
    TResult Function(AddressIndex_LastUnused value)? lastUnused,
    TResult Function(AddressIndex_Peek value)? peek,
    TResult Function(AddressIndex_Reset value)? reset,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AddressIndexCopyWith<$Res> {
  factory $AddressIndexCopyWith(
          AddressIndex value, $Res Function(AddressIndex) then) =
      _$AddressIndexCopyWithImpl<$Res, AddressIndex>;
}

/// @nodoc
class _$AddressIndexCopyWithImpl<$Res, $Val extends AddressIndex>
    implements $AddressIndexCopyWith<$Res> {
  _$AddressIndexCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$AddressIndex_NewIndexImplCopyWith<$Res> {
  factory _$$AddressIndex_NewIndexImplCopyWith(
          _$AddressIndex_NewIndexImpl value,
          $Res Function(_$AddressIndex_NewIndexImpl) then) =
      __$$AddressIndex_NewIndexImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AddressIndex_NewIndexImplCopyWithImpl<$Res>
    extends _$AddressIndexCopyWithImpl<$Res, _$AddressIndex_NewIndexImpl>
    implements _$$AddressIndex_NewIndexImplCopyWith<$Res> {
  __$$AddressIndex_NewIndexImplCopyWithImpl(_$AddressIndex_NewIndexImpl _value,
      $Res Function(_$AddressIndex_NewIndexImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$AddressIndex_NewIndexImpl implements AddressIndex_NewIndex {
  const _$AddressIndex_NewIndexImpl();

  @override
  String toString() {
    return 'AddressIndex.newIndex()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddressIndex_NewIndexImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() newIndex,
    required TResult Function() lastUnused,
    required TResult Function(int index) peek,
    required TResult Function(int index) reset,
  }) {
    return newIndex();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? newIndex,
    TResult? Function()? lastUnused,
    TResult? Function(int index)? peek,
    TResult? Function(int index)? reset,
  }) {
    return newIndex?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? newIndex,
    TResult Function()? lastUnused,
    TResult Function(int index)? peek,
    TResult Function(int index)? reset,
    required TResult orElse(),
  }) {
    if (newIndex != null) {
      return newIndex();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AddressIndex_NewIndex value) newIndex,
    required TResult Function(AddressIndex_LastUnused value) lastUnused,
    required TResult Function(AddressIndex_Peek value) peek,
    required TResult Function(AddressIndex_Reset value) reset,
  }) {
    return newIndex(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AddressIndex_NewIndex value)? newIndex,
    TResult? Function(AddressIndex_LastUnused value)? lastUnused,
    TResult? Function(AddressIndex_Peek value)? peek,
    TResult? Function(AddressIndex_Reset value)? reset,
  }) {
    return newIndex?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AddressIndex_NewIndex value)? newIndex,
    TResult Function(AddressIndex_LastUnused value)? lastUnused,
    TResult Function(AddressIndex_Peek value)? peek,
    TResult Function(AddressIndex_Reset value)? reset,
    required TResult orElse(),
  }) {
    if (newIndex != null) {
      return newIndex(this);
    }
    return orElse();
  }
}

abstract class AddressIndex_NewIndex implements AddressIndex {
  const factory AddressIndex_NewIndex() = _$AddressIndex_NewIndexImpl;
}

/// @nodoc
abstract class _$$AddressIndex_LastUnusedImplCopyWith<$Res> {
  factory _$$AddressIndex_LastUnusedImplCopyWith(
          _$AddressIndex_LastUnusedImpl value,
          $Res Function(_$AddressIndex_LastUnusedImpl) then) =
      __$$AddressIndex_LastUnusedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AddressIndex_LastUnusedImplCopyWithImpl<$Res>
    extends _$AddressIndexCopyWithImpl<$Res, _$AddressIndex_LastUnusedImpl>
    implements _$$AddressIndex_LastUnusedImplCopyWith<$Res> {
  __$$AddressIndex_LastUnusedImplCopyWithImpl(
      _$AddressIndex_LastUnusedImpl _value,
      $Res Function(_$AddressIndex_LastUnusedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$AddressIndex_LastUnusedImpl implements AddressIndex_LastUnused {
  const _$AddressIndex_LastUnusedImpl();

  @override
  String toString() {
    return 'AddressIndex.lastUnused()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddressIndex_LastUnusedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() newIndex,
    required TResult Function() lastUnused,
    required TResult Function(int index) peek,
    required TResult Function(int index) reset,
  }) {
    return lastUnused();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? newIndex,
    TResult? Function()? lastUnused,
    TResult? Function(int index)? peek,
    TResult? Function(int index)? reset,
  }) {
    return lastUnused?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? newIndex,
    TResult Function()? lastUnused,
    TResult Function(int index)? peek,
    TResult Function(int index)? reset,
    required TResult orElse(),
  }) {
    if (lastUnused != null) {
      return lastUnused();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AddressIndex_NewIndex value) newIndex,
    required TResult Function(AddressIndex_LastUnused value) lastUnused,
    required TResult Function(AddressIndex_Peek value) peek,
    required TResult Function(AddressIndex_Reset value) reset,
  }) {
    return lastUnused(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AddressIndex_NewIndex value)? newIndex,
    TResult? Function(AddressIndex_LastUnused value)? lastUnused,
    TResult? Function(AddressIndex_Peek value)? peek,
    TResult? Function(AddressIndex_Reset value)? reset,
  }) {
    return lastUnused?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AddressIndex_NewIndex value)? newIndex,
    TResult Function(AddressIndex_LastUnused value)? lastUnused,
    TResult Function(AddressIndex_Peek value)? peek,
    TResult Function(AddressIndex_Reset value)? reset,
    required TResult orElse(),
  }) {
    if (lastUnused != null) {
      return lastUnused(this);
    }
    return orElse();
  }
}

abstract class AddressIndex_LastUnused implements AddressIndex {
  const factory AddressIndex_LastUnused() = _$AddressIndex_LastUnusedImpl;
}

/// @nodoc
abstract class _$$AddressIndex_PeekImplCopyWith<$Res> {
  factory _$$AddressIndex_PeekImplCopyWith(_$AddressIndex_PeekImpl value,
          $Res Function(_$AddressIndex_PeekImpl) then) =
      __$$AddressIndex_PeekImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int index});
}

/// @nodoc
class __$$AddressIndex_PeekImplCopyWithImpl<$Res>
    extends _$AddressIndexCopyWithImpl<$Res, _$AddressIndex_PeekImpl>
    implements _$$AddressIndex_PeekImplCopyWith<$Res> {
  __$$AddressIndex_PeekImplCopyWithImpl(_$AddressIndex_PeekImpl _value,
      $Res Function(_$AddressIndex_PeekImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
  }) {
    return _then(_$AddressIndex_PeekImpl(
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$AddressIndex_PeekImpl implements AddressIndex_Peek {
  const _$AddressIndex_PeekImpl({required this.index});

  @override
  final int index;

  @override
  String toString() {
    return 'AddressIndex.peek(index: $index)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddressIndex_PeekImpl &&
            (identical(other.index, index) || other.index == index));
  }

  @override
  int get hashCode => Object.hash(runtimeType, index);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AddressIndex_PeekImplCopyWith<_$AddressIndex_PeekImpl> get copyWith =>
      __$$AddressIndex_PeekImplCopyWithImpl<_$AddressIndex_PeekImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() newIndex,
    required TResult Function() lastUnused,
    required TResult Function(int index) peek,
    required TResult Function(int index) reset,
  }) {
    return peek(index);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? newIndex,
    TResult? Function()? lastUnused,
    TResult? Function(int index)? peek,
    TResult? Function(int index)? reset,
  }) {
    return peek?.call(index);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? newIndex,
    TResult Function()? lastUnused,
    TResult Function(int index)? peek,
    TResult Function(int index)? reset,
    required TResult orElse(),
  }) {
    if (peek != null) {
      return peek(index);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AddressIndex_NewIndex value) newIndex,
    required TResult Function(AddressIndex_LastUnused value) lastUnused,
    required TResult Function(AddressIndex_Peek value) peek,
    required TResult Function(AddressIndex_Reset value) reset,
  }) {
    return peek(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AddressIndex_NewIndex value)? newIndex,
    TResult? Function(AddressIndex_LastUnused value)? lastUnused,
    TResult? Function(AddressIndex_Peek value)? peek,
    TResult? Function(AddressIndex_Reset value)? reset,
  }) {
    return peek?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AddressIndex_NewIndex value)? newIndex,
    TResult Function(AddressIndex_LastUnused value)? lastUnused,
    TResult Function(AddressIndex_Peek value)? peek,
    TResult Function(AddressIndex_Reset value)? reset,
    required TResult orElse(),
  }) {
    if (peek != null) {
      return peek(this);
    }
    return orElse();
  }
}

abstract class AddressIndex_Peek implements AddressIndex {
  const factory AddressIndex_Peek({required final int index}) =
      _$AddressIndex_PeekImpl;

  int get index;
  @JsonKey(ignore: true)
  _$$AddressIndex_PeekImplCopyWith<_$AddressIndex_PeekImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AddressIndex_ResetImplCopyWith<$Res> {
  factory _$$AddressIndex_ResetImplCopyWith(_$AddressIndex_ResetImpl value,
          $Res Function(_$AddressIndex_ResetImpl) then) =
      __$$AddressIndex_ResetImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int index});
}

/// @nodoc
class __$$AddressIndex_ResetImplCopyWithImpl<$Res>
    extends _$AddressIndexCopyWithImpl<$Res, _$AddressIndex_ResetImpl>
    implements _$$AddressIndex_ResetImplCopyWith<$Res> {
  __$$AddressIndex_ResetImplCopyWithImpl(_$AddressIndex_ResetImpl _value,
      $Res Function(_$AddressIndex_ResetImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
  }) {
    return _then(_$AddressIndex_ResetImpl(
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$AddressIndex_ResetImpl implements AddressIndex_Reset {
  const _$AddressIndex_ResetImpl({required this.index});

  @override
  final int index;

  @override
  String toString() {
    return 'AddressIndex.reset(index: $index)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddressIndex_ResetImpl &&
            (identical(other.index, index) || other.index == index));
  }

  @override
  int get hashCode => Object.hash(runtimeType, index);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AddressIndex_ResetImplCopyWith<_$AddressIndex_ResetImpl> get copyWith =>
      __$$AddressIndex_ResetImplCopyWithImpl<_$AddressIndex_ResetImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() newIndex,
    required TResult Function() lastUnused,
    required TResult Function(int index) peek,
    required TResult Function(int index) reset,
  }) {
    return reset(index);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? newIndex,
    TResult? Function()? lastUnused,
    TResult? Function(int index)? peek,
    TResult? Function(int index)? reset,
  }) {
    return reset?.call(index);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? newIndex,
    TResult Function()? lastUnused,
    TResult Function(int index)? peek,
    TResult Function(int index)? reset,
    required TResult orElse(),
  }) {
    if (reset != null) {
      return reset(index);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AddressIndex_NewIndex value) newIndex,
    required TResult Function(AddressIndex_LastUnused value) lastUnused,
    required TResult Function(AddressIndex_Peek value) peek,
    required TResult Function(AddressIndex_Reset value) reset,
  }) {
    return reset(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AddressIndex_NewIndex value)? newIndex,
    TResult? Function(AddressIndex_LastUnused value)? lastUnused,
    TResult? Function(AddressIndex_Peek value)? peek,
    TResult? Function(AddressIndex_Reset value)? reset,
  }) {
    return reset?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AddressIndex_NewIndex value)? newIndex,
    TResult Function(AddressIndex_LastUnused value)? lastUnused,
    TResult Function(AddressIndex_Peek value)? peek,
    TResult Function(AddressIndex_Reset value)? reset,
    required TResult orElse(),
  }) {
    if (reset != null) {
      return reset(this);
    }
    return orElse();
  }
}

abstract class AddressIndex_Reset implements AddressIndex {
  const factory AddressIndex_Reset({required final int index}) =
      _$AddressIndex_ResetImpl;

  int get index;
  @JsonKey(ignore: true)
  _$$AddressIndex_ResetImplCopyWith<_$AddressIndex_ResetImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$BlockchainConfig {
  Object get config => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ElectrumConfig config) electrum,
    required TResult Function(EsploraConfig config) esplora,
    required TResult Function(RpcConfig config) rpc,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ElectrumConfig config)? electrum,
    TResult? Function(EsploraConfig config)? esplora,
    TResult? Function(RpcConfig config)? rpc,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ElectrumConfig config)? electrum,
    TResult Function(EsploraConfig config)? esplora,
    TResult Function(RpcConfig config)? rpc,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BlockchainConfig_Electrum value) electrum,
    required TResult Function(BlockchainConfig_Esplora value) esplora,
    required TResult Function(BlockchainConfig_Rpc value) rpc,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BlockchainConfig_Electrum value)? electrum,
    TResult? Function(BlockchainConfig_Esplora value)? esplora,
    TResult? Function(BlockchainConfig_Rpc value)? rpc,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BlockchainConfig_Electrum value)? electrum,
    TResult Function(BlockchainConfig_Esplora value)? esplora,
    TResult Function(BlockchainConfig_Rpc value)? rpc,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BlockchainConfigCopyWith<$Res> {
  factory $BlockchainConfigCopyWith(
          BlockchainConfig value, $Res Function(BlockchainConfig) then) =
      _$BlockchainConfigCopyWithImpl<$Res, BlockchainConfig>;
}

/// @nodoc
class _$BlockchainConfigCopyWithImpl<$Res, $Val extends BlockchainConfig>
    implements $BlockchainConfigCopyWith<$Res> {
  _$BlockchainConfigCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$BlockchainConfig_ElectrumImplCopyWith<$Res> {
  factory _$$BlockchainConfig_ElectrumImplCopyWith(
          _$BlockchainConfig_ElectrumImpl value,
          $Res Function(_$BlockchainConfig_ElectrumImpl) then) =
      __$$BlockchainConfig_ElectrumImplCopyWithImpl<$Res>;
  @useResult
  $Res call({ElectrumConfig config});
}

/// @nodoc
class __$$BlockchainConfig_ElectrumImplCopyWithImpl<$Res>
    extends _$BlockchainConfigCopyWithImpl<$Res,
        _$BlockchainConfig_ElectrumImpl>
    implements _$$BlockchainConfig_ElectrumImplCopyWith<$Res> {
  __$$BlockchainConfig_ElectrumImplCopyWithImpl(
      _$BlockchainConfig_ElectrumImpl _value,
      $Res Function(_$BlockchainConfig_ElectrumImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? config = null,
  }) {
    return _then(_$BlockchainConfig_ElectrumImpl(
      config: null == config
          ? _value.config
          : config // ignore: cast_nullable_to_non_nullable
              as ElectrumConfig,
    ));
  }
}

/// @nodoc

class _$BlockchainConfig_ElectrumImpl implements BlockchainConfig_Electrum {
  const _$BlockchainConfig_ElectrumImpl({required this.config});

  @override
  final ElectrumConfig config;

  @override
  String toString() {
    return 'BlockchainConfig.electrum(config: $config)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BlockchainConfig_ElectrumImpl &&
            (identical(other.config, config) || other.config == config));
  }

  @override
  int get hashCode => Object.hash(runtimeType, config);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BlockchainConfig_ElectrumImplCopyWith<_$BlockchainConfig_ElectrumImpl>
      get copyWith => __$$BlockchainConfig_ElectrumImplCopyWithImpl<
          _$BlockchainConfig_ElectrumImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ElectrumConfig config) electrum,
    required TResult Function(EsploraConfig config) esplora,
    required TResult Function(RpcConfig config) rpc,
  }) {
    return electrum(config);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ElectrumConfig config)? electrum,
    TResult? Function(EsploraConfig config)? esplora,
    TResult? Function(RpcConfig config)? rpc,
  }) {
    return electrum?.call(config);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ElectrumConfig config)? electrum,
    TResult Function(EsploraConfig config)? esplora,
    TResult Function(RpcConfig config)? rpc,
    required TResult orElse(),
  }) {
    if (electrum != null) {
      return electrum(config);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BlockchainConfig_Electrum value) electrum,
    required TResult Function(BlockchainConfig_Esplora value) esplora,
    required TResult Function(BlockchainConfig_Rpc value) rpc,
  }) {
    return electrum(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BlockchainConfig_Electrum value)? electrum,
    TResult? Function(BlockchainConfig_Esplora value)? esplora,
    TResult? Function(BlockchainConfig_Rpc value)? rpc,
  }) {
    return electrum?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BlockchainConfig_Electrum value)? electrum,
    TResult Function(BlockchainConfig_Esplora value)? esplora,
    TResult Function(BlockchainConfig_Rpc value)? rpc,
    required TResult orElse(),
  }) {
    if (electrum != null) {
      return electrum(this);
    }
    return orElse();
  }
}

abstract class BlockchainConfig_Electrum implements BlockchainConfig {
  const factory BlockchainConfig_Electrum(
      {required final ElectrumConfig config}) = _$BlockchainConfig_ElectrumImpl;

  @override
  ElectrumConfig get config;
  @JsonKey(ignore: true)
  _$$BlockchainConfig_ElectrumImplCopyWith<_$BlockchainConfig_ElectrumImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BlockchainConfig_EsploraImplCopyWith<$Res> {
  factory _$$BlockchainConfig_EsploraImplCopyWith(
          _$BlockchainConfig_EsploraImpl value,
          $Res Function(_$BlockchainConfig_EsploraImpl) then) =
      __$$BlockchainConfig_EsploraImplCopyWithImpl<$Res>;
  @useResult
  $Res call({EsploraConfig config});
}

/// @nodoc
class __$$BlockchainConfig_EsploraImplCopyWithImpl<$Res>
    extends _$BlockchainConfigCopyWithImpl<$Res, _$BlockchainConfig_EsploraImpl>
    implements _$$BlockchainConfig_EsploraImplCopyWith<$Res> {
  __$$BlockchainConfig_EsploraImplCopyWithImpl(
      _$BlockchainConfig_EsploraImpl _value,
      $Res Function(_$BlockchainConfig_EsploraImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? config = null,
  }) {
    return _then(_$BlockchainConfig_EsploraImpl(
      config: null == config
          ? _value.config
          : config // ignore: cast_nullable_to_non_nullable
              as EsploraConfig,
    ));
  }
}

/// @nodoc

class _$BlockchainConfig_EsploraImpl implements BlockchainConfig_Esplora {
  const _$BlockchainConfig_EsploraImpl({required this.config});

  @override
  final EsploraConfig config;

  @override
  String toString() {
    return 'BlockchainConfig.esplora(config: $config)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BlockchainConfig_EsploraImpl &&
            (identical(other.config, config) || other.config == config));
  }

  @override
  int get hashCode => Object.hash(runtimeType, config);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BlockchainConfig_EsploraImplCopyWith<_$BlockchainConfig_EsploraImpl>
      get copyWith => __$$BlockchainConfig_EsploraImplCopyWithImpl<
          _$BlockchainConfig_EsploraImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ElectrumConfig config) electrum,
    required TResult Function(EsploraConfig config) esplora,
    required TResult Function(RpcConfig config) rpc,
  }) {
    return esplora(config);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ElectrumConfig config)? electrum,
    TResult? Function(EsploraConfig config)? esplora,
    TResult? Function(RpcConfig config)? rpc,
  }) {
    return esplora?.call(config);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ElectrumConfig config)? electrum,
    TResult Function(EsploraConfig config)? esplora,
    TResult Function(RpcConfig config)? rpc,
    required TResult orElse(),
  }) {
    if (esplora != null) {
      return esplora(config);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BlockchainConfig_Electrum value) electrum,
    required TResult Function(BlockchainConfig_Esplora value) esplora,
    required TResult Function(BlockchainConfig_Rpc value) rpc,
  }) {
    return esplora(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BlockchainConfig_Electrum value)? electrum,
    TResult? Function(BlockchainConfig_Esplora value)? esplora,
    TResult? Function(BlockchainConfig_Rpc value)? rpc,
  }) {
    return esplora?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BlockchainConfig_Electrum value)? electrum,
    TResult Function(BlockchainConfig_Esplora value)? esplora,
    TResult Function(BlockchainConfig_Rpc value)? rpc,
    required TResult orElse(),
  }) {
    if (esplora != null) {
      return esplora(this);
    }
    return orElse();
  }
}

abstract class BlockchainConfig_Esplora implements BlockchainConfig {
  const factory BlockchainConfig_Esplora(
      {required final EsploraConfig config}) = _$BlockchainConfig_EsploraImpl;

  @override
  EsploraConfig get config;
  @JsonKey(ignore: true)
  _$$BlockchainConfig_EsploraImplCopyWith<_$BlockchainConfig_EsploraImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BlockchainConfig_RpcImplCopyWith<$Res> {
  factory _$$BlockchainConfig_RpcImplCopyWith(_$BlockchainConfig_RpcImpl value,
          $Res Function(_$BlockchainConfig_RpcImpl) then) =
      __$$BlockchainConfig_RpcImplCopyWithImpl<$Res>;
  @useResult
  $Res call({RpcConfig config});
}

/// @nodoc
class __$$BlockchainConfig_RpcImplCopyWithImpl<$Res>
    extends _$BlockchainConfigCopyWithImpl<$Res, _$BlockchainConfig_RpcImpl>
    implements _$$BlockchainConfig_RpcImplCopyWith<$Res> {
  __$$BlockchainConfig_RpcImplCopyWithImpl(_$BlockchainConfig_RpcImpl _value,
      $Res Function(_$BlockchainConfig_RpcImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? config = null,
  }) {
    return _then(_$BlockchainConfig_RpcImpl(
      config: null == config
          ? _value.config
          : config // ignore: cast_nullable_to_non_nullable
              as RpcConfig,
    ));
  }
}

/// @nodoc

class _$BlockchainConfig_RpcImpl implements BlockchainConfig_Rpc {
  const _$BlockchainConfig_RpcImpl({required this.config});

  @override
  final RpcConfig config;

  @override
  String toString() {
    return 'BlockchainConfig.rpc(config: $config)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BlockchainConfig_RpcImpl &&
            (identical(other.config, config) || other.config == config));
  }

  @override
  int get hashCode => Object.hash(runtimeType, config);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BlockchainConfig_RpcImplCopyWith<_$BlockchainConfig_RpcImpl>
      get copyWith =>
          __$$BlockchainConfig_RpcImplCopyWithImpl<_$BlockchainConfig_RpcImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ElectrumConfig config) electrum,
    required TResult Function(EsploraConfig config) esplora,
    required TResult Function(RpcConfig config) rpc,
  }) {
    return rpc(config);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ElectrumConfig config)? electrum,
    TResult? Function(EsploraConfig config)? esplora,
    TResult? Function(RpcConfig config)? rpc,
  }) {
    return rpc?.call(config);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ElectrumConfig config)? electrum,
    TResult Function(EsploraConfig config)? esplora,
    TResult Function(RpcConfig config)? rpc,
    required TResult orElse(),
  }) {
    if (rpc != null) {
      return rpc(config);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BlockchainConfig_Electrum value) electrum,
    required TResult Function(BlockchainConfig_Esplora value) esplora,
    required TResult Function(BlockchainConfig_Rpc value) rpc,
  }) {
    return rpc(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BlockchainConfig_Electrum value)? electrum,
    TResult? Function(BlockchainConfig_Esplora value)? esplora,
    TResult? Function(BlockchainConfig_Rpc value)? rpc,
  }) {
    return rpc?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BlockchainConfig_Electrum value)? electrum,
    TResult Function(BlockchainConfig_Esplora value)? esplora,
    TResult Function(BlockchainConfig_Rpc value)? rpc,
    required TResult orElse(),
  }) {
    if (rpc != null) {
      return rpc(this);
    }
    return orElse();
  }
}

abstract class BlockchainConfig_Rpc implements BlockchainConfig {
  const factory BlockchainConfig_Rpc({required final RpcConfig config}) =
      _$BlockchainConfig_RpcImpl;

  @override
  RpcConfig get config;
  @JsonKey(ignore: true)
  _$$BlockchainConfig_RpcImplCopyWith<_$BlockchainConfig_RpcImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$DatabaseConfig {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() memory,
    required TResult Function(SqliteDbConfiguration config) sqlite,
    required TResult Function(SledDbConfiguration config) sled,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? memory,
    TResult? Function(SqliteDbConfiguration config)? sqlite,
    TResult? Function(SledDbConfiguration config)? sled,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? memory,
    TResult Function(SqliteDbConfiguration config)? sqlite,
    TResult Function(SledDbConfiguration config)? sled,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DatabaseConfig_Memory value) memory,
    required TResult Function(DatabaseConfig_Sqlite value) sqlite,
    required TResult Function(DatabaseConfig_Sled value) sled,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DatabaseConfig_Memory value)? memory,
    TResult? Function(DatabaseConfig_Sqlite value)? sqlite,
    TResult? Function(DatabaseConfig_Sled value)? sled,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DatabaseConfig_Memory value)? memory,
    TResult Function(DatabaseConfig_Sqlite value)? sqlite,
    TResult Function(DatabaseConfig_Sled value)? sled,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DatabaseConfigCopyWith<$Res> {
  factory $DatabaseConfigCopyWith(
          DatabaseConfig value, $Res Function(DatabaseConfig) then) =
      _$DatabaseConfigCopyWithImpl<$Res, DatabaseConfig>;
}

/// @nodoc
class _$DatabaseConfigCopyWithImpl<$Res, $Val extends DatabaseConfig>
    implements $DatabaseConfigCopyWith<$Res> {
  _$DatabaseConfigCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$DatabaseConfig_MemoryImplCopyWith<$Res> {
  factory _$$DatabaseConfig_MemoryImplCopyWith(
          _$DatabaseConfig_MemoryImpl value,
          $Res Function(_$DatabaseConfig_MemoryImpl) then) =
      __$$DatabaseConfig_MemoryImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DatabaseConfig_MemoryImplCopyWithImpl<$Res>
    extends _$DatabaseConfigCopyWithImpl<$Res, _$DatabaseConfig_MemoryImpl>
    implements _$$DatabaseConfig_MemoryImplCopyWith<$Res> {
  __$$DatabaseConfig_MemoryImplCopyWithImpl(_$DatabaseConfig_MemoryImpl _value,
      $Res Function(_$DatabaseConfig_MemoryImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DatabaseConfig_MemoryImpl implements DatabaseConfig_Memory {
  const _$DatabaseConfig_MemoryImpl();

  @override
  String toString() {
    return 'DatabaseConfig.memory()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DatabaseConfig_MemoryImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() memory,
    required TResult Function(SqliteDbConfiguration config) sqlite,
    required TResult Function(SledDbConfiguration config) sled,
  }) {
    return memory();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? memory,
    TResult? Function(SqliteDbConfiguration config)? sqlite,
    TResult? Function(SledDbConfiguration config)? sled,
  }) {
    return memory?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? memory,
    TResult Function(SqliteDbConfiguration config)? sqlite,
    TResult Function(SledDbConfiguration config)? sled,
    required TResult orElse(),
  }) {
    if (memory != null) {
      return memory();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DatabaseConfig_Memory value) memory,
    required TResult Function(DatabaseConfig_Sqlite value) sqlite,
    required TResult Function(DatabaseConfig_Sled value) sled,
  }) {
    return memory(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DatabaseConfig_Memory value)? memory,
    TResult? Function(DatabaseConfig_Sqlite value)? sqlite,
    TResult? Function(DatabaseConfig_Sled value)? sled,
  }) {
    return memory?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DatabaseConfig_Memory value)? memory,
    TResult Function(DatabaseConfig_Sqlite value)? sqlite,
    TResult Function(DatabaseConfig_Sled value)? sled,
    required TResult orElse(),
  }) {
    if (memory != null) {
      return memory(this);
    }
    return orElse();
  }
}

abstract class DatabaseConfig_Memory implements DatabaseConfig {
  const factory DatabaseConfig_Memory() = _$DatabaseConfig_MemoryImpl;
}

/// @nodoc
abstract class _$$DatabaseConfig_SqliteImplCopyWith<$Res> {
  factory _$$DatabaseConfig_SqliteImplCopyWith(
          _$DatabaseConfig_SqliteImpl value,
          $Res Function(_$DatabaseConfig_SqliteImpl) then) =
      __$$DatabaseConfig_SqliteImplCopyWithImpl<$Res>;
  @useResult
  $Res call({SqliteDbConfiguration config});
}

/// @nodoc
class __$$DatabaseConfig_SqliteImplCopyWithImpl<$Res>
    extends _$DatabaseConfigCopyWithImpl<$Res, _$DatabaseConfig_SqliteImpl>
    implements _$$DatabaseConfig_SqliteImplCopyWith<$Res> {
  __$$DatabaseConfig_SqliteImplCopyWithImpl(_$DatabaseConfig_SqliteImpl _value,
      $Res Function(_$DatabaseConfig_SqliteImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? config = null,
  }) {
    return _then(_$DatabaseConfig_SqliteImpl(
      config: null == config
          ? _value.config
          : config // ignore: cast_nullable_to_non_nullable
              as SqliteDbConfiguration,
    ));
  }
}

/// @nodoc

class _$DatabaseConfig_SqliteImpl implements DatabaseConfig_Sqlite {
  const _$DatabaseConfig_SqliteImpl({required this.config});

  @override
  final SqliteDbConfiguration config;

  @override
  String toString() {
    return 'DatabaseConfig.sqlite(config: $config)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DatabaseConfig_SqliteImpl &&
            (identical(other.config, config) || other.config == config));
  }

  @override
  int get hashCode => Object.hash(runtimeType, config);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DatabaseConfig_SqliteImplCopyWith<_$DatabaseConfig_SqliteImpl>
      get copyWith => __$$DatabaseConfig_SqliteImplCopyWithImpl<
          _$DatabaseConfig_SqliteImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() memory,
    required TResult Function(SqliteDbConfiguration config) sqlite,
    required TResult Function(SledDbConfiguration config) sled,
  }) {
    return sqlite(config);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? memory,
    TResult? Function(SqliteDbConfiguration config)? sqlite,
    TResult? Function(SledDbConfiguration config)? sled,
  }) {
    return sqlite?.call(config);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? memory,
    TResult Function(SqliteDbConfiguration config)? sqlite,
    TResult Function(SledDbConfiguration config)? sled,
    required TResult orElse(),
  }) {
    if (sqlite != null) {
      return sqlite(config);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DatabaseConfig_Memory value) memory,
    required TResult Function(DatabaseConfig_Sqlite value) sqlite,
    required TResult Function(DatabaseConfig_Sled value) sled,
  }) {
    return sqlite(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DatabaseConfig_Memory value)? memory,
    TResult? Function(DatabaseConfig_Sqlite value)? sqlite,
    TResult? Function(DatabaseConfig_Sled value)? sled,
  }) {
    return sqlite?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DatabaseConfig_Memory value)? memory,
    TResult Function(DatabaseConfig_Sqlite value)? sqlite,
    TResult Function(DatabaseConfig_Sled value)? sled,
    required TResult orElse(),
  }) {
    if (sqlite != null) {
      return sqlite(this);
    }
    return orElse();
  }
}

abstract class DatabaseConfig_Sqlite implements DatabaseConfig {
  const factory DatabaseConfig_Sqlite(
          {required final SqliteDbConfiguration config}) =
      _$DatabaseConfig_SqliteImpl;

  SqliteDbConfiguration get config;
  @JsonKey(ignore: true)
  _$$DatabaseConfig_SqliteImplCopyWith<_$DatabaseConfig_SqliteImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DatabaseConfig_SledImplCopyWith<$Res> {
  factory _$$DatabaseConfig_SledImplCopyWith(_$DatabaseConfig_SledImpl value,
          $Res Function(_$DatabaseConfig_SledImpl) then) =
      __$$DatabaseConfig_SledImplCopyWithImpl<$Res>;
  @useResult
  $Res call({SledDbConfiguration config});
}

/// @nodoc
class __$$DatabaseConfig_SledImplCopyWithImpl<$Res>
    extends _$DatabaseConfigCopyWithImpl<$Res, _$DatabaseConfig_SledImpl>
    implements _$$DatabaseConfig_SledImplCopyWith<$Res> {
  __$$DatabaseConfig_SledImplCopyWithImpl(_$DatabaseConfig_SledImpl _value,
      $Res Function(_$DatabaseConfig_SledImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? config = null,
  }) {
    return _then(_$DatabaseConfig_SledImpl(
      config: null == config
          ? _value.config
          : config // ignore: cast_nullable_to_non_nullable
              as SledDbConfiguration,
    ));
  }
}

/// @nodoc

class _$DatabaseConfig_SledImpl implements DatabaseConfig_Sled {
  const _$DatabaseConfig_SledImpl({required this.config});

  @override
  final SledDbConfiguration config;

  @override
  String toString() {
    return 'DatabaseConfig.sled(config: $config)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DatabaseConfig_SledImpl &&
            (identical(other.config, config) || other.config == config));
  }

  @override
  int get hashCode => Object.hash(runtimeType, config);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DatabaseConfig_SledImplCopyWith<_$DatabaseConfig_SledImpl> get copyWith =>
      __$$DatabaseConfig_SledImplCopyWithImpl<_$DatabaseConfig_SledImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() memory,
    required TResult Function(SqliteDbConfiguration config) sqlite,
    required TResult Function(SledDbConfiguration config) sled,
  }) {
    return sled(config);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? memory,
    TResult? Function(SqliteDbConfiguration config)? sqlite,
    TResult? Function(SledDbConfiguration config)? sled,
  }) {
    return sled?.call(config);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? memory,
    TResult Function(SqliteDbConfiguration config)? sqlite,
    TResult Function(SledDbConfiguration config)? sled,
    required TResult orElse(),
  }) {
    if (sled != null) {
      return sled(config);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DatabaseConfig_Memory value) memory,
    required TResult Function(DatabaseConfig_Sqlite value) sqlite,
    required TResult Function(DatabaseConfig_Sled value) sled,
  }) {
    return sled(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DatabaseConfig_Memory value)? memory,
    TResult? Function(DatabaseConfig_Sqlite value)? sqlite,
    TResult? Function(DatabaseConfig_Sled value)? sled,
  }) {
    return sled?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DatabaseConfig_Memory value)? memory,
    TResult Function(DatabaseConfig_Sqlite value)? sqlite,
    TResult Function(DatabaseConfig_Sled value)? sled,
    required TResult orElse(),
  }) {
    if (sled != null) {
      return sled(this);
    }
    return orElse();
  }
}

abstract class DatabaseConfig_Sled implements DatabaseConfig {
  const factory DatabaseConfig_Sled(
      {required final SledDbConfiguration config}) = _$DatabaseConfig_SledImpl;

  SledDbConfiguration get config;
  @JsonKey(ignore: true)
  _$$DatabaseConfig_SledImplCopyWith<_$DatabaseConfig_SledImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Payload {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Uint8List pubkeyHash) pubkeyHash,
    required TResult Function(Uint8List scriptHash) scriptHash,
    required TResult Function(WitnessVersion version, Uint8List program)
        witnessProgram,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Uint8List pubkeyHash)? pubkeyHash,
    TResult? Function(Uint8List scriptHash)? scriptHash,
    TResult? Function(WitnessVersion version, Uint8List program)?
        witnessProgram,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Uint8List pubkeyHash)? pubkeyHash,
    TResult Function(Uint8List scriptHash)? scriptHash,
    TResult Function(WitnessVersion version, Uint8List program)? witnessProgram,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Payload_PubkeyHash value) pubkeyHash,
    required TResult Function(Payload_ScriptHash value) scriptHash,
    required TResult Function(Payload_WitnessProgram value) witnessProgram,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Payload_PubkeyHash value)? pubkeyHash,
    TResult? Function(Payload_ScriptHash value)? scriptHash,
    TResult? Function(Payload_WitnessProgram value)? witnessProgram,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Payload_PubkeyHash value)? pubkeyHash,
    TResult Function(Payload_ScriptHash value)? scriptHash,
    TResult Function(Payload_WitnessProgram value)? witnessProgram,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PayloadCopyWith<$Res> {
  factory $PayloadCopyWith(Payload value, $Res Function(Payload) then) =
      _$PayloadCopyWithImpl<$Res, Payload>;
}

/// @nodoc
class _$PayloadCopyWithImpl<$Res, $Val extends Payload>
    implements $PayloadCopyWith<$Res> {
  _$PayloadCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$Payload_PubkeyHashImplCopyWith<$Res> {
  factory _$$Payload_PubkeyHashImplCopyWith(_$Payload_PubkeyHashImpl value,
          $Res Function(_$Payload_PubkeyHashImpl) then) =
      __$$Payload_PubkeyHashImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Uint8List pubkeyHash});
}

/// @nodoc
class __$$Payload_PubkeyHashImplCopyWithImpl<$Res>
    extends _$PayloadCopyWithImpl<$Res, _$Payload_PubkeyHashImpl>
    implements _$$Payload_PubkeyHashImplCopyWith<$Res> {
  __$$Payload_PubkeyHashImplCopyWithImpl(_$Payload_PubkeyHashImpl _value,
      $Res Function(_$Payload_PubkeyHashImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? pubkeyHash = null,
  }) {
    return _then(_$Payload_PubkeyHashImpl(
      pubkeyHash: null == pubkeyHash
          ? _value.pubkeyHash
          : pubkeyHash // ignore: cast_nullable_to_non_nullable
              as Uint8List,
    ));
  }
}

/// @nodoc

class _$Payload_PubkeyHashImpl implements Payload_PubkeyHash {
  const _$Payload_PubkeyHashImpl({required this.pubkeyHash});

  @override
  final Uint8List pubkeyHash;

  @override
  String toString() {
    return 'Payload.pubkeyHash(pubkeyHash: $pubkeyHash)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Payload_PubkeyHashImpl &&
            const DeepCollectionEquality()
                .equals(other.pubkeyHash, pubkeyHash));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(pubkeyHash));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Payload_PubkeyHashImplCopyWith<_$Payload_PubkeyHashImpl> get copyWith =>
      __$$Payload_PubkeyHashImplCopyWithImpl<_$Payload_PubkeyHashImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Uint8List pubkeyHash) pubkeyHash,
    required TResult Function(Uint8List scriptHash) scriptHash,
    required TResult Function(WitnessVersion version, Uint8List program)
        witnessProgram,
  }) {
    return pubkeyHash(this.pubkeyHash);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Uint8List pubkeyHash)? pubkeyHash,
    TResult? Function(Uint8List scriptHash)? scriptHash,
    TResult? Function(WitnessVersion version, Uint8List program)?
        witnessProgram,
  }) {
    return pubkeyHash?.call(this.pubkeyHash);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Uint8List pubkeyHash)? pubkeyHash,
    TResult Function(Uint8List scriptHash)? scriptHash,
    TResult Function(WitnessVersion version, Uint8List program)? witnessProgram,
    required TResult orElse(),
  }) {
    if (pubkeyHash != null) {
      return pubkeyHash(this.pubkeyHash);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Payload_PubkeyHash value) pubkeyHash,
    required TResult Function(Payload_ScriptHash value) scriptHash,
    required TResult Function(Payload_WitnessProgram value) witnessProgram,
  }) {
    return pubkeyHash(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Payload_PubkeyHash value)? pubkeyHash,
    TResult? Function(Payload_ScriptHash value)? scriptHash,
    TResult? Function(Payload_WitnessProgram value)? witnessProgram,
  }) {
    return pubkeyHash?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Payload_PubkeyHash value)? pubkeyHash,
    TResult Function(Payload_ScriptHash value)? scriptHash,
    TResult Function(Payload_WitnessProgram value)? witnessProgram,
    required TResult orElse(),
  }) {
    if (pubkeyHash != null) {
      return pubkeyHash(this);
    }
    return orElse();
  }
}

abstract class Payload_PubkeyHash implements Payload {
  const factory Payload_PubkeyHash({required final Uint8List pubkeyHash}) =
      _$Payload_PubkeyHashImpl;

  Uint8List get pubkeyHash;
  @JsonKey(ignore: true)
  _$$Payload_PubkeyHashImplCopyWith<_$Payload_PubkeyHashImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Payload_ScriptHashImplCopyWith<$Res> {
  factory _$$Payload_ScriptHashImplCopyWith(_$Payload_ScriptHashImpl value,
          $Res Function(_$Payload_ScriptHashImpl) then) =
      __$$Payload_ScriptHashImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Uint8List scriptHash});
}

/// @nodoc
class __$$Payload_ScriptHashImplCopyWithImpl<$Res>
    extends _$PayloadCopyWithImpl<$Res, _$Payload_ScriptHashImpl>
    implements _$$Payload_ScriptHashImplCopyWith<$Res> {
  __$$Payload_ScriptHashImplCopyWithImpl(_$Payload_ScriptHashImpl _value,
      $Res Function(_$Payload_ScriptHashImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? scriptHash = null,
  }) {
    return _then(_$Payload_ScriptHashImpl(
      scriptHash: null == scriptHash
          ? _value.scriptHash
          : scriptHash // ignore: cast_nullable_to_non_nullable
              as Uint8List,
    ));
  }
}

/// @nodoc

class _$Payload_ScriptHashImpl implements Payload_ScriptHash {
  const _$Payload_ScriptHashImpl({required this.scriptHash});

  @override
  final Uint8List scriptHash;

  @override
  String toString() {
    return 'Payload.scriptHash(scriptHash: $scriptHash)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Payload_ScriptHashImpl &&
            const DeepCollectionEquality()
                .equals(other.scriptHash, scriptHash));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(scriptHash));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Payload_ScriptHashImplCopyWith<_$Payload_ScriptHashImpl> get copyWith =>
      __$$Payload_ScriptHashImplCopyWithImpl<_$Payload_ScriptHashImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Uint8List pubkeyHash) pubkeyHash,
    required TResult Function(Uint8List scriptHash) scriptHash,
    required TResult Function(WitnessVersion version, Uint8List program)
        witnessProgram,
  }) {
    return scriptHash(this.scriptHash);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Uint8List pubkeyHash)? pubkeyHash,
    TResult? Function(Uint8List scriptHash)? scriptHash,
    TResult? Function(WitnessVersion version, Uint8List program)?
        witnessProgram,
  }) {
    return scriptHash?.call(this.scriptHash);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Uint8List pubkeyHash)? pubkeyHash,
    TResult Function(Uint8List scriptHash)? scriptHash,
    TResult Function(WitnessVersion version, Uint8List program)? witnessProgram,
    required TResult orElse(),
  }) {
    if (scriptHash != null) {
      return scriptHash(this.scriptHash);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Payload_PubkeyHash value) pubkeyHash,
    required TResult Function(Payload_ScriptHash value) scriptHash,
    required TResult Function(Payload_WitnessProgram value) witnessProgram,
  }) {
    return scriptHash(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Payload_PubkeyHash value)? pubkeyHash,
    TResult? Function(Payload_ScriptHash value)? scriptHash,
    TResult? Function(Payload_WitnessProgram value)? witnessProgram,
  }) {
    return scriptHash?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Payload_PubkeyHash value)? pubkeyHash,
    TResult Function(Payload_ScriptHash value)? scriptHash,
    TResult Function(Payload_WitnessProgram value)? witnessProgram,
    required TResult orElse(),
  }) {
    if (scriptHash != null) {
      return scriptHash(this);
    }
    return orElse();
  }
}

abstract class Payload_ScriptHash implements Payload {
  const factory Payload_ScriptHash({required final Uint8List scriptHash}) =
      _$Payload_ScriptHashImpl;

  Uint8List get scriptHash;
  @JsonKey(ignore: true)
  _$$Payload_ScriptHashImplCopyWith<_$Payload_ScriptHashImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Payload_WitnessProgramImplCopyWith<$Res> {
  factory _$$Payload_WitnessProgramImplCopyWith(
          _$Payload_WitnessProgramImpl value,
          $Res Function(_$Payload_WitnessProgramImpl) then) =
      __$$Payload_WitnessProgramImplCopyWithImpl<$Res>;
  @useResult
  $Res call({WitnessVersion version, Uint8List program});
}

/// @nodoc
class __$$Payload_WitnessProgramImplCopyWithImpl<$Res>
    extends _$PayloadCopyWithImpl<$Res, _$Payload_WitnessProgramImpl>
    implements _$$Payload_WitnessProgramImplCopyWith<$Res> {
  __$$Payload_WitnessProgramImplCopyWithImpl(
      _$Payload_WitnessProgramImpl _value,
      $Res Function(_$Payload_WitnessProgramImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? version = null,
    Object? program = null,
  }) {
    return _then(_$Payload_WitnessProgramImpl(
      version: null == version
          ? _value.version
          : version // ignore: cast_nullable_to_non_nullable
              as WitnessVersion,
      program: null == program
          ? _value.program
          : program // ignore: cast_nullable_to_non_nullable
              as Uint8List,
    ));
  }
}

/// @nodoc

class _$Payload_WitnessProgramImpl implements Payload_WitnessProgram {
  const _$Payload_WitnessProgramImpl(
      {required this.version, required this.program});

  /// The witness program version.
  @override
  final WitnessVersion version;

  /// The witness program.
  @override
  final Uint8List program;

  @override
  String toString() {
    return 'Payload.witnessProgram(version: $version, program: $program)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Payload_WitnessProgramImpl &&
            (identical(other.version, version) || other.version == version) &&
            const DeepCollectionEquality().equals(other.program, program));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, version, const DeepCollectionEquality().hash(program));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Payload_WitnessProgramImplCopyWith<_$Payload_WitnessProgramImpl>
      get copyWith => __$$Payload_WitnessProgramImplCopyWithImpl<
          _$Payload_WitnessProgramImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Uint8List pubkeyHash) pubkeyHash,
    required TResult Function(Uint8List scriptHash) scriptHash,
    required TResult Function(WitnessVersion version, Uint8List program)
        witnessProgram,
  }) {
    return witnessProgram(version, program);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Uint8List pubkeyHash)? pubkeyHash,
    TResult? Function(Uint8List scriptHash)? scriptHash,
    TResult? Function(WitnessVersion version, Uint8List program)?
        witnessProgram,
  }) {
    return witnessProgram?.call(version, program);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Uint8List pubkeyHash)? pubkeyHash,
    TResult Function(Uint8List scriptHash)? scriptHash,
    TResult Function(WitnessVersion version, Uint8List program)? witnessProgram,
    required TResult orElse(),
  }) {
    if (witnessProgram != null) {
      return witnessProgram(version, program);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Payload_PubkeyHash value) pubkeyHash,
    required TResult Function(Payload_ScriptHash value) scriptHash,
    required TResult Function(Payload_WitnessProgram value) witnessProgram,
  }) {
    return witnessProgram(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Payload_PubkeyHash value)? pubkeyHash,
    TResult? Function(Payload_ScriptHash value)? scriptHash,
    TResult? Function(Payload_WitnessProgram value)? witnessProgram,
  }) {
    return witnessProgram?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Payload_PubkeyHash value)? pubkeyHash,
    TResult Function(Payload_ScriptHash value)? scriptHash,
    TResult Function(Payload_WitnessProgram value)? witnessProgram,
    required TResult orElse(),
  }) {
    if (witnessProgram != null) {
      return witnessProgram(this);
    }
    return orElse();
  }
}

abstract class Payload_WitnessProgram implements Payload {
  const factory Payload_WitnessProgram(
      {required final WitnessVersion version,
      required final Uint8List program}) = _$Payload_WitnessProgramImpl;

  /// The witness program version.
  WitnessVersion get version;

  /// The witness program.
  Uint8List get program;
  @JsonKey(ignore: true)
  _$$Payload_WitnessProgramImplCopyWith<_$Payload_WitnessProgramImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$RbfValue {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() rbfDefault,
    required TResult Function(int field0) value,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? rbfDefault,
    TResult? Function(int field0)? value,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? rbfDefault,
    TResult Function(int field0)? value,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RbfValue_RbfDefault value) rbfDefault,
    required TResult Function(RbfValue_Value value) value,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RbfValue_RbfDefault value)? rbfDefault,
    TResult? Function(RbfValue_Value value)? value,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RbfValue_RbfDefault value)? rbfDefault,
    TResult Function(RbfValue_Value value)? value,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RbfValueCopyWith<$Res> {
  factory $RbfValueCopyWith(RbfValue value, $Res Function(RbfValue) then) =
      _$RbfValueCopyWithImpl<$Res, RbfValue>;
}

/// @nodoc
class _$RbfValueCopyWithImpl<$Res, $Val extends RbfValue>
    implements $RbfValueCopyWith<$Res> {
  _$RbfValueCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$RbfValue_RbfDefaultImplCopyWith<$Res> {
  factory _$$RbfValue_RbfDefaultImplCopyWith(_$RbfValue_RbfDefaultImpl value,
          $Res Function(_$RbfValue_RbfDefaultImpl) then) =
      __$$RbfValue_RbfDefaultImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$RbfValue_RbfDefaultImplCopyWithImpl<$Res>
    extends _$RbfValueCopyWithImpl<$Res, _$RbfValue_RbfDefaultImpl>
    implements _$$RbfValue_RbfDefaultImplCopyWith<$Res> {
  __$$RbfValue_RbfDefaultImplCopyWithImpl(_$RbfValue_RbfDefaultImpl _value,
      $Res Function(_$RbfValue_RbfDefaultImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$RbfValue_RbfDefaultImpl implements RbfValue_RbfDefault {
  const _$RbfValue_RbfDefaultImpl();

  @override
  String toString() {
    return 'RbfValue.rbfDefault()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RbfValue_RbfDefaultImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() rbfDefault,
    required TResult Function(int field0) value,
  }) {
    return rbfDefault();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? rbfDefault,
    TResult? Function(int field0)? value,
  }) {
    return rbfDefault?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? rbfDefault,
    TResult Function(int field0)? value,
    required TResult orElse(),
  }) {
    if (rbfDefault != null) {
      return rbfDefault();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RbfValue_RbfDefault value) rbfDefault,
    required TResult Function(RbfValue_Value value) value,
  }) {
    return rbfDefault(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RbfValue_RbfDefault value)? rbfDefault,
    TResult? Function(RbfValue_Value value)? value,
  }) {
    return rbfDefault?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RbfValue_RbfDefault value)? rbfDefault,
    TResult Function(RbfValue_Value value)? value,
    required TResult orElse(),
  }) {
    if (rbfDefault != null) {
      return rbfDefault(this);
    }
    return orElse();
  }
}

abstract class RbfValue_RbfDefault implements RbfValue {
  const factory RbfValue_RbfDefault() = _$RbfValue_RbfDefaultImpl;
}

/// @nodoc
abstract class _$$RbfValue_ValueImplCopyWith<$Res> {
  factory _$$RbfValue_ValueImplCopyWith(_$RbfValue_ValueImpl value,
          $Res Function(_$RbfValue_ValueImpl) then) =
      __$$RbfValue_ValueImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$RbfValue_ValueImplCopyWithImpl<$Res>
    extends _$RbfValueCopyWithImpl<$Res, _$RbfValue_ValueImpl>
    implements _$$RbfValue_ValueImplCopyWith<$Res> {
  __$$RbfValue_ValueImplCopyWithImpl(
      _$RbfValue_ValueImpl _value, $Res Function(_$RbfValue_ValueImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$RbfValue_ValueImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$RbfValue_ValueImpl implements RbfValue_Value {
  const _$RbfValue_ValueImpl(this.field0);

  @override
  final int field0;

  @override
  String toString() {
    return 'RbfValue.value(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RbfValue_ValueImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RbfValue_ValueImplCopyWith<_$RbfValue_ValueImpl> get copyWith =>
      __$$RbfValue_ValueImplCopyWithImpl<_$RbfValue_ValueImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() rbfDefault,
    required TResult Function(int field0) value,
  }) {
    return value(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? rbfDefault,
    TResult? Function(int field0)? value,
  }) {
    return value?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? rbfDefault,
    TResult Function(int field0)? value,
    required TResult orElse(),
  }) {
    if (value != null) {
      return value(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RbfValue_RbfDefault value) rbfDefault,
    required TResult Function(RbfValue_Value value) value,
  }) {
    return value(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RbfValue_RbfDefault value)? rbfDefault,
    TResult? Function(RbfValue_Value value)? value,
  }) {
    return value?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RbfValue_RbfDefault value)? rbfDefault,
    TResult Function(RbfValue_Value value)? value,
    required TResult orElse(),
  }) {
    if (value != null) {
      return value(this);
    }
    return orElse();
  }
}

abstract class RbfValue_Value implements RbfValue {
  const factory RbfValue_Value(final int field0) = _$RbfValue_ValueImpl;

  int get field0;
  @JsonKey(ignore: true)
  _$$RbfValue_ValueImplCopyWith<_$RbfValue_ValueImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
