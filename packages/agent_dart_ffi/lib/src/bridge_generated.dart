// AUTO GENERATED FILE, DO NOT EDIT.
// Generated by `flutter_rust_bridge`@ 1.78.0.
// ignore_for_file: non_constant_identifier_names, unused_element, duplicate_ignore, directives_ordering, curly_braces_in_flow_control_structures, unnecessary_lambdas, slash_for_doc_comments, prefer_const_literals_to_create_immutables, implicit_dynamic_list_literal, duplicate_import, unused_import, unnecessary_import, prefer_single_quotes, prefer_const_constructors, use_super_parameters, always_use_package_imports, annotate_overrides, invalid_use_of_protected_member, constant_identifier_names, invalid_use_of_internal_member, prefer_is_empty, unnecessary_const

import 'dart:convert';
import 'dart:async';
import 'package:meta/meta.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge.dart';
import 'package:uuid/uuid.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;

import 'dart:convert';
import 'dart:async';
import 'package:meta/meta.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge.dart';
import 'package:uuid/uuid.dart';
import 'bridge_generated.io.dart' if (dart.library.html) 'bridge_generated.web.dart';

part 'bridge_generated.freezed.dart';

abstract class AgentDart {
  /// --------------------
  /// mnemonic
  /// --------------------
  /// create_phrase
  /// phrase_to_seed
  /// seed_to_key
  Future<Uint8List> mnemonicPhraseToSeed({required PhraseToSeedReq req, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kMnemonicPhraseToSeedConstMeta;

  Future<Uint8List> mnemonicSeedToKey({required SeedToKeyReq req, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kMnemonicSeedToKeyConstMeta;

  /// --------------------
  /// bls
  /// --------------------
  /// bls_init
  /// bls_verify
  Future<bool> blsInit({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kBlsInitConstMeta;

  Future<bool> blsVerify({required BLSVerifyReq req, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kBlsVerifyConstMeta;

  /// --------------
  /// ed25519
  /// --------------------
  /// ed25519_from_seed
  /// ed25519_sign
  /// ed25519_verify
  Future<ED25519Res> ed25519FromSeed({required ED25519FromSeedReq req, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kEd25519FromSeedConstMeta;

  Future<Uint8List> ed25519Sign({required ED25519SignReq req, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kEd25519SignConstMeta;

  Future<bool> ed25519Verify({required ED25519VerifyReq req, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kEd25519VerifyConstMeta;

  /// ---------------------
  /// secp256k1
  /// ---------------------
  Future<Secp256k1IdentityExport> secp256K1FromSeed({required Secp256k1FromSeedReq req, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSecp256K1FromSeedConstMeta;

  Future<SignatureFFI> secp256K1Sign({required Secp256k1SignWithSeedReq req, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSecp256K1SignConstMeta;

  Future<SignatureFFI> secp256K1SignWithRng({required Secp256k1SignWithRngReq req, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSecp256K1SignWithRngConstMeta;

  Future<SignatureFFI> secp256K1SignRecoverable({required Secp256k1SignWithSeedReq req, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSecp256K1SignRecoverableConstMeta;

  Future<bool> secp256K1Verify({required Secp256k1VerifyReq req, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSecp256K1VerifyConstMeta;

  Future<Uint8List> secp256K1GetSharedSecret({required Secp256k1ShareSecretReq req, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSecp256K1GetSharedSecretConstMeta;

  Future<Uint8List> secp256K1Recover({required Secp256k1RecoverReq req, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSecp256K1RecoverConstMeta;

  /// ---------------------
  /// secp256k1
  /// ---------------------
  Future<P256IdentityExport> p256FromSeed({required P256FromSeedReq req, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kP256FromSeedConstMeta;

  Future<SignatureFFI> p256Sign({required P256SignWithSeedReq req, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kP256SignConstMeta;

  Future<bool> p256Verify({required P256VerifyReq req, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kP256VerifyConstMeta;

  Future<Uint8List> p256GetSharedSecret({required P256ShareSecretReq req, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kP256GetSharedSecretConstMeta;

  /// ---------------------
  /// schnorr
  /// ---------------------
  Future<SchnorrIdentityExport> schnorrFromSeed({required SchnorrFromSeedReq req, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSchnorrFromSeedConstMeta;

  Future<SignatureFFI> schnorrSign({required SchnorrSignWithSeedReq req, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSchnorrSignConstMeta;

  Future<bool> schnorrVerify({required SchnorrVerifyReq req, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSchnorrVerifyConstMeta;

  /// ---------------------
  /// aes
  /// ---------------------
  Future<Uint8List> aes128CtrEncrypt({required AesEncryptReq req, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kAes128CtrEncryptConstMeta;

  Future<Uint8List> aes128CtrDecrypt({required AesDecryptReq req, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kAes128CtrDecryptConstMeta;

  Future<Uint8List> aes256CbcEncrypt({required AesEncryptReq req, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kAes256CbcEncryptConstMeta;

  Future<Uint8List> aes256CbcDecrypt({required AesDecryptReq req, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kAes256CbcDecryptConstMeta;

  Future<Uint8List> aes256GcmEncrypt({required AesEncryptReq req, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kAes256GcmEncryptConstMeta;

  Future<Uint8List> aes256GcmDecrypt({required AesDecryptReq req, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kAes256GcmDecryptConstMeta;

  Future<KeyDerivedRes> pbkdf2DeriveKey({required PBKDFDeriveReq req, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kPbkdf2DeriveKeyConstMeta;

  Future<KeyDerivedRes> scryptDeriveKey({required ScriptDeriveReq req, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kScryptDeriveKeyConstMeta;

  Future<BlockchainInstance> createBlockchainStaticMethodApi({required BlockchainConfig config, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kCreateBlockchainStaticMethodApiConstMeta;

  Future<int> getHeightStaticMethodApi({required BlockchainInstance blockchain, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetHeightStaticMethodApiConstMeta;

  Future<String> getBlockchainHashStaticMethodApi({required int blockchainHeight, required BlockchainInstance blockchain, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetBlockchainHashStaticMethodApiConstMeta;

  Future<double> estimateFeeStaticMethodApi({required int target, required BlockchainInstance blockchain, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kEstimateFeeStaticMethodApiConstMeta;

  Future<String> broadcastStaticMethodApi({required String tx, required BlockchainInstance blockchain, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kBroadcastStaticMethodApiConstMeta;

  Future<String> getTxStaticMethodApi({required String tx, required BlockchainInstance blockchain, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetTxStaticMethodApiConstMeta;

  Future<String> createTransactionStaticMethodApi({required Uint8List tx, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kCreateTransactionStaticMethodApiConstMeta;

  Future<String> txTxidStaticMethodApi({required String tx, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kTxTxidStaticMethodApiConstMeta;

  Future<int> weightStaticMethodApi({required String tx, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kWeightStaticMethodApiConstMeta;

  Future<int> sizeStaticMethodApi({required String tx, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSizeStaticMethodApiConstMeta;

  Future<int> vsizeStaticMethodApi({required String tx, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kVsizeStaticMethodApiConstMeta;

  Future<Uint8List> serializeTxStaticMethodApi({required String tx, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSerializeTxStaticMethodApiConstMeta;

  Future<bool> isCoinBaseStaticMethodApi({required String tx, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kIsCoinBaseStaticMethodApiConstMeta;

  Future<bool> isExplicitlyRbfStaticMethodApi({required String tx, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kIsExplicitlyRbfStaticMethodApiConstMeta;

  Future<bool> isLockTimeEnabledStaticMethodApi({required String tx, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kIsLockTimeEnabledStaticMethodApiConstMeta;

  Future<int> versionStaticMethodApi({required String tx, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kVersionStaticMethodApiConstMeta;

  Future<int> lockTimeStaticMethodApi({required String tx, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kLockTimeStaticMethodApiConstMeta;

  Future<List<TxIn>> inputStaticMethodApi({required String tx, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kInputStaticMethodApiConstMeta;

  Future<List<TxOut>> outputStaticMethodApi({required String tx, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kOutputStaticMethodApiConstMeta;

  Future<String> serializePsbtStaticMethodApi({required String psbtStr, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSerializePsbtStaticMethodApiConstMeta;

  Future<String> psbtTxidStaticMethodApi({required String psbtStr, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kPsbtTxidStaticMethodApiConstMeta;

  Future<String> extractTxStaticMethodApi({required String psbtStr, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kExtractTxStaticMethodApiConstMeta;

  Future<double?> psbtFeeRateStaticMethodApi({required String psbtStr, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kPsbtFeeRateStaticMethodApiConstMeta;

  Future<int?> psbtFeeAmountStaticMethodApi({required String psbtStr, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kPsbtFeeAmountStaticMethodApiConstMeta;

  Future<String> combinePsbtStaticMethodApi({required String psbtStr, required String other, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kCombinePsbtStaticMethodApiConstMeta;

  Future<String> jsonSerializeStaticMethodApi({required String psbtStr, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kJsonSerializeStaticMethodApiConstMeta;

  Future<List<TxOut>> getInputsStaticMethodApi({required String psbtStr, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetInputsStaticMethodApiConstMeta;

  Future<BdkTxBuilderResult> txBuilderFinishStaticMethodApi({required WalletInstance wallet, required List<ScriptAmount> recipients, required List<TxBytes> txs, required List<OutPoint> unspendable, required List<ForeignUtxo> foreignUtxos, required ChangeSpendPolicy changePolicy, required bool manuallySelectedOnly, double? feeRate, int? feeAbsolute, required bool drainWallet, Script? drainTo, RbfValue? rbf, required Uint8List data, bool? shuffleUtxo, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kTxBuilderFinishStaticMethodApiConstMeta;

  Future<int> txCalFeeFinishStaticMethodApi({required WalletInstance wallet, required List<ScriptAmount> recipients, required List<TxBytes> txs, required List<OutPoint> unspendable, required List<ForeignUtxo> foreignUtxos, required ChangeSpendPolicy changePolicy, required bool manuallySelectedOnly, double? feeRate, int? feeAbsolute, required bool drainWallet, Script? drainTo, RbfValue? rbf, required Uint8List data, bool? shuffleUtxo, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kTxCalFeeFinishStaticMethodApiConstMeta;

  Future<BdkTxBuilderResult> bumpFeeTxBuilderFinishStaticMethodApi({required String txid, required double feeRate, String? allowShrinking, required WalletInstance wallet, required bool enableRbf, required bool keepChange, int? nSequence, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kBumpFeeTxBuilderFinishStaticMethodApiConstMeta;

  Future<BdkDescriptor> createDescriptorStaticMethodApi({required String descriptor, required Network network, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kCreateDescriptorStaticMethodApiConstMeta;

  Future<BdkDescriptor> importSingleWifStaticMethodApi({required String wif, required String addressType, required Network network, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kImportSingleWifStaticMethodApiConstMeta;

  Future<BdkDescriptor> newBip44DescriptorStaticMethodApi({required KeychainKind keyChainKind, required String secretKey, required Network network, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kNewBip44DescriptorStaticMethodApiConstMeta;

  Future<BdkDescriptor> newBip44PublicStaticMethodApi({required KeychainKind keyChainKind, required String publicKey, required Network network, required String fingerprint, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kNewBip44PublicStaticMethodApiConstMeta;

  Future<BdkDescriptor> newBip44TrDescriptorStaticMethodApi({required KeychainKind keyChainKind, required String secretKey, required Network network, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kNewBip44TrDescriptorStaticMethodApiConstMeta;

  Future<BdkDescriptor> newBip44TrPublicStaticMethodApi({required KeychainKind keyChainKind, required String publicKey, required Network network, required String fingerprint, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kNewBip44TrPublicStaticMethodApiConstMeta;

  Future<BdkDescriptor> newBip49DescriptorStaticMethodApi({required KeychainKind keyChainKind, required String secretKey, required Network network, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kNewBip49DescriptorStaticMethodApiConstMeta;

  Future<BdkDescriptor> newBip49PublicStaticMethodApi({required KeychainKind keyChainKind, required String publicKey, required Network network, required String fingerprint, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kNewBip49PublicStaticMethodApiConstMeta;

  Future<BdkDescriptor> newBip84DescriptorStaticMethodApi({required KeychainKind keyChainKind, required String secretKey, required Network network, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kNewBip84DescriptorStaticMethodApiConstMeta;

  Future<BdkDescriptor> newBip84PublicStaticMethodApi({required KeychainKind keyChainKind, required String publicKey, required Network network, required String fingerprint, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kNewBip84PublicStaticMethodApiConstMeta;

  Future<BdkDescriptor> newBip86DescriptorStaticMethodApi({required KeychainKind keyChainKind, required String secretKey, required Network network, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kNewBip86DescriptorStaticMethodApiConstMeta;

  Future<BdkDescriptor> newBip86PublicStaticMethodApi({required KeychainKind keyChainKind, required String publicKey, required Network network, required String fingerprint, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kNewBip86PublicStaticMethodApiConstMeta;

  Future<String> asStringPrivateStaticMethodApi({required BdkDescriptor descriptor, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kAsStringPrivateStaticMethodApiConstMeta;

  Future<String> asStringStaticMethodApi({required BdkDescriptor descriptor, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kAsStringStaticMethodApiConstMeta;

  Future<AddressInfo> deriveAddressAtStaticMethodApi({required BdkDescriptor descriptor, required int index, required Network network, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kDeriveAddressAtStaticMethodApiConstMeta;

  Future<String> createDescriptorSecretStaticMethodApi({required Network network, required String mnemonic, String? password, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kCreateDescriptorSecretStaticMethodApiConstMeta;

  Future<String> createDerivedDescriptorSecretStaticMethodApi({required Network network, required String mnemonic, required String path, String? password, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kCreateDerivedDescriptorSecretStaticMethodApiConstMeta;

  Future<String> descriptorSecretFromStringStaticMethodApi({required String secret, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kDescriptorSecretFromStringStaticMethodApiConstMeta;

  Future<String> extendDescriptorSecretStaticMethodApi({required String secret, required String path, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kExtendDescriptorSecretStaticMethodApiConstMeta;

  Future<String> deriveDescriptorSecretStaticMethodApi({required String secret, required String path, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kDeriveDescriptorSecretStaticMethodApiConstMeta;

  Future<Uint8List> asSecretBytesStaticMethodApi({required String secret, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kAsSecretBytesStaticMethodApiConstMeta;

  Future<String> asPublicStaticMethodApi({required String secret, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kAsPublicStaticMethodApiConstMeta;

  Future<String> getPubFromSecretBytesStaticMethodApi({required Uint8List bytes, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetPubFromSecretBytesStaticMethodApiConstMeta;

  Future<String> createDerivationPathStaticMethodApi({required String path, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kCreateDerivationPathStaticMethodApiConstMeta;

  Future<String> descriptorPublicFromStringStaticMethodApi({required String publicKey, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kDescriptorPublicFromStringStaticMethodApiConstMeta;

  Future<String> masterFinterprintStaticMethodApi({required String xpub, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kMasterFinterprintStaticMethodApiConstMeta;

  Future<String> createDescriptorPublicStaticMethodApi({String? xpub, required String path, required bool derive, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kCreateDescriptorPublicStaticMethodApiConstMeta;

  Future<String> toPublicStringStaticMethodApi({required String xpub, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kToPublicStringStaticMethodApiConstMeta;

  Future<Script> createScriptStaticMethodApi({required Uint8List rawOutputScript, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kCreateScriptStaticMethodApiConstMeta;

  Future<String> createAddressStaticMethodApi({required String address, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kCreateAddressStaticMethodApiConstMeta;

  Future<String> addressFromScriptStaticMethodApi({required Script script, required Network network, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kAddressFromScriptStaticMethodApiConstMeta;

  Future<Script> addressToScriptPubkeyStaticMethodApi({required String address, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kAddressToScriptPubkeyStaticMethodApiConstMeta;

  Future<Payload> payloadStaticMethodApi({required String address, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kPayloadStaticMethodApiConstMeta;

  Future<Network> addressNetworkStaticMethodApi({required String address, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kAddressNetworkStaticMethodApiConstMeta;

  Future<String> getAddressTypeStaticMethodApi({required String address, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetAddressTypeStaticMethodApiConstMeta;

  Future<WalletInstance> createWalletStaticMethodApi({required BdkDescriptor descriptor, BdkDescriptor? changeDescriptor, required Network network, required DatabaseConfig databaseConfig, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kCreateWalletStaticMethodApiConstMeta;

  Future<AddressInfo> getAddressStaticMethodApi({required WalletInstance wallet, required AddressIndex addressIndex, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetAddressStaticMethodApiConstMeta;

  Future<AddressInfo> getInternalAddressStaticMethodApi({required WalletInstance wallet, required AddressIndex addressIndex, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetInternalAddressStaticMethodApiConstMeta;

  Future<void> syncWalletStaticMethodApi({required WalletInstance wallet, required BlockchainInstance blockchain, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSyncWalletStaticMethodApiConstMeta;

  Future<void> syncWalletThreadStaticMethodApi({required WalletInstance wallet, required BlockchainInstance blockchain, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSyncWalletThreadStaticMethodApiConstMeta;

  Future<Balance> getBalanceStaticMethodApi({required WalletInstance wallet, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetBalanceStaticMethodApiConstMeta;

  Future<List<LocalUtxo>> listUnspentOutputsStaticMethodApi({required WalletInstance wallet, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kListUnspentOutputsStaticMethodApiConstMeta;

  Future<List<TransactionDetails>> getTransactionsStaticMethodApi({required WalletInstance wallet, required bool includeRaw, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetTransactionsStaticMethodApiConstMeta;

  Future<String?> signStaticMethodApi({required WalletInstance wallet, required String psbtStr, SignOptions? signOptions, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSignStaticMethodApiConstMeta;

  Future<Network> walletNetworkStaticMethodApi({required WalletInstance wallet, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kWalletNetworkStaticMethodApiConstMeta;

  Future<List<LocalUtxo>> listUnspentStaticMethodApi({required WalletInstance wallet, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kListUnspentStaticMethodApiConstMeta;

  Future<bool> cacheAddressStaticMethodApi({required WalletInstance wallet, required int cacheSize, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kCacheAddressStaticMethodApiConstMeta;

  Future<String> generateSeedFromWordCountStaticMethodApi({required WordCount wordCount, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGenerateSeedFromWordCountStaticMethodApiConstMeta;

  Future<String> generateSeedFromStringStaticMethodApi({required String mnemonic, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGenerateSeedFromStringStaticMethodApiConstMeta;

  Future<String> generateSeedFromEntropyStaticMethodApi({required Uint8List entropy, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGenerateSeedFromEntropyStaticMethodApiConstMeta;

  Future<String> bip322SignSegwitStaticMethodApi({required Uint8List secret, required String message, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kBip322SignSegwitStaticMethodApiConstMeta;

  Future<String> bip322SignTaprootStaticMethodApi({required Uint8List secret, required String message, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kBip322SignTaprootStaticMethodApiConstMeta;

  DropFnType get dropOpaqueBdkDescriptor;
  ShareFnType get shareOpaqueBdkDescriptor;
  OpaqueTypeFinalizer get BdkDescriptorFinalizer;

  DropFnType get dropOpaqueBlockchainInstance;
  ShareFnType get shareOpaqueBlockchainInstance;
  OpaqueTypeFinalizer get BlockchainInstanceFinalizer;

  DropFnType get dropOpaqueWalletInstance;
  ShareFnType get shareOpaqueWalletInstance;
  OpaqueTypeFinalizer get WalletInstanceFinalizer;
}

@sealed
class BdkDescriptor extends FrbOpaque {
  final AgentDart bridge;
  BdkDescriptor.fromRaw(int ptr, int size, this.bridge) : super.unsafe(ptr, size);
  @override
  DropFnType get dropFn => bridge.dropOpaqueBdkDescriptor;

  @override
  ShareFnType get shareFn => bridge.shareOpaqueBdkDescriptor;

  @override
  OpaqueTypeFinalizer get staticFinalizer => bridge.BdkDescriptorFinalizer;
}

@sealed
class BlockchainInstance extends FrbOpaque {
  final AgentDart bridge;
  BlockchainInstance.fromRaw(int ptr, int size, this.bridge) : super.unsafe(ptr, size);
  @override
  DropFnType get dropFn => bridge.dropOpaqueBlockchainInstance;

  @override
  ShareFnType get shareFn => bridge.shareOpaqueBlockchainInstance;

  @override
  OpaqueTypeFinalizer get staticFinalizer => bridge.BlockchainInstanceFinalizer;
}

@sealed
class WalletInstance extends FrbOpaque {
  final AgentDart bridge;
  WalletInstance.fromRaw(int ptr, int size, this.bridge) : super.unsafe(ptr, size);
  @override
  DropFnType get dropFn => bridge.dropOpaqueWalletInstance;

  @override
  ShareFnType get shareFn => bridge.shareOpaqueWalletInstance;

  @override
  OpaqueTypeFinalizer get staticFinalizer => bridge.WalletInstanceFinalizer;
}

@freezed
class AddressIndex with _$AddressIndex {
  ///Return a new address after incrementing the current descriptor index.
  const factory AddressIndex.new() = AddressIndex_New;

  ///Return the address for the current descriptor index if it has not been used in a received transaction. Otherwise return a new address as with AddressIndex.New.
  ///Use with caution, if the wallet has not yet detected an address has been used it could return an already used address. This function is primarily meant for situations where the caller is untrusted; for example when deriving donation addresses on-demand for a public web page.
  const factory AddressIndex.lastUnused() = AddressIndex_LastUnused;

  /// Return the address for a specific descriptor index. Does not change the current descriptor
  /// index used by `AddressIndex` and `AddressIndex.LastUsed`.
  /// Use with caution, if an index is given that is less than the current descriptor index
  /// then the returned address may have already been used.
  const factory AddressIndex.peek({
    required int index,
  }) = AddressIndex_Peek;

  /// Return the address for a specific descriptor index and reset the current descriptor index
  /// used by `AddressIndex` and `AddressIndex.LastUsed` to this value.
  /// Use with caution, if an index is given that is less than the current descriptor index
  /// then the returned address and subsequent addresses returned by calls to `AddressIndex`
  /// and `AddressIndex.LastUsed` may have already been used. Also if the index is reset to a
  /// value earlier than the Blockchain stopGap (default is 20) then a
  /// larger stopGap should be used to monitor for all possibly used addresses.
  const factory AddressIndex.reset({
    required int index,
  }) = AddressIndex_Reset;
}

///A derived address and the index it was found at For convenience this automatically derefs to Address
class AddressInfo {
  ///Child index of this address
  final int index;

  /// Address
  final String address;

  const AddressInfo({
    required this.index,
    required this.address,
  });
}

class AesDecryptReq {
  final Uint8List key;
  final Uint8List iv;
  final Uint8List cipherText;

  const AesDecryptReq({
    required this.key,
    required this.iv,
    required this.cipherText,
  });
}

class AesEncryptReq {
  final Uint8List key;
  final Uint8List iv;
  final Uint8List message;

  const AesEncryptReq({
    required this.key,
    required this.iv,
    required this.message,
  });
}

/// Local Wallet's Balance
class Balance {
  final int immature;

  /// Unconfirmed UTXOs generated by a wallet tx
  final int trustedPending;

  /// Unconfirmed UTXOs received from an external wallet
  final int untrustedPending;

  /// Confirmed and immediately spendable balance
  final int confirmed;

  /// Get sum of trusted_pending and confirmed coins
  final int spendable;

  /// Get the whole balance visible to the wallet
  final int total;

  const Balance({
    required this.immature,
    required this.trustedPending,
    required this.untrustedPending,
    required this.confirmed,
    required this.spendable,
    required this.total,
  });
}

/// The result after calling the TxBuilder finish() function. Contains unsigned PSBT and
/// transaction details.
class BdkTxBuilderResult {
  final String field0;
  final TransactionDetails field1;

  const BdkTxBuilderResult({
    required this.field0,
    required this.field1,
  });
}

///Block height and timestamp of a block
class BlockTime {
  ///Confirmation block height
  final int height;

  ///Confirmation block timestamp
  final int timestamp;

  const BlockTime({
    required this.height,
    required this.timestamp,
  });
}

@freezed
class BlockchainConfig with _$BlockchainConfig {
  /// Electrum client
  const factory BlockchainConfig.electrum({
    required ElectrumConfig config,
  }) = BlockchainConfig_Electrum;

  /// Esplora client
  const factory BlockchainConfig.esplora({
    required EsploraConfig config,
  }) = BlockchainConfig_Esplora;

  /// Bitcoin Core RPC client
  const factory BlockchainConfig.rpc({
    required RpcConfig config,
  }) = BlockchainConfig_Rpc;
}

class BLSVerifyReq {
  final Uint8List signature;
  final Uint8List message;
  final Uint8List publicKey;

  const BLSVerifyReq({
    required this.signature,
    required this.message,
    required this.publicKey,
  });
}

enum ChangeSpendPolicy {
  ChangeAllowed,
  OnlyChange,
  ChangeForbidden,
}

@freezed
class DatabaseConfig with _$DatabaseConfig {
  const factory DatabaseConfig.memory() = DatabaseConfig_Memory;

  ///Simple key-value embedded database based on sled
  const factory DatabaseConfig.sqlite({
    required SqliteDbConfiguration config,
  }) = DatabaseConfig_Sqlite;

  ///Sqlite embedded database using rusqlite
  const factory DatabaseConfig.sled({
    required SledDbConfiguration config,
  }) = DatabaseConfig_Sled;
}

class ED25519FromSeedReq {
  final Uint8List seed;

  const ED25519FromSeedReq({
    required this.seed,
  });
}

class ED25519Res {
  final Uint8List seed;
  final Uint8List publicKey;

  const ED25519Res({
    required this.seed,
    required this.publicKey,
  });
}

class ED25519SignReq {
  final Uint8List seed;
  final Uint8List message;

  const ED25519SignReq({
    required this.seed,
    required this.message,
  });
}

class ED25519VerifyReq {
  final Uint8List sig;
  final Uint8List message;
  final Uint8List pubKey;

  const ED25519VerifyReq({
    required this.sig,
    required this.message,
    required this.pubKey,
  });
}

/// Configuration for an ElectrumBlockchain
class ElectrumConfig {
  ///URL of the Electrum server (such as ElectrumX, Esplora, BWT) may start with ssl:// or tcp:// and include a port
  ///eg. ssl://electrum.blockstream.info:60002
  final String url;

  ///URL of the socks5 proxy server or a Tor service
  final String? socks5;

  ///Request retry count
  final int retry;

  ///Request timeout (seconds)
  final int? timeout;

  ///Stop searching addresses for transactions after finding an unused gap of this length
  final int stopGap;

  /// Validate the domain when using SSL
  final bool validateDomain;

  const ElectrumConfig({
    required this.url,
    this.socks5,
    required this.retry,
    this.timeout,
    required this.stopGap,
    required this.validateDomain,
  });
}

///Configuration for an EsploraBlockchain
class EsploraConfig {
  ///Base URL of the esplora service
  ///eg. https://blockstream.info/api/
  final String baseUrl;

  ///  Optional URL of the proxy to use to make requests to the Esplora server
  /// The string should be formatted as: <protocol>://<user>:<password>@host:<port>.
  /// Note that the format of this value and the supported protocols change slightly between the sync version of esplora (using ureq) and the async version (using reqwest).
  ///  For more details check with the documentation of the two crates. Both of them are compiled with the socks feature enabled.
  /// The proxy is ignored when targeting wasm32.
  final String? proxy;

  ///Number of parallel requests sent to the esplora service (default: 4)
  final int? concurrency;

  ///Stop searching addresses for transactions after finding an unused gap of this length.
  final int stopGap;

  ///Socket timeout.
  final int? timeout;

  const EsploraConfig({
    required this.baseUrl,
    this.proxy,
    this.concurrency,
    required this.stopGap,
    this.timeout,
  });
}

class ForeignUtxo {
  /// Reference to a transaction output
  final OutPoint outpoint;

  ///Transaction output
  final TxOutForeign txout;

  const ForeignUtxo({
    required this.outpoint,
    required this.txout,
  });
}

class KeyDerivedRes {
  final Uint8List leftBits;
  final Uint8List rightBits;

  const KeyDerivedRes({
    required this.leftBits,
    required this.rightBits,
  });
}

///Types of keychains
enum KeychainKind {
  External,

  ///Internal, usually used for change outputs
  Internal,
}

/// Unspent outputs of this wallet
class LocalUtxo {
  /// Reference to a transaction output
  final OutPoint outpoint;

  ///Transaction output
  final TxOut txout;

  ///Whether this UTXO is spent or not
  final bool isSpent;
  final KeychainKind keychain;

  const LocalUtxo({
    required this.outpoint,
    required this.txout,
    required this.isSpent,
    required this.keychain,
  });
}

///The cryptocurrency to act on
enum Network {
  ///Bitcoin’s testnet
  Testnet,

  ///Bitcoin’s regtest
  Regtest,

  ///Classic Bitcoin
  Bitcoin,

  ///Bitcoin’s signet
  Signet,
}

/// A reference to a transaction output.
class OutPoint {
  /// The referenced transaction's txid.
  final String txid;

  /// The index of the referenced output in its transaction's vout.
  final int vout;

  const OutPoint({
    required this.txid,
    required this.vout,
  });
}

class P256FromSeedReq {
  final Uint8List seed;

  const P256FromSeedReq({
    required this.seed,
  });
}

class P256IdentityExport {
  final Uint8List privateKeyHash;
  final Uint8List derEncodedPublicKey;

  const P256IdentityExport({
    required this.privateKeyHash,
    required this.derEncodedPublicKey,
  });
}

class P256ShareSecretReq {
  final Uint8List seed;
  final Uint8List publicKeyRawBytes;

  const P256ShareSecretReq({
    required this.seed,
    required this.publicKeyRawBytes,
  });
}

class P256SignWithSeedReq {
  final Uint8List msg;
  final Uint8List seed;

  const P256SignWithSeedReq({
    required this.msg,
    required this.seed,
  });
}

class P256VerifyReq {
  final Uint8List messageHash;
  final Uint8List signatureBytes;
  final Uint8List publicKeyBytes;

  const P256VerifyReq({
    required this.messageHash,
    required this.signatureBytes,
    required this.publicKeyBytes,
  });
}

@freezed
class Payload with _$Payload {
  /// P2PKH address.
  const factory Payload.pubkeyHash({
    required Uint8List pubkeyHash,
  }) = Payload_PubkeyHash;

  /// P2SH address.
  const factory Payload.scriptHash({
    required Uint8List scriptHash,
  }) = Payload_ScriptHash;

  /// Segwit address.
  const factory Payload.witnessProgram({
    /// The witness program version.
    required WitnessVersion version,

    /// The witness program.
    required Uint8List program,
  }) = Payload_WitnessProgram;
}

class PBKDFDeriveReq {
  final Uint8List password;
  final Uint8List salt;
  final int c;

  const PBKDFDeriveReq({
    required this.password,
    required this.salt,
    required this.c,
  });
}

class PhraseToSeedReq {
  final String phrase;
  final String password;

  const PhraseToSeedReq({
    required this.phrase,
    required this.password,
  });
}

@freezed
class RbfValue with _$RbfValue {
  const factory RbfValue.rbfDefault() = RbfValue_RbfDefault;
  const factory RbfValue.value(
    int field0,
  ) = RbfValue_Value;
}

class RpcConfig {
  /// The bitcoin node url
  final String url;

  /// The bitcoin node authentication mechanism
  final String? authCookie;
  final UserPass? authUserPass;

  /// The network we are using (it will be checked the bitcoin node network matches this)
  final Network network;

  /// The wallet name in the bitcoin node
  final String walletName;

  /// Sync parameters
  final RpcSyncParams? syncParams;

  const RpcConfig({
    required this.url,
    this.authCookie,
    this.authUserPass,
    required this.network,
    required this.walletName,
    this.syncParams,
  });
}

/// Sync parameters for Bitcoin Core RPC.
///
/// In general, BDK tries to sync `scriptPubKey`s cached in `Database` with
/// `scriptPubKey`s imported in the Bitcoin Core Wallet. These parameters are used for determining
/// how the `importdescriptors` RPC calls are to be made.
///
class RpcSyncParams {
  /// The minimum number of scripts to scan for on initial sync.
  final int startScriptCount;

  /// Time in unix seconds in which initial sync will start scanning from (0 to start from genesis).
  final int startTime;

  /// Forces every sync to use `start_time` as import timestamp.
  final bool forceStartTime;

  /// RPC poll rate (in seconds) to get state updates.
  final int pollRateSec;

  const RpcSyncParams({
    required this.startScriptCount,
    required this.startTime,
    required this.forceStartTime,
    required this.pollRateSec,
  });
}

class SchnorrFromSeedReq {
  final Uint8List seed;

  const SchnorrFromSeedReq({
    required this.seed,
  });
}

class SchnorrIdentityExport {
  final Uint8List privateKeyHash;
  final Uint8List publicKeyHash;

  const SchnorrIdentityExport({
    required this.privateKeyHash,
    required this.publicKeyHash,
  });
}

class SchnorrSignWithSeedReq {
  final Uint8List msg;
  final Uint8List seed;
  final Uint8List? auxRand;

  const SchnorrSignWithSeedReq({
    required this.msg,
    required this.seed,
    this.auxRand,
  });
}

class SchnorrVerifyReq {
  final Uint8List messageHash;
  final Uint8List signatureBytes;
  final Uint8List publicKeyBytes;

  const SchnorrVerifyReq({
    required this.messageHash,
    required this.signatureBytes,
    required this.publicKeyBytes,
  });
}

/// A Bitcoin script.
class Script {
  final Uint8List internal;

  const Script({
    required this.internal,
  });
}

/// A output script and an amount of satoshis.
class ScriptAmount {
  final Script script;
  final int amount;

  const ScriptAmount({
    required this.script,
    required this.amount,
  });
}

class ScriptDeriveReq {
  final Uint8List password;
  final Uint8List salt;
  final int n;
  final int p;
  final int r;

  const ScriptDeriveReq({
    required this.password,
    required this.salt,
    required this.n,
    required this.p,
    required this.r,
  });
}

class Secp256k1FromSeedReq {
  final Uint8List seed;

  const Secp256k1FromSeedReq({
    required this.seed,
  });
}

class Secp256k1IdentityExport {
  final Uint8List privateKeyHash;
  final Uint8List derEncodedPublicKey;

  const Secp256k1IdentityExport({
    required this.privateKeyHash,
    required this.derEncodedPublicKey,
  });
}

class Secp256k1RecoverReq {
  final Uint8List messagePreHashed;
  final Uint8List signatureBytes;
  final int? chainId;

  const Secp256k1RecoverReq({
    required this.messagePreHashed,
    required this.signatureBytes,
    this.chainId,
  });
}

class Secp256k1ShareSecretReq {
  final Uint8List seed;
  final Uint8List publicKeyRawBytes;

  const Secp256k1ShareSecretReq({
    required this.seed,
    required this.publicKeyRawBytes,
  });
}

class Secp256k1SignWithRngReq {
  final Uint8List msg;
  final Uint8List privateBytes;

  const Secp256k1SignWithRngReq({
    required this.msg,
    required this.privateBytes,
  });
}

class Secp256k1SignWithSeedReq {
  final Uint8List msg;
  final Uint8List seed;

  const Secp256k1SignWithSeedReq({
    required this.msg,
    required this.seed,
  });
}

class Secp256k1VerifyReq {
  final Uint8List messageHash;
  final Uint8List signatureBytes;
  final Uint8List publicKeyBytes;

  const Secp256k1VerifyReq({
    required this.messageHash,
    required this.signatureBytes,
    required this.publicKeyBytes,
  });
}

class SeedToKeyReq {
  final Uint8List seed;
  final String path;

  const SeedToKeyReq({
    required this.seed,
    required this.path,
  });
}

/// Options for a software signer
///
/// Adjust the behavior of our software signers and the way a transaction is finalized
class SignOptions {
  /// Whether the signer should trust the `witness_utxo`, if the `non_witness_utxo` hasn't been
  /// provided
  ///
  /// Defaults to `false` to mitigate the "SegWit bug" which should trick the wallet into
  /// paying a fee larger than expected.
  ///
  /// Some wallets, especially if relatively old, might not provide the `non_witness_utxo` for
  /// SegWit transactions in the PSBT they generate: in those cases setting this to `true`
  /// should correctly produce a signature, at the expense of an increased trust in the creator
  /// of the PSBT.
  ///
  /// For more details see: <https://blog.trezor.io/details-of-firmware-updates-for-trezor-one-version-1-9-1-and-trezor-model-t-version-2-3-1-1eba8f60f2dd>
  final bool trustWitnessUtxo;

  /// Whether the wallet should assume a specific height has been reached when trying to finalize
  /// a transaction
  ///
  /// The wallet will only "use" a timelock to satisfy the spending policy of an input if the
  /// timelock height has already been reached. This option allows overriding the "current height" to let the
  /// wallet use timelocks in the future to spend a coin.
  final int? assumeHeight;

  /// Whether the signer should use the `sighash_type` set in the PSBT when signing, no matter
  /// what its value is
  ///
  /// Defaults to `false` which will only allow signing using `SIGHASH_ALL`.
  final bool allowAllSighashes;

  /// Whether to remove partial signatures from the PSBT inputs while finalizing PSBT.
  ///
  /// Defaults to `true` which will remove partial signatures during finalization.
  final bool removePartialSigs;

  /// Whether to try finalizing the PSBT after the inputs are signed.
  ///
  /// Defaults to `true` which will try finalizing PSBT after inputs are signed.
  final bool tryFinalize;

  /// Whether to try finalizing the PSBT after the inputs are signed.
  ///
  /// Defaults to `true` which will try finalizing PSBT of Mine.
  final bool finalizeMineOnly;

  /// Whether we should try to sign a taproot transaction with the taproot internal key
  /// or not. This option is ignored if we're signing a non-taproot PSBT.
  ///
  /// Defaults to `true`, i.e., we always try to sign with the taproot internal key.
  final bool signWithTapInternalKey;

  /// Whether we should grind ECDSA signature to ensure signing with low r
  /// or not.
  /// Defaults to `true`, i.e., we always grind ECDSA signature to sign with low r.
  final bool allowGrinding;

  const SignOptions({
    required this.trustWitnessUtxo,
    this.assumeHeight,
    required this.allowAllSighashes,
    required this.removePartialSigs,
    required this.tryFinalize,
    required this.finalizeMineOnly,
    required this.signWithTapInternalKey,
    required this.allowGrinding,
  });
}

class SignatureFFI {
  /// This is the DER-encoded public key.
  final Uint8List? publicKey;

  /// The signature bytes.
  final Uint8List? signature;

  const SignatureFFI({
    this.publicKey,
    this.signature,
  });
}

///Configuration type for a sled Tree database
class SledDbConfiguration {
  ///Main directory of the db
  final String path;

  ///Name of the database tree, a separated namespace for the data
  final String treeName;

  const SledDbConfiguration({
    required this.path,
    required this.treeName,
  });
}

///Configuration type for a SqliteDatabase database
class SqliteDbConfiguration {
  ///Main directory of the db
  final String path;

  const SqliteDbConfiguration({
    required this.path,
  });
}

///A wallet transaction
class TransactionDetails {
  final String? serializedTx;

  /// Transaction id.
  final String txid;

  /// Received value (sats)
  /// Sum of owned outputs of this transaction.
  final int received;

  /// Sent value (sats)
  /// Sum of owned inputs of this transaction.
  final int sent;

  /// Fee value (sats) if confirmed.
  /// The availability of the fee depends on the backend. It's never None with an Electrum
  /// Server backend, but it could be None with a Bitcoin RPC node without txindex that receive
  /// funds while offline.
  final int? fee;

  /// If the transaction is confirmed, contains height and timestamp of the block containing the
  /// transaction, unconfirmed transaction contains `None`.
  final BlockTime? confirmationTime;

  const TransactionDetails({
    this.serializedTx,
    required this.txid,
    required this.received,
    required this.sent,
    this.fee,
    this.confirmationTime,
  });
}

/// TxBytes with tx_id and bytes
class TxBytes {
  /// The value of the output, in satoshis.
  final String txId;

  /// The script which must be satisfied for the output to be spent.
  final Uint8List bytes;

  const TxBytes({
    required this.txId,
    required this.bytes,
  });
}

class TxIn {
  final OutPoint previousOutput;
  final Script scriptSig;
  final int sequence;
  final List<String> witness;

  const TxIn({
    required this.previousOutput,
    required this.scriptSig,
    required this.sequence,
    required this.witness,
  });
}

///A transaction output, which defines new coins to be created from old ones.
class TxOut {
  /// The value of the output, in satoshis.
  final int value;

  /// The address of the output.
  final Script scriptPubkey;

  const TxOut({
    required this.value,
    required this.scriptPubkey,
  });
}

class TxOutForeign {
  /// The value of the output, in satoshis.
  final int value;

  /// The script which must be satisfied for the output to be spent.
  final String scriptPubkey;

  const TxOutForeign({
    required this.value,
    required this.scriptPubkey,
  });
}

/// RpcBlockchain configuration options
///
class UserPass {
  /// Username
  final String username;

  /// Password
  final String password;

  const UserPass({
    required this.username,
    required this.password,
  });
}

enum WitnessVersion {
  /// Initial version of witness program. Used for P2WPKH and P2WPK outputs
  V0,

  /// Version of witness program used for Taproot P2TR outputs.
  V1,

  /// Future (unsupported) version of witness program.
  V2,

  /// Future (unsupported) version of witness program.
  V3,

  /// Future (unsupported) version of witness program.
  V4,

  /// Future (unsupported) version of witness program.
  V5,

  /// Future (unsupported) version of witness program.
  V6,

  /// Future (unsupported) version of witness program.
  V7,

  /// Future (unsupported) version of witness program.
  V8,

  /// Future (unsupported) version of witness program.
  V9,

  /// Future (unsupported) version of witness program.
  V10,

  /// Future (unsupported) version of witness program.
  V11,

  /// Future (unsupported) version of witness program.
  V12,

  /// Future (unsupported) version of witness program.
  V13,

  /// Future (unsupported) version of witness program.
  V14,

  /// Future (unsupported) version of witness program.
  V15,

  /// Future (unsupported) version of witness program.
  V16,
}

///Type describing entropy length (aka word count) in the mnemonic
enum WordCount {
  ///12 words mnemonic (128 bits entropy)
  Words12,

  ///18 words mnemonic (192 bits entropy)
  Words18,

  ///24 words mnemonic (256 bits entropy)
  Words24,
}

class AgentDartImpl implements AgentDart {
  final AgentDartPlatform _platform;
  factory AgentDartImpl(ExternalLibrary dylib) => AgentDartImpl.raw(AgentDartPlatform(dylib));

  /// Only valid on web/WASM platforms.
  factory AgentDartImpl.wasm(FutureOr<WasmModule> module) => AgentDartImpl(module as ExternalLibrary);
  AgentDartImpl.raw(this._platform);
  Future<Uint8List> mnemonicPhraseToSeed({required PhraseToSeedReq req, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_phrase_to_seed_req(req);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_mnemonic_phrase_to_seed(port_, arg0),
      parseSuccessData: _wire2api_uint_8_list,
      constMeta: kMnemonicPhraseToSeedConstMeta,
      argValues: [
        req
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kMnemonicPhraseToSeedConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "mnemonic_phrase_to_seed",
        argNames: [
          "req"
        ],
      );

  Future<Uint8List> mnemonicSeedToKey({required SeedToKeyReq req, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_seed_to_key_req(req);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_mnemonic_seed_to_key(port_, arg0),
      parseSuccessData: _wire2api_uint_8_list,
      constMeta: kMnemonicSeedToKeyConstMeta,
      argValues: [
        req
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kMnemonicSeedToKeyConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "mnemonic_seed_to_key",
        argNames: [
          "req"
        ],
      );

  Future<bool> blsInit({dynamic hint}) {
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_bls_init(port_),
      parseSuccessData: _wire2api_bool,
      constMeta: kBlsInitConstMeta,
      argValues: [],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kBlsInitConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "bls_init",
        argNames: [],
      );

  Future<bool> blsVerify({required BLSVerifyReq req, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_bls_verify_req(req);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_bls_verify(port_, arg0),
      parseSuccessData: _wire2api_bool,
      constMeta: kBlsVerifyConstMeta,
      argValues: [
        req
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kBlsVerifyConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "bls_verify",
        argNames: [
          "req"
        ],
      );

  Future<ED25519Res> ed25519FromSeed({required ED25519FromSeedReq req, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_ed_25519_from_seed_req(req);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_ed25519_from_seed(port_, arg0),
      parseSuccessData: _wire2api_ed_25519_res,
      constMeta: kEd25519FromSeedConstMeta,
      argValues: [
        req
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kEd25519FromSeedConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "ed25519_from_seed",
        argNames: [
          "req"
        ],
      );

  Future<Uint8List> ed25519Sign({required ED25519SignReq req, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_ed_25519_sign_req(req);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_ed25519_sign(port_, arg0),
      parseSuccessData: _wire2api_uint_8_list,
      constMeta: kEd25519SignConstMeta,
      argValues: [
        req
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kEd25519SignConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "ed25519_sign",
        argNames: [
          "req"
        ],
      );

  Future<bool> ed25519Verify({required ED25519VerifyReq req, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_ed_25519_verify_req(req);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_ed25519_verify(port_, arg0),
      parseSuccessData: _wire2api_bool,
      constMeta: kEd25519VerifyConstMeta,
      argValues: [
        req
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kEd25519VerifyConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "ed25519_verify",
        argNames: [
          "req"
        ],
      );

  Future<Secp256k1IdentityExport> secp256K1FromSeed({required Secp256k1FromSeedReq req, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_secp_256_k_1_from_seed_req(req);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_secp256k1_from_seed(port_, arg0),
      parseSuccessData: _wire2api_secp_256_k_1_identity_export,
      constMeta: kSecp256K1FromSeedConstMeta,
      argValues: [
        req
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kSecp256K1FromSeedConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "secp256k1_from_seed",
        argNames: [
          "req"
        ],
      );

  Future<SignatureFFI> secp256K1Sign({required Secp256k1SignWithSeedReq req, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_secp_256_k_1_sign_with_seed_req(req);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_secp256k1_sign(port_, arg0),
      parseSuccessData: _wire2api_signature_ffi,
      constMeta: kSecp256K1SignConstMeta,
      argValues: [
        req
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kSecp256K1SignConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "secp256k1_sign",
        argNames: [
          "req"
        ],
      );

  Future<SignatureFFI> secp256K1SignWithRng({required Secp256k1SignWithRngReq req, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_secp_256_k_1_sign_with_rng_req(req);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_secp256k1_sign_with_rng(port_, arg0),
      parseSuccessData: _wire2api_signature_ffi,
      constMeta: kSecp256K1SignWithRngConstMeta,
      argValues: [
        req
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kSecp256K1SignWithRngConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "secp256k1_sign_with_rng",
        argNames: [
          "req"
        ],
      );

  Future<SignatureFFI> secp256K1SignRecoverable({required Secp256k1SignWithSeedReq req, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_secp_256_k_1_sign_with_seed_req(req);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_secp256k1_sign_recoverable(port_, arg0),
      parseSuccessData: _wire2api_signature_ffi,
      constMeta: kSecp256K1SignRecoverableConstMeta,
      argValues: [
        req
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kSecp256K1SignRecoverableConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "secp256k1_sign_recoverable",
        argNames: [
          "req"
        ],
      );

  Future<bool> secp256K1Verify({required Secp256k1VerifyReq req, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_secp_256_k_1_verify_req(req);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_secp256k1_verify(port_, arg0),
      parseSuccessData: _wire2api_bool,
      constMeta: kSecp256K1VerifyConstMeta,
      argValues: [
        req
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kSecp256K1VerifyConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "secp256k1_verify",
        argNames: [
          "req"
        ],
      );

  Future<Uint8List> secp256K1GetSharedSecret({required Secp256k1ShareSecretReq req, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_secp_256_k_1_share_secret_req(req);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_secp256k1_get_shared_secret(port_, arg0),
      parseSuccessData: _wire2api_uint_8_list,
      constMeta: kSecp256K1GetSharedSecretConstMeta,
      argValues: [
        req
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kSecp256K1GetSharedSecretConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "secp256k1_get_shared_secret",
        argNames: [
          "req"
        ],
      );

  Future<Uint8List> secp256K1Recover({required Secp256k1RecoverReq req, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_secp_256_k_1_recover_req(req);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_secp256k1_recover(port_, arg0),
      parseSuccessData: _wire2api_uint_8_list,
      constMeta: kSecp256K1RecoverConstMeta,
      argValues: [
        req
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kSecp256K1RecoverConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "secp256k1_recover",
        argNames: [
          "req"
        ],
      );

  Future<P256IdentityExport> p256FromSeed({required P256FromSeedReq req, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_p_256_from_seed_req(req);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_p256_from_seed(port_, arg0),
      parseSuccessData: _wire2api_p_256_identity_export,
      constMeta: kP256FromSeedConstMeta,
      argValues: [
        req
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kP256FromSeedConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "p256_from_seed",
        argNames: [
          "req"
        ],
      );

  Future<SignatureFFI> p256Sign({required P256SignWithSeedReq req, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_p_256_sign_with_seed_req(req);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_p256_sign(port_, arg0),
      parseSuccessData: _wire2api_signature_ffi,
      constMeta: kP256SignConstMeta,
      argValues: [
        req
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kP256SignConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "p256_sign",
        argNames: [
          "req"
        ],
      );

  Future<bool> p256Verify({required P256VerifyReq req, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_p_256_verify_req(req);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_p256_verify(port_, arg0),
      parseSuccessData: _wire2api_bool,
      constMeta: kP256VerifyConstMeta,
      argValues: [
        req
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kP256VerifyConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "p256_verify",
        argNames: [
          "req"
        ],
      );

  Future<Uint8List> p256GetSharedSecret({required P256ShareSecretReq req, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_p_256_share_secret_req(req);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_p256_get_shared_secret(port_, arg0),
      parseSuccessData: _wire2api_uint_8_list,
      constMeta: kP256GetSharedSecretConstMeta,
      argValues: [
        req
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kP256GetSharedSecretConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "p256_get_shared_secret",
        argNames: [
          "req"
        ],
      );

  Future<SchnorrIdentityExport> schnorrFromSeed({required SchnorrFromSeedReq req, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_schnorr_from_seed_req(req);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_schnorr_from_seed(port_, arg0),
      parseSuccessData: _wire2api_schnorr_identity_export,
      constMeta: kSchnorrFromSeedConstMeta,
      argValues: [
        req
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kSchnorrFromSeedConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "schnorr_from_seed",
        argNames: [
          "req"
        ],
      );

  Future<SignatureFFI> schnorrSign({required SchnorrSignWithSeedReq req, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_schnorr_sign_with_seed_req(req);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_schnorr_sign(port_, arg0),
      parseSuccessData: _wire2api_signature_ffi,
      constMeta: kSchnorrSignConstMeta,
      argValues: [
        req
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kSchnorrSignConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "schnorr_sign",
        argNames: [
          "req"
        ],
      );

  Future<bool> schnorrVerify({required SchnorrVerifyReq req, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_schnorr_verify_req(req);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_schnorr_verify(port_, arg0),
      parseSuccessData: _wire2api_bool,
      constMeta: kSchnorrVerifyConstMeta,
      argValues: [
        req
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kSchnorrVerifyConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "schnorr_verify",
        argNames: [
          "req"
        ],
      );

  Future<Uint8List> aes128CtrEncrypt({required AesEncryptReq req, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_aes_encrypt_req(req);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_aes_128_ctr_encrypt(port_, arg0),
      parseSuccessData: _wire2api_uint_8_list,
      constMeta: kAes128CtrEncryptConstMeta,
      argValues: [
        req
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kAes128CtrEncryptConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "aes_128_ctr_encrypt",
        argNames: [
          "req"
        ],
      );

  Future<Uint8List> aes128CtrDecrypt({required AesDecryptReq req, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_aes_decrypt_req(req);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_aes_128_ctr_decrypt(port_, arg0),
      parseSuccessData: _wire2api_uint_8_list,
      constMeta: kAes128CtrDecryptConstMeta,
      argValues: [
        req
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kAes128CtrDecryptConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "aes_128_ctr_decrypt",
        argNames: [
          "req"
        ],
      );

  Future<Uint8List> aes256CbcEncrypt({required AesEncryptReq req, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_aes_encrypt_req(req);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_aes_256_cbc_encrypt(port_, arg0),
      parseSuccessData: _wire2api_uint_8_list,
      constMeta: kAes256CbcEncryptConstMeta,
      argValues: [
        req
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kAes256CbcEncryptConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "aes_256_cbc_encrypt",
        argNames: [
          "req"
        ],
      );

  Future<Uint8List> aes256CbcDecrypt({required AesDecryptReq req, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_aes_decrypt_req(req);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_aes_256_cbc_decrypt(port_, arg0),
      parseSuccessData: _wire2api_uint_8_list,
      constMeta: kAes256CbcDecryptConstMeta,
      argValues: [
        req
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kAes256CbcDecryptConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "aes_256_cbc_decrypt",
        argNames: [
          "req"
        ],
      );

  Future<Uint8List> aes256GcmEncrypt({required AesEncryptReq req, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_aes_encrypt_req(req);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_aes_256_gcm_encrypt(port_, arg0),
      parseSuccessData: _wire2api_uint_8_list,
      constMeta: kAes256GcmEncryptConstMeta,
      argValues: [
        req
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kAes256GcmEncryptConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "aes_256_gcm_encrypt",
        argNames: [
          "req"
        ],
      );

  Future<Uint8List> aes256GcmDecrypt({required AesDecryptReq req, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_aes_decrypt_req(req);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_aes_256_gcm_decrypt(port_, arg0),
      parseSuccessData: _wire2api_uint_8_list,
      constMeta: kAes256GcmDecryptConstMeta,
      argValues: [
        req
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kAes256GcmDecryptConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "aes_256_gcm_decrypt",
        argNames: [
          "req"
        ],
      );

  Future<KeyDerivedRes> pbkdf2DeriveKey({required PBKDFDeriveReq req, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_pbkdf_derive_req(req);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_pbkdf2_derive_key(port_, arg0),
      parseSuccessData: _wire2api_key_derived_res,
      constMeta: kPbkdf2DeriveKeyConstMeta,
      argValues: [
        req
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kPbkdf2DeriveKeyConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "pbkdf2_derive_key",
        argNames: [
          "req"
        ],
      );

  Future<KeyDerivedRes> scryptDeriveKey({required ScriptDeriveReq req, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_script_derive_req(req);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_scrypt_derive_key(port_, arg0),
      parseSuccessData: _wire2api_key_derived_res,
      constMeta: kScryptDeriveKeyConstMeta,
      argValues: [
        req
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kScryptDeriveKeyConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "scrypt_derive_key",
        argNames: [
          "req"
        ],
      );

  Future<BlockchainInstance> createBlockchainStaticMethodApi({required BlockchainConfig config, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_blockchain_config(config);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_create_blockchain__static_method__Api(port_, arg0),
      parseSuccessData: _wire2api_BlockchainInstance,
      constMeta: kCreateBlockchainStaticMethodApiConstMeta,
      argValues: [
        config
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kCreateBlockchainStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "create_blockchain__static_method__Api",
        argNames: [
          "config"
        ],
      );

  Future<int> getHeightStaticMethodApi({required BlockchainInstance blockchain, dynamic hint}) {
    var arg0 = _platform.api2wire_BlockchainInstance(blockchain);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_get_height__static_method__Api(port_, arg0),
      parseSuccessData: _wire2api_u32,
      constMeta: kGetHeightStaticMethodApiConstMeta,
      argValues: [
        blockchain
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kGetHeightStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "get_height__static_method__Api",
        argNames: [
          "blockchain"
        ],
      );

  Future<String> getBlockchainHashStaticMethodApi({required int blockchainHeight, required BlockchainInstance blockchain, dynamic hint}) {
    var arg0 = api2wire_u32(blockchainHeight);
    var arg1 = _platform.api2wire_BlockchainInstance(blockchain);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_get_blockchain_hash__static_method__Api(port_, arg0, arg1),
      parseSuccessData: _wire2api_String,
      constMeta: kGetBlockchainHashStaticMethodApiConstMeta,
      argValues: [
        blockchainHeight,
        blockchain
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kGetBlockchainHashStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "get_blockchain_hash__static_method__Api",
        argNames: [
          "blockchainHeight",
          "blockchain"
        ],
      );

  Future<double> estimateFeeStaticMethodApi({required int target, required BlockchainInstance blockchain, dynamic hint}) {
    var arg0 = _platform.api2wire_u64(target);
    var arg1 = _platform.api2wire_BlockchainInstance(blockchain);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_estimate_fee__static_method__Api(port_, arg0, arg1),
      parseSuccessData: _wire2api_f32,
      constMeta: kEstimateFeeStaticMethodApiConstMeta,
      argValues: [
        target,
        blockchain
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kEstimateFeeStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "estimate_fee__static_method__Api",
        argNames: [
          "target",
          "blockchain"
        ],
      );

  Future<String> broadcastStaticMethodApi({required String tx, required BlockchainInstance blockchain, dynamic hint}) {
    var arg0 = _platform.api2wire_String(tx);
    var arg1 = _platform.api2wire_BlockchainInstance(blockchain);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_broadcast__static_method__Api(port_, arg0, arg1),
      parseSuccessData: _wire2api_String,
      constMeta: kBroadcastStaticMethodApiConstMeta,
      argValues: [
        tx,
        blockchain
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kBroadcastStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "broadcast__static_method__Api",
        argNames: [
          "tx",
          "blockchain"
        ],
      );

  Future<String> getTxStaticMethodApi({required String tx, required BlockchainInstance blockchain, dynamic hint}) {
    var arg0 = _platform.api2wire_String(tx);
    var arg1 = _platform.api2wire_BlockchainInstance(blockchain);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_get_tx__static_method__Api(port_, arg0, arg1),
      parseSuccessData: _wire2api_String,
      constMeta: kGetTxStaticMethodApiConstMeta,
      argValues: [
        tx,
        blockchain
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kGetTxStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "get_tx__static_method__Api",
        argNames: [
          "tx",
          "blockchain"
        ],
      );

  Future<String> createTransactionStaticMethodApi({required Uint8List tx, dynamic hint}) {
    var arg0 = _platform.api2wire_uint_8_list(tx);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_create_transaction__static_method__Api(port_, arg0),
      parseSuccessData: _wire2api_String,
      constMeta: kCreateTransactionStaticMethodApiConstMeta,
      argValues: [
        tx
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kCreateTransactionStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "create_transaction__static_method__Api",
        argNames: [
          "tx"
        ],
      );

  Future<String> txTxidStaticMethodApi({required String tx, dynamic hint}) {
    var arg0 = _platform.api2wire_String(tx);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_tx_txid__static_method__Api(port_, arg0),
      parseSuccessData: _wire2api_String,
      constMeta: kTxTxidStaticMethodApiConstMeta,
      argValues: [
        tx
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kTxTxidStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "tx_txid__static_method__Api",
        argNames: [
          "tx"
        ],
      );

  Future<int> weightStaticMethodApi({required String tx, dynamic hint}) {
    var arg0 = _platform.api2wire_String(tx);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_weight__static_method__Api(port_, arg0),
      parseSuccessData: _wire2api_u64,
      constMeta: kWeightStaticMethodApiConstMeta,
      argValues: [
        tx
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kWeightStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "weight__static_method__Api",
        argNames: [
          "tx"
        ],
      );

  Future<int> sizeStaticMethodApi({required String tx, dynamic hint}) {
    var arg0 = _platform.api2wire_String(tx);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_size__static_method__Api(port_, arg0),
      parseSuccessData: _wire2api_u64,
      constMeta: kSizeStaticMethodApiConstMeta,
      argValues: [
        tx
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kSizeStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "size__static_method__Api",
        argNames: [
          "tx"
        ],
      );

  Future<int> vsizeStaticMethodApi({required String tx, dynamic hint}) {
    var arg0 = _platform.api2wire_String(tx);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_vsize__static_method__Api(port_, arg0),
      parseSuccessData: _wire2api_u64,
      constMeta: kVsizeStaticMethodApiConstMeta,
      argValues: [
        tx
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kVsizeStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "vsize__static_method__Api",
        argNames: [
          "tx"
        ],
      );

  Future<Uint8List> serializeTxStaticMethodApi({required String tx, dynamic hint}) {
    var arg0 = _platform.api2wire_String(tx);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_serialize_tx__static_method__Api(port_, arg0),
      parseSuccessData: _wire2api_uint_8_list,
      constMeta: kSerializeTxStaticMethodApiConstMeta,
      argValues: [
        tx
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kSerializeTxStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "serialize_tx__static_method__Api",
        argNames: [
          "tx"
        ],
      );

  Future<bool> isCoinBaseStaticMethodApi({required String tx, dynamic hint}) {
    var arg0 = _platform.api2wire_String(tx);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_is_coin_base__static_method__Api(port_, arg0),
      parseSuccessData: _wire2api_bool,
      constMeta: kIsCoinBaseStaticMethodApiConstMeta,
      argValues: [
        tx
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kIsCoinBaseStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "is_coin_base__static_method__Api",
        argNames: [
          "tx"
        ],
      );

  Future<bool> isExplicitlyRbfStaticMethodApi({required String tx, dynamic hint}) {
    var arg0 = _platform.api2wire_String(tx);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_is_explicitly_rbf__static_method__Api(port_, arg0),
      parseSuccessData: _wire2api_bool,
      constMeta: kIsExplicitlyRbfStaticMethodApiConstMeta,
      argValues: [
        tx
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kIsExplicitlyRbfStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "is_explicitly_rbf__static_method__Api",
        argNames: [
          "tx"
        ],
      );

  Future<bool> isLockTimeEnabledStaticMethodApi({required String tx, dynamic hint}) {
    var arg0 = _platform.api2wire_String(tx);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_is_lock_time_enabled__static_method__Api(port_, arg0),
      parseSuccessData: _wire2api_bool,
      constMeta: kIsLockTimeEnabledStaticMethodApiConstMeta,
      argValues: [
        tx
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kIsLockTimeEnabledStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "is_lock_time_enabled__static_method__Api",
        argNames: [
          "tx"
        ],
      );

  Future<int> versionStaticMethodApi({required String tx, dynamic hint}) {
    var arg0 = _platform.api2wire_String(tx);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_version__static_method__Api(port_, arg0),
      parseSuccessData: _wire2api_i32,
      constMeta: kVersionStaticMethodApiConstMeta,
      argValues: [
        tx
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kVersionStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "version__static_method__Api",
        argNames: [
          "tx"
        ],
      );

  Future<int> lockTimeStaticMethodApi({required String tx, dynamic hint}) {
    var arg0 = _platform.api2wire_String(tx);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_lock_time__static_method__Api(port_, arg0),
      parseSuccessData: _wire2api_u32,
      constMeta: kLockTimeStaticMethodApiConstMeta,
      argValues: [
        tx
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kLockTimeStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "lock_time__static_method__Api",
        argNames: [
          "tx"
        ],
      );

  Future<List<TxIn>> inputStaticMethodApi({required String tx, dynamic hint}) {
    var arg0 = _platform.api2wire_String(tx);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_input__static_method__Api(port_, arg0),
      parseSuccessData: _wire2api_list_tx_in,
      constMeta: kInputStaticMethodApiConstMeta,
      argValues: [
        tx
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kInputStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "input__static_method__Api",
        argNames: [
          "tx"
        ],
      );

  Future<List<TxOut>> outputStaticMethodApi({required String tx, dynamic hint}) {
    var arg0 = _platform.api2wire_String(tx);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_output__static_method__Api(port_, arg0),
      parseSuccessData: _wire2api_list_tx_out,
      constMeta: kOutputStaticMethodApiConstMeta,
      argValues: [
        tx
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kOutputStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "output__static_method__Api",
        argNames: [
          "tx"
        ],
      );

  Future<String> serializePsbtStaticMethodApi({required String psbtStr, dynamic hint}) {
    var arg0 = _platform.api2wire_String(psbtStr);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_serialize_psbt__static_method__Api(port_, arg0),
      parseSuccessData: _wire2api_String,
      constMeta: kSerializePsbtStaticMethodApiConstMeta,
      argValues: [
        psbtStr
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kSerializePsbtStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "serialize_psbt__static_method__Api",
        argNames: [
          "psbtStr"
        ],
      );

  Future<String> psbtTxidStaticMethodApi({required String psbtStr, dynamic hint}) {
    var arg0 = _platform.api2wire_String(psbtStr);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_psbt_txid__static_method__Api(port_, arg0),
      parseSuccessData: _wire2api_String,
      constMeta: kPsbtTxidStaticMethodApiConstMeta,
      argValues: [
        psbtStr
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kPsbtTxidStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "psbt_txid__static_method__Api",
        argNames: [
          "psbtStr"
        ],
      );

  Future<String> extractTxStaticMethodApi({required String psbtStr, dynamic hint}) {
    var arg0 = _platform.api2wire_String(psbtStr);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_extract_tx__static_method__Api(port_, arg0),
      parseSuccessData: _wire2api_String,
      constMeta: kExtractTxStaticMethodApiConstMeta,
      argValues: [
        psbtStr
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kExtractTxStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "extract_tx__static_method__Api",
        argNames: [
          "psbtStr"
        ],
      );

  Future<double?> psbtFeeRateStaticMethodApi({required String psbtStr, dynamic hint}) {
    var arg0 = _platform.api2wire_String(psbtStr);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_psbt_fee_rate__static_method__Api(port_, arg0),
      parseSuccessData: _wire2api_opt_box_autoadd_f32,
      constMeta: kPsbtFeeRateStaticMethodApiConstMeta,
      argValues: [
        psbtStr
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kPsbtFeeRateStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "psbt_fee_rate__static_method__Api",
        argNames: [
          "psbtStr"
        ],
      );

  Future<int?> psbtFeeAmountStaticMethodApi({required String psbtStr, dynamic hint}) {
    var arg0 = _platform.api2wire_String(psbtStr);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_psbt_fee_amount__static_method__Api(port_, arg0),
      parseSuccessData: _wire2api_opt_box_autoadd_u64,
      constMeta: kPsbtFeeAmountStaticMethodApiConstMeta,
      argValues: [
        psbtStr
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kPsbtFeeAmountStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "psbt_fee_amount__static_method__Api",
        argNames: [
          "psbtStr"
        ],
      );

  Future<String> combinePsbtStaticMethodApi({required String psbtStr, required String other, dynamic hint}) {
    var arg0 = _platform.api2wire_String(psbtStr);
    var arg1 = _platform.api2wire_String(other);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_combine_psbt__static_method__Api(port_, arg0, arg1),
      parseSuccessData: _wire2api_String,
      constMeta: kCombinePsbtStaticMethodApiConstMeta,
      argValues: [
        psbtStr,
        other
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kCombinePsbtStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "combine_psbt__static_method__Api",
        argNames: [
          "psbtStr",
          "other"
        ],
      );

  Future<String> jsonSerializeStaticMethodApi({required String psbtStr, dynamic hint}) {
    var arg0 = _platform.api2wire_String(psbtStr);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_json_serialize__static_method__Api(port_, arg0),
      parseSuccessData: _wire2api_String,
      constMeta: kJsonSerializeStaticMethodApiConstMeta,
      argValues: [
        psbtStr
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kJsonSerializeStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "json_serialize__static_method__Api",
        argNames: [
          "psbtStr"
        ],
      );

  Future<List<TxOut>> getInputsStaticMethodApi({required String psbtStr, dynamic hint}) {
    var arg0 = _platform.api2wire_String(psbtStr);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_get_inputs__static_method__Api(port_, arg0),
      parseSuccessData: _wire2api_list_tx_out,
      constMeta: kGetInputsStaticMethodApiConstMeta,
      argValues: [
        psbtStr
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kGetInputsStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "get_inputs__static_method__Api",
        argNames: [
          "psbtStr"
        ],
      );

  Future<BdkTxBuilderResult> txBuilderFinishStaticMethodApi({required WalletInstance wallet, required List<ScriptAmount> recipients, required List<TxBytes> txs, required List<OutPoint> unspendable, required List<ForeignUtxo> foreignUtxos, required ChangeSpendPolicy changePolicy, required bool manuallySelectedOnly, double? feeRate, int? feeAbsolute, required bool drainWallet, Script? drainTo, RbfValue? rbf, required Uint8List data, bool? shuffleUtxo, dynamic hint}) {
    var arg0 = _platform.api2wire_WalletInstance(wallet);
    var arg1 = _platform.api2wire_list_script_amount(recipients);
    var arg2 = _platform.api2wire_list_tx_bytes(txs);
    var arg3 = _platform.api2wire_list_out_point(unspendable);
    var arg4 = _platform.api2wire_list_foreign_utxo(foreignUtxos);
    var arg5 = api2wire_change_spend_policy(changePolicy);
    var arg6 = manuallySelectedOnly;
    var arg7 = _platform.api2wire_opt_box_autoadd_f32(feeRate);
    var arg8 = _platform.api2wire_opt_box_autoadd_u64(feeAbsolute);
    var arg9 = drainWallet;
    var arg10 = _platform.api2wire_opt_box_autoadd_script(drainTo);
    var arg11 = _platform.api2wire_opt_box_autoadd_rbf_value(rbf);
    var arg12 = _platform.api2wire_uint_8_list(data);
    var arg13 = _platform.api2wire_opt_box_autoadd_bool(shuffleUtxo);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_tx_builder_finish__static_method__Api(port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13),
      parseSuccessData: _wire2api_bdk_tx_builder_result,
      constMeta: kTxBuilderFinishStaticMethodApiConstMeta,
      argValues: [
        wallet,
        recipients,
        txs,
        unspendable,
        foreignUtxos,
        changePolicy,
        manuallySelectedOnly,
        feeRate,
        feeAbsolute,
        drainWallet,
        drainTo,
        rbf,
        data,
        shuffleUtxo
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kTxBuilderFinishStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "tx_builder_finish__static_method__Api",
        argNames: [
          "wallet",
          "recipients",
          "txs",
          "unspendable",
          "foreignUtxos",
          "changePolicy",
          "manuallySelectedOnly",
          "feeRate",
          "feeAbsolute",
          "drainWallet",
          "drainTo",
          "rbf",
          "data",
          "shuffleUtxo"
        ],
      );

  Future<int> txCalFeeFinishStaticMethodApi({required WalletInstance wallet, required List<ScriptAmount> recipients, required List<TxBytes> txs, required List<OutPoint> unspendable, required List<ForeignUtxo> foreignUtxos, required ChangeSpendPolicy changePolicy, required bool manuallySelectedOnly, double? feeRate, int? feeAbsolute, required bool drainWallet, Script? drainTo, RbfValue? rbf, required Uint8List data, bool? shuffleUtxo, dynamic hint}) {
    var arg0 = _platform.api2wire_WalletInstance(wallet);
    var arg1 = _platform.api2wire_list_script_amount(recipients);
    var arg2 = _platform.api2wire_list_tx_bytes(txs);
    var arg3 = _platform.api2wire_list_out_point(unspendable);
    var arg4 = _platform.api2wire_list_foreign_utxo(foreignUtxos);
    var arg5 = api2wire_change_spend_policy(changePolicy);
    var arg6 = manuallySelectedOnly;
    var arg7 = _platform.api2wire_opt_box_autoadd_f32(feeRate);
    var arg8 = _platform.api2wire_opt_box_autoadd_u64(feeAbsolute);
    var arg9 = drainWallet;
    var arg10 = _platform.api2wire_opt_box_autoadd_script(drainTo);
    var arg11 = _platform.api2wire_opt_box_autoadd_rbf_value(rbf);
    var arg12 = _platform.api2wire_uint_8_list(data);
    var arg13 = _platform.api2wire_opt_box_autoadd_bool(shuffleUtxo);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_tx_cal_fee_finish__static_method__Api(port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13),
      parseSuccessData: _wire2api_u64,
      constMeta: kTxCalFeeFinishStaticMethodApiConstMeta,
      argValues: [
        wallet,
        recipients,
        txs,
        unspendable,
        foreignUtxos,
        changePolicy,
        manuallySelectedOnly,
        feeRate,
        feeAbsolute,
        drainWallet,
        drainTo,
        rbf,
        data,
        shuffleUtxo
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kTxCalFeeFinishStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "tx_cal_fee_finish__static_method__Api",
        argNames: [
          "wallet",
          "recipients",
          "txs",
          "unspendable",
          "foreignUtxos",
          "changePolicy",
          "manuallySelectedOnly",
          "feeRate",
          "feeAbsolute",
          "drainWallet",
          "drainTo",
          "rbf",
          "data",
          "shuffleUtxo"
        ],
      );

  Future<BdkTxBuilderResult> bumpFeeTxBuilderFinishStaticMethodApi({required String txid, required double feeRate, String? allowShrinking, required WalletInstance wallet, required bool enableRbf, required bool keepChange, int? nSequence, dynamic hint}) {
    var arg0 = _platform.api2wire_String(txid);
    var arg1 = api2wire_f32(feeRate);
    var arg2 = _platform.api2wire_opt_String(allowShrinking);
    var arg3 = _platform.api2wire_WalletInstance(wallet);
    var arg4 = enableRbf;
    var arg5 = keepChange;
    var arg6 = _platform.api2wire_opt_box_autoadd_u32(nSequence);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_bump_fee_tx_builder_finish__static_method__Api(port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6),
      parseSuccessData: _wire2api_bdk_tx_builder_result,
      constMeta: kBumpFeeTxBuilderFinishStaticMethodApiConstMeta,
      argValues: [
        txid,
        feeRate,
        allowShrinking,
        wallet,
        enableRbf,
        keepChange,
        nSequence
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kBumpFeeTxBuilderFinishStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "bump_fee_tx_builder_finish__static_method__Api",
        argNames: [
          "txid",
          "feeRate",
          "allowShrinking",
          "wallet",
          "enableRbf",
          "keepChange",
          "nSequence"
        ],
      );

  Future<BdkDescriptor> createDescriptorStaticMethodApi({required String descriptor, required Network network, dynamic hint}) {
    var arg0 = _platform.api2wire_String(descriptor);
    var arg1 = api2wire_network(network);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_create_descriptor__static_method__Api(port_, arg0, arg1),
      parseSuccessData: _wire2api_BdkDescriptor,
      constMeta: kCreateDescriptorStaticMethodApiConstMeta,
      argValues: [
        descriptor,
        network
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kCreateDescriptorStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "create_descriptor__static_method__Api",
        argNames: [
          "descriptor",
          "network"
        ],
      );

  Future<BdkDescriptor> importSingleWifStaticMethodApi({required String wif, required String addressType, required Network network, dynamic hint}) {
    var arg0 = _platform.api2wire_String(wif);
    var arg1 = _platform.api2wire_String(addressType);
    var arg2 = api2wire_network(network);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_import_single_wif__static_method__Api(port_, arg0, arg1, arg2),
      parseSuccessData: _wire2api_BdkDescriptor,
      constMeta: kImportSingleWifStaticMethodApiConstMeta,
      argValues: [
        wif,
        addressType,
        network
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kImportSingleWifStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "import_single_wif__static_method__Api",
        argNames: [
          "wif",
          "addressType",
          "network"
        ],
      );

  Future<BdkDescriptor> newBip44DescriptorStaticMethodApi({required KeychainKind keyChainKind, required String secretKey, required Network network, dynamic hint}) {
    var arg0 = api2wire_keychain_kind(keyChainKind);
    var arg1 = _platform.api2wire_String(secretKey);
    var arg2 = api2wire_network(network);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_new_bip44_descriptor__static_method__Api(port_, arg0, arg1, arg2),
      parseSuccessData: _wire2api_BdkDescriptor,
      constMeta: kNewBip44DescriptorStaticMethodApiConstMeta,
      argValues: [
        keyChainKind,
        secretKey,
        network
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kNewBip44DescriptorStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "new_bip44_descriptor__static_method__Api",
        argNames: [
          "keyChainKind",
          "secretKey",
          "network"
        ],
      );

  Future<BdkDescriptor> newBip44PublicStaticMethodApi({required KeychainKind keyChainKind, required String publicKey, required Network network, required String fingerprint, dynamic hint}) {
    var arg0 = api2wire_keychain_kind(keyChainKind);
    var arg1 = _platform.api2wire_String(publicKey);
    var arg2 = api2wire_network(network);
    var arg3 = _platform.api2wire_String(fingerprint);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_new_bip44_public__static_method__Api(port_, arg0, arg1, arg2, arg3),
      parseSuccessData: _wire2api_BdkDescriptor,
      constMeta: kNewBip44PublicStaticMethodApiConstMeta,
      argValues: [
        keyChainKind,
        publicKey,
        network,
        fingerprint
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kNewBip44PublicStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "new_bip44_public__static_method__Api",
        argNames: [
          "keyChainKind",
          "publicKey",
          "network",
          "fingerprint"
        ],
      );

  Future<BdkDescriptor> newBip44TrDescriptorStaticMethodApi({required KeychainKind keyChainKind, required String secretKey, required Network network, dynamic hint}) {
    var arg0 = api2wire_keychain_kind(keyChainKind);
    var arg1 = _platform.api2wire_String(secretKey);
    var arg2 = api2wire_network(network);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_new_bip44_tr_descriptor__static_method__Api(port_, arg0, arg1, arg2),
      parseSuccessData: _wire2api_BdkDescriptor,
      constMeta: kNewBip44TrDescriptorStaticMethodApiConstMeta,
      argValues: [
        keyChainKind,
        secretKey,
        network
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kNewBip44TrDescriptorStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "new_bip44_tr_descriptor__static_method__Api",
        argNames: [
          "keyChainKind",
          "secretKey",
          "network"
        ],
      );

  Future<BdkDescriptor> newBip44TrPublicStaticMethodApi({required KeychainKind keyChainKind, required String publicKey, required Network network, required String fingerprint, dynamic hint}) {
    var arg0 = api2wire_keychain_kind(keyChainKind);
    var arg1 = _platform.api2wire_String(publicKey);
    var arg2 = api2wire_network(network);
    var arg3 = _platform.api2wire_String(fingerprint);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_new_bip44_tr_public__static_method__Api(port_, arg0, arg1, arg2, arg3),
      parseSuccessData: _wire2api_BdkDescriptor,
      constMeta: kNewBip44TrPublicStaticMethodApiConstMeta,
      argValues: [
        keyChainKind,
        publicKey,
        network,
        fingerprint
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kNewBip44TrPublicStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "new_bip44_tr_public__static_method__Api",
        argNames: [
          "keyChainKind",
          "publicKey",
          "network",
          "fingerprint"
        ],
      );

  Future<BdkDescriptor> newBip49DescriptorStaticMethodApi({required KeychainKind keyChainKind, required String secretKey, required Network network, dynamic hint}) {
    var arg0 = api2wire_keychain_kind(keyChainKind);
    var arg1 = _platform.api2wire_String(secretKey);
    var arg2 = api2wire_network(network);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_new_bip49_descriptor__static_method__Api(port_, arg0, arg1, arg2),
      parseSuccessData: _wire2api_BdkDescriptor,
      constMeta: kNewBip49DescriptorStaticMethodApiConstMeta,
      argValues: [
        keyChainKind,
        secretKey,
        network
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kNewBip49DescriptorStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "new_bip49_descriptor__static_method__Api",
        argNames: [
          "keyChainKind",
          "secretKey",
          "network"
        ],
      );

  Future<BdkDescriptor> newBip49PublicStaticMethodApi({required KeychainKind keyChainKind, required String publicKey, required Network network, required String fingerprint, dynamic hint}) {
    var arg0 = api2wire_keychain_kind(keyChainKind);
    var arg1 = _platform.api2wire_String(publicKey);
    var arg2 = api2wire_network(network);
    var arg3 = _platform.api2wire_String(fingerprint);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_new_bip49_public__static_method__Api(port_, arg0, arg1, arg2, arg3),
      parseSuccessData: _wire2api_BdkDescriptor,
      constMeta: kNewBip49PublicStaticMethodApiConstMeta,
      argValues: [
        keyChainKind,
        publicKey,
        network,
        fingerprint
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kNewBip49PublicStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "new_bip49_public__static_method__Api",
        argNames: [
          "keyChainKind",
          "publicKey",
          "network",
          "fingerprint"
        ],
      );

  Future<BdkDescriptor> newBip84DescriptorStaticMethodApi({required KeychainKind keyChainKind, required String secretKey, required Network network, dynamic hint}) {
    var arg0 = api2wire_keychain_kind(keyChainKind);
    var arg1 = _platform.api2wire_String(secretKey);
    var arg2 = api2wire_network(network);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_new_bip84_descriptor__static_method__Api(port_, arg0, arg1, arg2),
      parseSuccessData: _wire2api_BdkDescriptor,
      constMeta: kNewBip84DescriptorStaticMethodApiConstMeta,
      argValues: [
        keyChainKind,
        secretKey,
        network
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kNewBip84DescriptorStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "new_bip84_descriptor__static_method__Api",
        argNames: [
          "keyChainKind",
          "secretKey",
          "network"
        ],
      );

  Future<BdkDescriptor> newBip84PublicStaticMethodApi({required KeychainKind keyChainKind, required String publicKey, required Network network, required String fingerprint, dynamic hint}) {
    var arg0 = api2wire_keychain_kind(keyChainKind);
    var arg1 = _platform.api2wire_String(publicKey);
    var arg2 = api2wire_network(network);
    var arg3 = _platform.api2wire_String(fingerprint);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_new_bip84_public__static_method__Api(port_, arg0, arg1, arg2, arg3),
      parseSuccessData: _wire2api_BdkDescriptor,
      constMeta: kNewBip84PublicStaticMethodApiConstMeta,
      argValues: [
        keyChainKind,
        publicKey,
        network,
        fingerprint
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kNewBip84PublicStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "new_bip84_public__static_method__Api",
        argNames: [
          "keyChainKind",
          "publicKey",
          "network",
          "fingerprint"
        ],
      );

  Future<BdkDescriptor> newBip86DescriptorStaticMethodApi({required KeychainKind keyChainKind, required String secretKey, required Network network, dynamic hint}) {
    var arg0 = api2wire_keychain_kind(keyChainKind);
    var arg1 = _platform.api2wire_String(secretKey);
    var arg2 = api2wire_network(network);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_new_bip86_descriptor__static_method__Api(port_, arg0, arg1, arg2),
      parseSuccessData: _wire2api_BdkDescriptor,
      constMeta: kNewBip86DescriptorStaticMethodApiConstMeta,
      argValues: [
        keyChainKind,
        secretKey,
        network
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kNewBip86DescriptorStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "new_bip86_descriptor__static_method__Api",
        argNames: [
          "keyChainKind",
          "secretKey",
          "network"
        ],
      );

  Future<BdkDescriptor> newBip86PublicStaticMethodApi({required KeychainKind keyChainKind, required String publicKey, required Network network, required String fingerprint, dynamic hint}) {
    var arg0 = api2wire_keychain_kind(keyChainKind);
    var arg1 = _platform.api2wire_String(publicKey);
    var arg2 = api2wire_network(network);
    var arg3 = _platform.api2wire_String(fingerprint);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_new_bip86_public__static_method__Api(port_, arg0, arg1, arg2, arg3),
      parseSuccessData: _wire2api_BdkDescriptor,
      constMeta: kNewBip86PublicStaticMethodApiConstMeta,
      argValues: [
        keyChainKind,
        publicKey,
        network,
        fingerprint
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kNewBip86PublicStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "new_bip86_public__static_method__Api",
        argNames: [
          "keyChainKind",
          "publicKey",
          "network",
          "fingerprint"
        ],
      );

  Future<String> asStringPrivateStaticMethodApi({required BdkDescriptor descriptor, dynamic hint}) {
    var arg0 = _platform.api2wire_BdkDescriptor(descriptor);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_as_string_private__static_method__Api(port_, arg0),
      parseSuccessData: _wire2api_String,
      constMeta: kAsStringPrivateStaticMethodApiConstMeta,
      argValues: [
        descriptor
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kAsStringPrivateStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "as_string_private__static_method__Api",
        argNames: [
          "descriptor"
        ],
      );

  Future<String> asStringStaticMethodApi({required BdkDescriptor descriptor, dynamic hint}) {
    var arg0 = _platform.api2wire_BdkDescriptor(descriptor);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_as_string__static_method__Api(port_, arg0),
      parseSuccessData: _wire2api_String,
      constMeta: kAsStringStaticMethodApiConstMeta,
      argValues: [
        descriptor
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kAsStringStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "as_string__static_method__Api",
        argNames: [
          "descriptor"
        ],
      );

  Future<AddressInfo> deriveAddressAtStaticMethodApi({required BdkDescriptor descriptor, required int index, required Network network, dynamic hint}) {
    var arg0 = _platform.api2wire_BdkDescriptor(descriptor);
    var arg1 = api2wire_u32(index);
    var arg2 = api2wire_network(network);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_derive_address_at__static_method__Api(port_, arg0, arg1, arg2),
      parseSuccessData: _wire2api_address_info,
      constMeta: kDeriveAddressAtStaticMethodApiConstMeta,
      argValues: [
        descriptor,
        index,
        network
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kDeriveAddressAtStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "derive_address_at__static_method__Api",
        argNames: [
          "descriptor",
          "index",
          "network"
        ],
      );

  Future<String> createDescriptorSecretStaticMethodApi({required Network network, required String mnemonic, String? password, dynamic hint}) {
    var arg0 = api2wire_network(network);
    var arg1 = _platform.api2wire_String(mnemonic);
    var arg2 = _platform.api2wire_opt_String(password);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_create_descriptor_secret__static_method__Api(port_, arg0, arg1, arg2),
      parseSuccessData: _wire2api_String,
      constMeta: kCreateDescriptorSecretStaticMethodApiConstMeta,
      argValues: [
        network,
        mnemonic,
        password
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kCreateDescriptorSecretStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "create_descriptor_secret__static_method__Api",
        argNames: [
          "network",
          "mnemonic",
          "password"
        ],
      );

  Future<String> createDerivedDescriptorSecretStaticMethodApi({required Network network, required String mnemonic, required String path, String? password, dynamic hint}) {
    var arg0 = api2wire_network(network);
    var arg1 = _platform.api2wire_String(mnemonic);
    var arg2 = _platform.api2wire_String(path);
    var arg3 = _platform.api2wire_opt_String(password);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_create_derived_descriptor_secret__static_method__Api(port_, arg0, arg1, arg2, arg3),
      parseSuccessData: _wire2api_String,
      constMeta: kCreateDerivedDescriptorSecretStaticMethodApiConstMeta,
      argValues: [
        network,
        mnemonic,
        path,
        password
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kCreateDerivedDescriptorSecretStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "create_derived_descriptor_secret__static_method__Api",
        argNames: [
          "network",
          "mnemonic",
          "path",
          "password"
        ],
      );

  Future<String> descriptorSecretFromStringStaticMethodApi({required String secret, dynamic hint}) {
    var arg0 = _platform.api2wire_String(secret);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_descriptor_secret_from_string__static_method__Api(port_, arg0),
      parseSuccessData: _wire2api_String,
      constMeta: kDescriptorSecretFromStringStaticMethodApiConstMeta,
      argValues: [
        secret
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kDescriptorSecretFromStringStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "descriptor_secret_from_string__static_method__Api",
        argNames: [
          "secret"
        ],
      );

  Future<String> extendDescriptorSecretStaticMethodApi({required String secret, required String path, dynamic hint}) {
    var arg0 = _platform.api2wire_String(secret);
    var arg1 = _platform.api2wire_String(path);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_extend_descriptor_secret__static_method__Api(port_, arg0, arg1),
      parseSuccessData: _wire2api_String,
      constMeta: kExtendDescriptorSecretStaticMethodApiConstMeta,
      argValues: [
        secret,
        path
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kExtendDescriptorSecretStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "extend_descriptor_secret__static_method__Api",
        argNames: [
          "secret",
          "path"
        ],
      );

  Future<String> deriveDescriptorSecretStaticMethodApi({required String secret, required String path, dynamic hint}) {
    var arg0 = _platform.api2wire_String(secret);
    var arg1 = _platform.api2wire_String(path);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_derive_descriptor_secret__static_method__Api(port_, arg0, arg1),
      parseSuccessData: _wire2api_String,
      constMeta: kDeriveDescriptorSecretStaticMethodApiConstMeta,
      argValues: [
        secret,
        path
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kDeriveDescriptorSecretStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "derive_descriptor_secret__static_method__Api",
        argNames: [
          "secret",
          "path"
        ],
      );

  Future<Uint8List> asSecretBytesStaticMethodApi({required String secret, dynamic hint}) {
    var arg0 = _platform.api2wire_String(secret);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_as_secret_bytes__static_method__Api(port_, arg0),
      parseSuccessData: _wire2api_uint_8_list,
      constMeta: kAsSecretBytesStaticMethodApiConstMeta,
      argValues: [
        secret
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kAsSecretBytesStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "as_secret_bytes__static_method__Api",
        argNames: [
          "secret"
        ],
      );

  Future<String> asPublicStaticMethodApi({required String secret, dynamic hint}) {
    var arg0 = _platform.api2wire_String(secret);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_as_public__static_method__Api(port_, arg0),
      parseSuccessData: _wire2api_String,
      constMeta: kAsPublicStaticMethodApiConstMeta,
      argValues: [
        secret
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kAsPublicStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "as_public__static_method__Api",
        argNames: [
          "secret"
        ],
      );

  Future<String> getPubFromSecretBytesStaticMethodApi({required Uint8List bytes, dynamic hint}) {
    var arg0 = _platform.api2wire_uint_8_list(bytes);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_get_pub_from_secret_bytes__static_method__Api(port_, arg0),
      parseSuccessData: _wire2api_String,
      constMeta: kGetPubFromSecretBytesStaticMethodApiConstMeta,
      argValues: [
        bytes
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kGetPubFromSecretBytesStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "get_pub_from_secret_bytes__static_method__Api",
        argNames: [
          "bytes"
        ],
      );

  Future<String> createDerivationPathStaticMethodApi({required String path, dynamic hint}) {
    var arg0 = _platform.api2wire_String(path);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_create_derivation_path__static_method__Api(port_, arg0),
      parseSuccessData: _wire2api_String,
      constMeta: kCreateDerivationPathStaticMethodApiConstMeta,
      argValues: [
        path
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kCreateDerivationPathStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "create_derivation_path__static_method__Api",
        argNames: [
          "path"
        ],
      );

  Future<String> descriptorPublicFromStringStaticMethodApi({required String publicKey, dynamic hint}) {
    var arg0 = _platform.api2wire_String(publicKey);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_descriptor_public_from_string__static_method__Api(port_, arg0),
      parseSuccessData: _wire2api_String,
      constMeta: kDescriptorPublicFromStringStaticMethodApiConstMeta,
      argValues: [
        publicKey
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kDescriptorPublicFromStringStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "descriptor_public_from_string__static_method__Api",
        argNames: [
          "publicKey"
        ],
      );

  Future<String> masterFinterprintStaticMethodApi({required String xpub, dynamic hint}) {
    var arg0 = _platform.api2wire_String(xpub);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_master_finterprint__static_method__Api(port_, arg0),
      parseSuccessData: _wire2api_String,
      constMeta: kMasterFinterprintStaticMethodApiConstMeta,
      argValues: [
        xpub
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kMasterFinterprintStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "master_finterprint__static_method__Api",
        argNames: [
          "xpub"
        ],
      );

  Future<String> createDescriptorPublicStaticMethodApi({String? xpub, required String path, required bool derive, dynamic hint}) {
    var arg0 = _platform.api2wire_opt_String(xpub);
    var arg1 = _platform.api2wire_String(path);
    var arg2 = derive;
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_create_descriptor_public__static_method__Api(port_, arg0, arg1, arg2),
      parseSuccessData: _wire2api_String,
      constMeta: kCreateDescriptorPublicStaticMethodApiConstMeta,
      argValues: [
        xpub,
        path,
        derive
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kCreateDescriptorPublicStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "create_descriptor_public__static_method__Api",
        argNames: [
          "xpub",
          "path",
          "derive"
        ],
      );

  Future<String> toPublicStringStaticMethodApi({required String xpub, dynamic hint}) {
    var arg0 = _platform.api2wire_String(xpub);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_to_public_string__static_method__Api(port_, arg0),
      parseSuccessData: _wire2api_String,
      constMeta: kToPublicStringStaticMethodApiConstMeta,
      argValues: [
        xpub
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kToPublicStringStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "to_public_string__static_method__Api",
        argNames: [
          "xpub"
        ],
      );

  Future<Script> createScriptStaticMethodApi({required Uint8List rawOutputScript, dynamic hint}) {
    var arg0 = _platform.api2wire_uint_8_list(rawOutputScript);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_create_script__static_method__Api(port_, arg0),
      parseSuccessData: _wire2api_script,
      constMeta: kCreateScriptStaticMethodApiConstMeta,
      argValues: [
        rawOutputScript
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kCreateScriptStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "create_script__static_method__Api",
        argNames: [
          "rawOutputScript"
        ],
      );

  Future<String> createAddressStaticMethodApi({required String address, dynamic hint}) {
    var arg0 = _platform.api2wire_String(address);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_create_address__static_method__Api(port_, arg0),
      parseSuccessData: _wire2api_String,
      constMeta: kCreateAddressStaticMethodApiConstMeta,
      argValues: [
        address
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kCreateAddressStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "create_address__static_method__Api",
        argNames: [
          "address"
        ],
      );

  Future<String> addressFromScriptStaticMethodApi({required Script script, required Network network, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_script(script);
    var arg1 = api2wire_network(network);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_address_from_script__static_method__Api(port_, arg0, arg1),
      parseSuccessData: _wire2api_String,
      constMeta: kAddressFromScriptStaticMethodApiConstMeta,
      argValues: [
        script,
        network
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kAddressFromScriptStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "address_from_script__static_method__Api",
        argNames: [
          "script",
          "network"
        ],
      );

  Future<Script> addressToScriptPubkeyStaticMethodApi({required String address, dynamic hint}) {
    var arg0 = _platform.api2wire_String(address);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_address_to_script_pubkey__static_method__Api(port_, arg0),
      parseSuccessData: _wire2api_script,
      constMeta: kAddressToScriptPubkeyStaticMethodApiConstMeta,
      argValues: [
        address
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kAddressToScriptPubkeyStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "address_to_script_pubkey__static_method__Api",
        argNames: [
          "address"
        ],
      );

  Future<Payload> payloadStaticMethodApi({required String address, dynamic hint}) {
    var arg0 = _platform.api2wire_String(address);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_payload__static_method__Api(port_, arg0),
      parseSuccessData: _wire2api_payload,
      constMeta: kPayloadStaticMethodApiConstMeta,
      argValues: [
        address
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kPayloadStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "payload__static_method__Api",
        argNames: [
          "address"
        ],
      );

  Future<Network> addressNetworkStaticMethodApi({required String address, dynamic hint}) {
    var arg0 = _platform.api2wire_String(address);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_address_network__static_method__Api(port_, arg0),
      parseSuccessData: _wire2api_network,
      constMeta: kAddressNetworkStaticMethodApiConstMeta,
      argValues: [
        address
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kAddressNetworkStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "address_network__static_method__Api",
        argNames: [
          "address"
        ],
      );

  Future<String> getAddressTypeStaticMethodApi({required String address, dynamic hint}) {
    var arg0 = _platform.api2wire_String(address);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_get_address_type__static_method__Api(port_, arg0),
      parseSuccessData: _wire2api_String,
      constMeta: kGetAddressTypeStaticMethodApiConstMeta,
      argValues: [
        address
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kGetAddressTypeStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "get_address_type__static_method__Api",
        argNames: [
          "address"
        ],
      );

  Future<WalletInstance> createWalletStaticMethodApi({required BdkDescriptor descriptor, BdkDescriptor? changeDescriptor, required Network network, required DatabaseConfig databaseConfig, dynamic hint}) {
    var arg0 = _platform.api2wire_BdkDescriptor(descriptor);
    var arg1 = _platform.api2wire_opt_box_autoadd_BdkDescriptor(changeDescriptor);
    var arg2 = api2wire_network(network);
    var arg3 = _platform.api2wire_box_autoadd_database_config(databaseConfig);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_create_wallet__static_method__Api(port_, arg0, arg1, arg2, arg3),
      parseSuccessData: _wire2api_WalletInstance,
      constMeta: kCreateWalletStaticMethodApiConstMeta,
      argValues: [
        descriptor,
        changeDescriptor,
        network,
        databaseConfig
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kCreateWalletStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "create_wallet__static_method__Api",
        argNames: [
          "descriptor",
          "changeDescriptor",
          "network",
          "databaseConfig"
        ],
      );

  Future<AddressInfo> getAddressStaticMethodApi({required WalletInstance wallet, required AddressIndex addressIndex, dynamic hint}) {
    var arg0 = _platform.api2wire_WalletInstance(wallet);
    var arg1 = _platform.api2wire_box_autoadd_address_index(addressIndex);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_get_address__static_method__Api(port_, arg0, arg1),
      parseSuccessData: _wire2api_address_info,
      constMeta: kGetAddressStaticMethodApiConstMeta,
      argValues: [
        wallet,
        addressIndex
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kGetAddressStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "get_address__static_method__Api",
        argNames: [
          "wallet",
          "addressIndex"
        ],
      );

  Future<AddressInfo> getInternalAddressStaticMethodApi({required WalletInstance wallet, required AddressIndex addressIndex, dynamic hint}) {
    var arg0 = _platform.api2wire_WalletInstance(wallet);
    var arg1 = _platform.api2wire_box_autoadd_address_index(addressIndex);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_get_internal_address__static_method__Api(port_, arg0, arg1),
      parseSuccessData: _wire2api_address_info,
      constMeta: kGetInternalAddressStaticMethodApiConstMeta,
      argValues: [
        wallet,
        addressIndex
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kGetInternalAddressStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "get_internal_address__static_method__Api",
        argNames: [
          "wallet",
          "addressIndex"
        ],
      );

  Future<void> syncWalletStaticMethodApi({required WalletInstance wallet, required BlockchainInstance blockchain, dynamic hint}) {
    var arg0 = _platform.api2wire_WalletInstance(wallet);
    var arg1 = _platform.api2wire_BlockchainInstance(blockchain);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_sync_wallet__static_method__Api(port_, arg0, arg1),
      parseSuccessData: _wire2api_unit,
      constMeta: kSyncWalletStaticMethodApiConstMeta,
      argValues: [
        wallet,
        blockchain
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kSyncWalletStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "sync_wallet__static_method__Api",
        argNames: [
          "wallet",
          "blockchain"
        ],
      );

  Future<void> syncWalletThreadStaticMethodApi({required WalletInstance wallet, required BlockchainInstance blockchain, dynamic hint}) {
    var arg0 = _platform.api2wire_WalletInstance(wallet);
    var arg1 = _platform.api2wire_BlockchainInstance(blockchain);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_sync_wallet_thread__static_method__Api(port_, arg0, arg1),
      parseSuccessData: _wire2api_unit,
      constMeta: kSyncWalletThreadStaticMethodApiConstMeta,
      argValues: [
        wallet,
        blockchain
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kSyncWalletThreadStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "sync_wallet_thread__static_method__Api",
        argNames: [
          "wallet",
          "blockchain"
        ],
      );

  Future<Balance> getBalanceStaticMethodApi({required WalletInstance wallet, dynamic hint}) {
    var arg0 = _platform.api2wire_WalletInstance(wallet);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_get_balance__static_method__Api(port_, arg0),
      parseSuccessData: _wire2api_balance,
      constMeta: kGetBalanceStaticMethodApiConstMeta,
      argValues: [
        wallet
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kGetBalanceStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "get_balance__static_method__Api",
        argNames: [
          "wallet"
        ],
      );

  Future<List<LocalUtxo>> listUnspentOutputsStaticMethodApi({required WalletInstance wallet, dynamic hint}) {
    var arg0 = _platform.api2wire_WalletInstance(wallet);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_list_unspent_outputs__static_method__Api(port_, arg0),
      parseSuccessData: _wire2api_list_local_utxo,
      constMeta: kListUnspentOutputsStaticMethodApiConstMeta,
      argValues: [
        wallet
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kListUnspentOutputsStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "list_unspent_outputs__static_method__Api",
        argNames: [
          "wallet"
        ],
      );

  Future<List<TransactionDetails>> getTransactionsStaticMethodApi({required WalletInstance wallet, required bool includeRaw, dynamic hint}) {
    var arg0 = _platform.api2wire_WalletInstance(wallet);
    var arg1 = includeRaw;
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_get_transactions__static_method__Api(port_, arg0, arg1),
      parseSuccessData: _wire2api_list_transaction_details,
      constMeta: kGetTransactionsStaticMethodApiConstMeta,
      argValues: [
        wallet,
        includeRaw
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kGetTransactionsStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "get_transactions__static_method__Api",
        argNames: [
          "wallet",
          "includeRaw"
        ],
      );

  Future<String?> signStaticMethodApi({required WalletInstance wallet, required String psbtStr, SignOptions? signOptions, dynamic hint}) {
    var arg0 = _platform.api2wire_WalletInstance(wallet);
    var arg1 = _platform.api2wire_String(psbtStr);
    var arg2 = _platform.api2wire_opt_box_autoadd_sign_options(signOptions);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_sign__static_method__Api(port_, arg0, arg1, arg2),
      parseSuccessData: _wire2api_opt_String,
      constMeta: kSignStaticMethodApiConstMeta,
      argValues: [
        wallet,
        psbtStr,
        signOptions
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kSignStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "sign__static_method__Api",
        argNames: [
          "wallet",
          "psbtStr",
          "signOptions"
        ],
      );

  Future<Network> walletNetworkStaticMethodApi({required WalletInstance wallet, dynamic hint}) {
    var arg0 = _platform.api2wire_WalletInstance(wallet);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_wallet_network__static_method__Api(port_, arg0),
      parseSuccessData: _wire2api_network,
      constMeta: kWalletNetworkStaticMethodApiConstMeta,
      argValues: [
        wallet
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kWalletNetworkStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "wallet_network__static_method__Api",
        argNames: [
          "wallet"
        ],
      );

  Future<List<LocalUtxo>> listUnspentStaticMethodApi({required WalletInstance wallet, dynamic hint}) {
    var arg0 = _platform.api2wire_WalletInstance(wallet);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_list_unspent__static_method__Api(port_, arg0),
      parseSuccessData: _wire2api_list_local_utxo,
      constMeta: kListUnspentStaticMethodApiConstMeta,
      argValues: [
        wallet
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kListUnspentStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "list_unspent__static_method__Api",
        argNames: [
          "wallet"
        ],
      );

  Future<bool> cacheAddressStaticMethodApi({required WalletInstance wallet, required int cacheSize, dynamic hint}) {
    var arg0 = _platform.api2wire_WalletInstance(wallet);
    var arg1 = api2wire_u32(cacheSize);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_cache_address__static_method__Api(port_, arg0, arg1),
      parseSuccessData: _wire2api_bool,
      constMeta: kCacheAddressStaticMethodApiConstMeta,
      argValues: [
        wallet,
        cacheSize
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kCacheAddressStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "cache_address__static_method__Api",
        argNames: [
          "wallet",
          "cacheSize"
        ],
      );

  Future<String> generateSeedFromWordCountStaticMethodApi({required WordCount wordCount, dynamic hint}) {
    var arg0 = api2wire_word_count(wordCount);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_generate_seed_from_word_count__static_method__Api(port_, arg0),
      parseSuccessData: _wire2api_String,
      constMeta: kGenerateSeedFromWordCountStaticMethodApiConstMeta,
      argValues: [
        wordCount
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kGenerateSeedFromWordCountStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "generate_seed_from_word_count__static_method__Api",
        argNames: [
          "wordCount"
        ],
      );

  Future<String> generateSeedFromStringStaticMethodApi({required String mnemonic, dynamic hint}) {
    var arg0 = _platform.api2wire_String(mnemonic);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_generate_seed_from_string__static_method__Api(port_, arg0),
      parseSuccessData: _wire2api_String,
      constMeta: kGenerateSeedFromStringStaticMethodApiConstMeta,
      argValues: [
        mnemonic
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kGenerateSeedFromStringStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "generate_seed_from_string__static_method__Api",
        argNames: [
          "mnemonic"
        ],
      );

  Future<String> generateSeedFromEntropyStaticMethodApi({required Uint8List entropy, dynamic hint}) {
    var arg0 = _platform.api2wire_uint_8_list(entropy);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_generate_seed_from_entropy__static_method__Api(port_, arg0),
      parseSuccessData: _wire2api_String,
      constMeta: kGenerateSeedFromEntropyStaticMethodApiConstMeta,
      argValues: [
        entropy
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kGenerateSeedFromEntropyStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "generate_seed_from_entropy__static_method__Api",
        argNames: [
          "entropy"
        ],
      );

  Future<String> bip322SignSegwitStaticMethodApi({required Uint8List secret, required String message, dynamic hint}) {
    var arg0 = _platform.api2wire_uint_8_list(secret);
    var arg1 = _platform.api2wire_String(message);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_bip322_sign_segwit__static_method__Api(port_, arg0, arg1),
      parseSuccessData: _wire2api_String,
      constMeta: kBip322SignSegwitStaticMethodApiConstMeta,
      argValues: [
        secret,
        message
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kBip322SignSegwitStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "bip322_sign_segwit__static_method__Api",
        argNames: [
          "secret",
          "message"
        ],
      );

  Future<String> bip322SignTaprootStaticMethodApi({required Uint8List secret, required String message, dynamic hint}) {
    var arg0 = _platform.api2wire_uint_8_list(secret);
    var arg1 = _platform.api2wire_String(message);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_bip322_sign_taproot__static_method__Api(port_, arg0, arg1),
      parseSuccessData: _wire2api_String,
      constMeta: kBip322SignTaprootStaticMethodApiConstMeta,
      argValues: [
        secret,
        message
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kBip322SignTaprootStaticMethodApiConstMeta => const FlutterRustBridgeTaskConstMeta(
        debugName: "bip322_sign_taproot__static_method__Api",
        argNames: [
          "secret",
          "message"
        ],
      );

  DropFnType get dropOpaqueBdkDescriptor => _platform.inner.drop_opaque_BdkDescriptor;
  ShareFnType get shareOpaqueBdkDescriptor => _platform.inner.share_opaque_BdkDescriptor;
  OpaqueTypeFinalizer get BdkDescriptorFinalizer => _platform.BdkDescriptorFinalizer;

  DropFnType get dropOpaqueBlockchainInstance => _platform.inner.drop_opaque_BlockchainInstance;
  ShareFnType get shareOpaqueBlockchainInstance => _platform.inner.share_opaque_BlockchainInstance;
  OpaqueTypeFinalizer get BlockchainInstanceFinalizer => _platform.BlockchainInstanceFinalizer;

  DropFnType get dropOpaqueWalletInstance => _platform.inner.drop_opaque_WalletInstance;
  ShareFnType get shareOpaqueWalletInstance => _platform.inner.share_opaque_WalletInstance;
  OpaqueTypeFinalizer get WalletInstanceFinalizer => _platform.WalletInstanceFinalizer;

  void dispose() {
    _platform.dispose();
  }
// Section: wire2api

  BdkDescriptor _wire2api_BdkDescriptor(dynamic raw) {
    return BdkDescriptor.fromRaw(raw[0], raw[1], this);
  }

  BlockchainInstance _wire2api_BlockchainInstance(dynamic raw) {
    return BlockchainInstance.fromRaw(raw[0], raw[1], this);
  }

  String _wire2api_String(dynamic raw) {
    return raw as String;
  }

  List<String> _wire2api_StringList(dynamic raw) {
    return (raw as List<dynamic>).cast<String>();
  }

  WalletInstance _wire2api_WalletInstance(dynamic raw) {
    return WalletInstance.fromRaw(raw[0], raw[1], this);
  }

  AddressInfo _wire2api_address_info(dynamic raw) {
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return AddressInfo(
      index: _wire2api_u32(arr[0]),
      address: _wire2api_String(arr[1]),
    );
  }

  Balance _wire2api_balance(dynamic raw) {
    final arr = raw as List<dynamic>;
    if (arr.length != 6) throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return Balance(
      immature: _wire2api_u64(arr[0]),
      trustedPending: _wire2api_u64(arr[1]),
      untrustedPending: _wire2api_u64(arr[2]),
      confirmed: _wire2api_u64(arr[3]),
      spendable: _wire2api_u64(arr[4]),
      total: _wire2api_u64(arr[5]),
    );
  }

  BdkTxBuilderResult _wire2api_bdk_tx_builder_result(dynamic raw) {
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return BdkTxBuilderResult(
      field0: _wire2api_String(arr[0]),
      field1: _wire2api_transaction_details(arr[1]),
    );
  }

  BlockTime _wire2api_block_time(dynamic raw) {
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return BlockTime(
      height: _wire2api_u32(arr[0]),
      timestamp: _wire2api_u64(arr[1]),
    );
  }

  bool _wire2api_bool(dynamic raw) {
    return raw as bool;
  }

  BlockTime _wire2api_box_autoadd_block_time(dynamic raw) {
    return _wire2api_block_time(raw);
  }

  double _wire2api_box_autoadd_f32(dynamic raw) {
    return raw as double;
  }

  int _wire2api_box_autoadd_u64(dynamic raw) {
    return _wire2api_u64(raw);
  }

  ED25519Res _wire2api_ed_25519_res(dynamic raw) {
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ED25519Res(
      seed: _wire2api_uint_8_list(arr[0]),
      publicKey: _wire2api_uint_8_list(arr[1]),
    );
  }

  double _wire2api_f32(dynamic raw) {
    return raw as double;
  }

  int _wire2api_i32(dynamic raw) {
    return raw as int;
  }

  KeyDerivedRes _wire2api_key_derived_res(dynamic raw) {
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return KeyDerivedRes(
      leftBits: _wire2api_uint_8_list(arr[0]),
      rightBits: _wire2api_uint_8_list(arr[1]),
    );
  }

  KeychainKind _wire2api_keychain_kind(dynamic raw) {
    return KeychainKind.values[raw as int];
  }

  List<LocalUtxo> _wire2api_list_local_utxo(dynamic raw) {
    return (raw as List<dynamic>).map(_wire2api_local_utxo).toList();
  }

  List<TransactionDetails> _wire2api_list_transaction_details(dynamic raw) {
    return (raw as List<dynamic>).map(_wire2api_transaction_details).toList();
  }

  List<TxIn> _wire2api_list_tx_in(dynamic raw) {
    return (raw as List<dynamic>).map(_wire2api_tx_in).toList();
  }

  List<TxOut> _wire2api_list_tx_out(dynamic raw) {
    return (raw as List<dynamic>).map(_wire2api_tx_out).toList();
  }

  LocalUtxo _wire2api_local_utxo(dynamic raw) {
    final arr = raw as List<dynamic>;
    if (arr.length != 4) throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return LocalUtxo(
      outpoint: _wire2api_out_point(arr[0]),
      txout: _wire2api_tx_out(arr[1]),
      isSpent: _wire2api_bool(arr[2]),
      keychain: _wire2api_keychain_kind(arr[3]),
    );
  }

  Network _wire2api_network(dynamic raw) {
    return Network.values[raw as int];
  }

  String? _wire2api_opt_String(dynamic raw) {
    return raw == null ? null : _wire2api_String(raw);
  }

  BlockTime? _wire2api_opt_box_autoadd_block_time(dynamic raw) {
    return raw == null ? null : _wire2api_box_autoadd_block_time(raw);
  }

  double? _wire2api_opt_box_autoadd_f32(dynamic raw) {
    return raw == null ? null : _wire2api_box_autoadd_f32(raw);
  }

  int? _wire2api_opt_box_autoadd_u64(dynamic raw) {
    return raw == null ? null : _wire2api_box_autoadd_u64(raw);
  }

  Uint8List? _wire2api_opt_uint_8_list(dynamic raw) {
    return raw == null ? null : _wire2api_uint_8_list(raw);
  }

  OutPoint _wire2api_out_point(dynamic raw) {
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return OutPoint(
      txid: _wire2api_String(arr[0]),
      vout: _wire2api_u32(arr[1]),
    );
  }

  P256IdentityExport _wire2api_p_256_identity_export(dynamic raw) {
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return P256IdentityExport(
      privateKeyHash: _wire2api_uint_8_list(arr[0]),
      derEncodedPublicKey: _wire2api_uint_8_list(arr[1]),
    );
  }

  Payload _wire2api_payload(dynamic raw) {
    switch (raw[0]) {
      case 0:
        return Payload_PubkeyHash(
          pubkeyHash: _wire2api_uint_8_list(raw[1]),
        );
      case 1:
        return Payload_ScriptHash(
          scriptHash: _wire2api_uint_8_list(raw[1]),
        );
      case 2:
        return Payload_WitnessProgram(
          version: _wire2api_witness_version(raw[1]),
          program: _wire2api_uint_8_list(raw[2]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  SchnorrIdentityExport _wire2api_schnorr_identity_export(dynamic raw) {
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return SchnorrIdentityExport(
      privateKeyHash: _wire2api_uint_8_list(arr[0]),
      publicKeyHash: _wire2api_uint_8_list(arr[1]),
    );
  }

  Script _wire2api_script(dynamic raw) {
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return Script(
      internal: _wire2api_uint_8_list(arr[0]),
    );
  }

  Secp256k1IdentityExport _wire2api_secp_256_k_1_identity_export(dynamic raw) {
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return Secp256k1IdentityExport(
      privateKeyHash: _wire2api_uint_8_list(arr[0]),
      derEncodedPublicKey: _wire2api_uint_8_list(arr[1]),
    );
  }

  SignatureFFI _wire2api_signature_ffi(dynamic raw) {
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return SignatureFFI(
      publicKey: _wire2api_opt_uint_8_list(arr[0]),
      signature: _wire2api_opt_uint_8_list(arr[1]),
    );
  }

  TransactionDetails _wire2api_transaction_details(dynamic raw) {
    final arr = raw as List<dynamic>;
    if (arr.length != 6) throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return TransactionDetails(
      serializedTx: _wire2api_opt_String(arr[0]),
      txid: _wire2api_String(arr[1]),
      received: _wire2api_u64(arr[2]),
      sent: _wire2api_u64(arr[3]),
      fee: _wire2api_opt_box_autoadd_u64(arr[4]),
      confirmationTime: _wire2api_opt_box_autoadd_block_time(arr[5]),
    );
  }

  TxIn _wire2api_tx_in(dynamic raw) {
    final arr = raw as List<dynamic>;
    if (arr.length != 4) throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return TxIn(
      previousOutput: _wire2api_out_point(arr[0]),
      scriptSig: _wire2api_script(arr[1]),
      sequence: _wire2api_u32(arr[2]),
      witness: _wire2api_StringList(arr[3]),
    );
  }

  TxOut _wire2api_tx_out(dynamic raw) {
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return TxOut(
      value: _wire2api_u64(arr[0]),
      scriptPubkey: _wire2api_script(arr[1]),
    );
  }

  int _wire2api_u32(dynamic raw) {
    return raw as int;
  }

  int _wire2api_u64(dynamic raw) {
    return castInt(raw);
  }

  int _wire2api_u8(dynamic raw) {
    return raw as int;
  }

  Uint8List _wire2api_uint_8_list(dynamic raw) {
    return raw as Uint8List;
  }

  void _wire2api_unit(dynamic raw) {
    return;
  }

  WitnessVersion _wire2api_witness_version(dynamic raw) {
    return WitnessVersion.values[raw as int];
  }
}

// Section: api2wire

@protected
bool api2wire_bool(bool raw) {
  return raw;
}

@protected
int api2wire_change_spend_policy(ChangeSpendPolicy raw) {
  return api2wire_i32(raw.index);
}

@protected
double api2wire_f32(double raw) {
  return raw;
}

@protected
int api2wire_i32(int raw) {
  return raw;
}

@protected
int api2wire_keychain_kind(KeychainKind raw) {
  return api2wire_i32(raw.index);
}

@protected
int api2wire_network(Network raw) {
  return api2wire_i32(raw.index);
}

@protected
int api2wire_u32(int raw) {
  return raw;
}

@protected
int api2wire_u8(int raw) {
  return raw;
}

@protected
int api2wire_word_count(WordCount raw) {
  return api2wire_i32(raw.index);
}
// Section: finalizer
